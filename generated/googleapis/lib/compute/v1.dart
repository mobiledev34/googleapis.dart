// This is a generated file (see the discoveryapis_generator project).

library googleapis.compute.v1;

import 'dart:core' as core;
import 'dart:async' as async;
import 'dart:convert' as convert;

import 'package:_discoveryapis_commons/_discoveryapis_commons.dart' as commons;
import 'package:http/http.dart' as http;

export 'package:_discoveryapis_commons/_discoveryapis_commons.dart'
    show ApiRequestError, DetailedApiRequestError;

const core.String USER_AGENT = 'dart-api-client compute/v1';

/// Creates and runs virtual machines on Google Cloud Platform.
class ComputeApi {
  /// View and manage your data across Google Cloud Platform services
  static const CloudPlatformScope =
      "https://www.googleapis.com/auth/cloud-platform";

  /// View and manage your Google Compute Engine resources
  static const ComputeScope = "https://www.googleapis.com/auth/compute";

  /// View your Google Compute Engine resources
  static const ComputeReadonlyScope =
      "https://www.googleapis.com/auth/compute.readonly";

  /// Manage your data and permissions in Google Cloud Storage
  static const DevstorageFullControlScope =
      "https://www.googleapis.com/auth/devstorage.full_control";

  /// View your data in Google Cloud Storage
  static const DevstorageReadOnlyScope =
      "https://www.googleapis.com/auth/devstorage.read_only";

  /// Manage your data in Google Cloud Storage
  static const DevstorageReadWriteScope =
      "https://www.googleapis.com/auth/devstorage.read_write";

  final commons.ApiRequester _requester;

  AcceleratorTypesResourceApi get acceleratorTypes =>
      new AcceleratorTypesResourceApi(_requester);
  AddressesResourceApi get addresses => new AddressesResourceApi(_requester);
  AutoscalersResourceApi get autoscalers =>
      new AutoscalersResourceApi(_requester);
  BackendBucketsResourceApi get backendBuckets =>
      new BackendBucketsResourceApi(_requester);
  BackendServicesResourceApi get backendServices =>
      new BackendServicesResourceApi(_requester);
  DiskTypesResourceApi get diskTypes => new DiskTypesResourceApi(_requester);
  DisksResourceApi get disks => new DisksResourceApi(_requester);
  FirewallsResourceApi get firewalls => new FirewallsResourceApi(_requester);
  ForwardingRulesResourceApi get forwardingRules =>
      new ForwardingRulesResourceApi(_requester);
  GlobalAddressesResourceApi get globalAddresses =>
      new GlobalAddressesResourceApi(_requester);
  GlobalForwardingRulesResourceApi get globalForwardingRules =>
      new GlobalForwardingRulesResourceApi(_requester);
  GlobalOperationsResourceApi get globalOperations =>
      new GlobalOperationsResourceApi(_requester);
  HealthChecksResourceApi get healthChecks =>
      new HealthChecksResourceApi(_requester);
  HttpHealthChecksResourceApi get httpHealthChecks =>
      new HttpHealthChecksResourceApi(_requester);
  HttpsHealthChecksResourceApi get httpsHealthChecks =>
      new HttpsHealthChecksResourceApi(_requester);
  ImagesResourceApi get images => new ImagesResourceApi(_requester);
  InstanceGroupManagersResourceApi get instanceGroupManagers =>
      new InstanceGroupManagersResourceApi(_requester);
  InstanceGroupsResourceApi get instanceGroups =>
      new InstanceGroupsResourceApi(_requester);
  InstanceTemplatesResourceApi get instanceTemplates =>
      new InstanceTemplatesResourceApi(_requester);
  InstancesResourceApi get instances => new InstancesResourceApi(_requester);
  InterconnectAttachmentsResourceApi get interconnectAttachments =>
      new InterconnectAttachmentsResourceApi(_requester);
  InterconnectLocationsResourceApi get interconnectLocations =>
      new InterconnectLocationsResourceApi(_requester);
  InterconnectsResourceApi get interconnects =>
      new InterconnectsResourceApi(_requester);
  LicensesResourceApi get licenses => new LicensesResourceApi(_requester);
  MachineTypesResourceApi get machineTypes =>
      new MachineTypesResourceApi(_requester);
  NetworksResourceApi get networks => new NetworksResourceApi(_requester);
  ProjectsResourceApi get projects => new ProjectsResourceApi(_requester);
  RegionAutoscalersResourceApi get regionAutoscalers =>
      new RegionAutoscalersResourceApi(_requester);
  RegionBackendServicesResourceApi get regionBackendServices =>
      new RegionBackendServicesResourceApi(_requester);
  RegionCommitmentsResourceApi get regionCommitments =>
      new RegionCommitmentsResourceApi(_requester);
  RegionInstanceGroupManagersResourceApi get regionInstanceGroupManagers =>
      new RegionInstanceGroupManagersResourceApi(_requester);
  RegionInstanceGroupsResourceApi get regionInstanceGroups =>
      new RegionInstanceGroupsResourceApi(_requester);
  RegionOperationsResourceApi get regionOperations =>
      new RegionOperationsResourceApi(_requester);
  RegionsResourceApi get regions => new RegionsResourceApi(_requester);
  RoutersResourceApi get routers => new RoutersResourceApi(_requester);
  RoutesResourceApi get routes => new RoutesResourceApi(_requester);
  SnapshotsResourceApi get snapshots => new SnapshotsResourceApi(_requester);
  SslCertificatesResourceApi get sslCertificates =>
      new SslCertificatesResourceApi(_requester);
  SubnetworksResourceApi get subnetworks =>
      new SubnetworksResourceApi(_requester);
  TargetHttpProxiesResourceApi get targetHttpProxies =>
      new TargetHttpProxiesResourceApi(_requester);
  TargetHttpsProxiesResourceApi get targetHttpsProxies =>
      new TargetHttpsProxiesResourceApi(_requester);
  TargetInstancesResourceApi get targetInstances =>
      new TargetInstancesResourceApi(_requester);
  TargetPoolsResourceApi get targetPools =>
      new TargetPoolsResourceApi(_requester);
  TargetSslProxiesResourceApi get targetSslProxies =>
      new TargetSslProxiesResourceApi(_requester);
  TargetTcpProxiesResourceApi get targetTcpProxies =>
      new TargetTcpProxiesResourceApi(_requester);
  TargetVpnGatewaysResourceApi get targetVpnGateways =>
      new TargetVpnGatewaysResourceApi(_requester);
  UrlMapsResourceApi get urlMaps => new UrlMapsResourceApi(_requester);
  VpnTunnelsResourceApi get vpnTunnels => new VpnTunnelsResourceApi(_requester);
  ZoneOperationsResourceApi get zoneOperations =>
      new ZoneOperationsResourceApi(_requester);
  ZonesResourceApi get zones => new ZonesResourceApi(_requester);

  ComputeApi(http.Client client,
      {core.String rootUrl: "https://www.googleapis.com/",
      core.String servicePath: "compute/v1/projects/"})
      : _requester =
            new commons.ApiRequester(client, rootUrl, servicePath, USER_AGENT);
}

class AcceleratorTypesResourceApi {
  final commons.ApiRequester _requester;

  AcceleratorTypesResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Retrieves an aggregated list of accelerator types.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [AcceleratorTypeAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<AcceleratorTypeAggregatedList> aggregatedList(
      core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/aggregated/acceleratorTypes';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new AcceleratorTypeAggregatedList.fromJson(data));
  }

  /// Returns the specified accelerator type. Get a list of available
  /// accelerator types by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [acceleratorType] - Name of the accelerator type to return.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [AcceleratorType].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<AcceleratorType> get(
      core.String project, core.String zone, core.String acceleratorType,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (acceleratorType == null) {
      throw new core.ArgumentError("Parameter acceleratorType is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/acceleratorTypes/' +
        commons.Escaper.ecapeVariable('$acceleratorType');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new AcceleratorType.fromJson(data));
  }

  /// Retrieves a list of accelerator types available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [AcceleratorTypeList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<AcceleratorTypeList> list(core.String project, core.String zone,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/acceleratorTypes';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new AcceleratorTypeList.fromJson(data));
  }
}

class AddressesResourceApi {
  final commons.ApiRequester _requester;

  AddressesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of addresses.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [AddressAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<AddressAggregatedList> aggregatedList(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/aggregated/addresses';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new AddressAggregatedList.fromJson(data));
  }

  /// Deletes the specified address resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [address] - Name of the address resource to delete.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String region, core.String address,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (address == null) {
      throw new core.ArgumentError("Parameter address is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/addresses/' +
        commons.Escaper.ecapeVariable('$address');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified address resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [address] - Name of the address resource to return.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Address].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Address> get(
      core.String project, core.String region, core.String address,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (address == null) {
      throw new core.ArgumentError("Parameter address is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/addresses/' +
        commons.Escaper.ecapeVariable('$address');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Address.fromJson(data));
  }

  /// Creates an address resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      Address request, core.String project, core.String region,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/addresses';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves a list of addresses contained within the specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [AddressList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<AddressList> list(core.String project, core.String region,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/addresses';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new AddressList.fromJson(data));
  }
}

class AutoscalersResourceApi {
  final commons.ApiRequester _requester;

  AutoscalersResourceApi(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of autoscalers.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [AutoscalerAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<AutoscalerAggregatedList> aggregatedList(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/aggregated/autoscalers';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new AutoscalerAggregatedList.fromJson(data));
  }

  /// Deletes the specified autoscaler.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [autoscaler] - Name of the autoscaler to delete.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String zone, core.String autoscaler,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (autoscaler == null) {
      throw new core.ArgumentError("Parameter autoscaler is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/autoscalers/' +
        commons.Escaper.ecapeVariable('$autoscaler');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified autoscaler resource. Get a list of available
  /// autoscalers by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [autoscaler] - Name of the autoscaler to return.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Autoscaler].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Autoscaler> get(
      core.String project, core.String zone, core.String autoscaler,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (autoscaler == null) {
      throw new core.ArgumentError("Parameter autoscaler is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/autoscalers/' +
        commons.Escaper.ecapeVariable('$autoscaler');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Autoscaler.fromJson(data));
  }

  /// Creates an autoscaler in the specified project using the data included in
  /// the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      Autoscaler request, core.String project, core.String zone,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/autoscalers';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves a list of autoscalers contained within the specified zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [AutoscalerList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<AutoscalerList> list(core.String project, core.String zone,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/autoscalers';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new AutoscalerList.fromJson(data));
  }

  /// Updates an autoscaler in the specified project using the data included in
  /// the request. This method supports PATCH semantics and uses the JSON merge
  /// patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [autoscaler] - Name of the autoscaler to patch.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
      Autoscaler request, core.String project, core.String zone,
      {core.String autoscaler, core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (autoscaler != null) {
      _queryParams["autoscaler"] = [autoscaler];
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/autoscalers';

    var _response = _requester.request(_url, "PATCH",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Updates an autoscaler in the specified project using the data included in
  /// the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [autoscaler] - Name of the autoscaler to update.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
      Autoscaler request, core.String project, core.String zone,
      {core.String autoscaler, core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (autoscaler != null) {
      _queryParams["autoscaler"] = [autoscaler];
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/autoscalers';

    var _response = _requester.request(_url, "PUT",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class BackendBucketsResourceApi {
  final commons.ApiRequester _requester;

  BackendBucketsResourceApi(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified BackendBucket resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [backendBucket] - Name of the BackendBucket resource to delete.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(core.String project, core.String backendBucket,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (backendBucket == null) {
      throw new core.ArgumentError("Parameter backendBucket is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/backendBuckets/' +
        commons.Escaper.ecapeVariable('$backendBucket');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified BackendBucket resource. Get a list of available
  /// backend buckets by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [backendBucket] - Name of the BackendBucket resource to return.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [BackendBucket].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<BackendBucket> get(
      core.String project, core.String backendBucket,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (backendBucket == null) {
      throw new core.ArgumentError("Parameter backendBucket is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/backendBuckets/' +
        commons.Escaper.ecapeVariable('$backendBucket');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new BackendBucket.fromJson(data));
  }

  /// Creates a BackendBucket resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(BackendBucket request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/backendBuckets';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of BackendBucket resources available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [BackendBucketList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<BackendBucketList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/backendBuckets';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new BackendBucketList.fromJson(data));
  }

  /// Updates the specified BackendBucket resource with the data included in the
  /// request. This method supports PATCH semantics and uses the JSON merge
  /// patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [backendBucket] - Name of the BackendBucket resource to patch.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
      BackendBucket request, core.String project, core.String backendBucket,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (backendBucket == null) {
      throw new core.ArgumentError("Parameter backendBucket is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/backendBuckets/' +
        commons.Escaper.ecapeVariable('$backendBucket');

    var _response = _requester.request(_url, "PATCH",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Updates the specified BackendBucket resource with the data included in the
  /// request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [backendBucket] - Name of the BackendBucket resource to update.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
      BackendBucket request, core.String project, core.String backendBucket,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (backendBucket == null) {
      throw new core.ArgumentError("Parameter backendBucket is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/backendBuckets/' +
        commons.Escaper.ecapeVariable('$backendBucket');

    var _response = _requester.request(_url, "PUT",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class BackendServicesResourceApi {
  final commons.ApiRequester _requester;

  BackendServicesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Retrieves the list of all BackendService resources, regional and global,
  /// available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Name of the project scoping this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [BackendServiceAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<BackendServiceAggregatedList> aggregatedList(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/aggregated/backendServices';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new BackendServiceAggregatedList.fromJson(data));
  }

  /// Deletes the specified BackendService resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [backendService] - Name of the BackendService resource to delete.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String backendService,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (backendService == null) {
      throw new core.ArgumentError("Parameter backendService is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/backendServices/' +
        commons.Escaper.ecapeVariable('$backendService');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified BackendService resource. Get a list of available
  /// backend services by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [backendService] - Name of the BackendService resource to return.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [BackendService].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<BackendService> get(
      core.String project, core.String backendService,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (backendService == null) {
      throw new core.ArgumentError("Parameter backendService is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/backendServices/' +
        commons.Escaper.ecapeVariable('$backendService');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new BackendService.fromJson(data));
  }

  /// Gets the most recent health check results for this BackendService.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - null
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [backendService] - Name of the BackendService resource to which the
  /// queried instance belongs.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [BackendServiceGroupHealth].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<BackendServiceGroupHealth> getHealth(
      ResourceGroupReference request,
      core.String project,
      core.String backendService,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (backendService == null) {
      throw new core.ArgumentError("Parameter backendService is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/backendServices/' +
        commons.Escaper.ecapeVariable('$backendService') +
        '/getHealth';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new BackendServiceGroupHealth.fromJson(data));
  }

  /// Creates a BackendService resource in the specified project using the data
  /// included in the request. There are several restrictions and guidelines to
  /// keep in mind when creating a backend service. Read  Restrictions and
  /// Guidelines for more information.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(BackendService request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/backendServices';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of BackendService resources available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [BackendServiceList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<BackendServiceList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/backendServices';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new BackendServiceList.fromJson(data));
  }

  /// Patches the specified BackendService resource with the data included in
  /// the request. There are several restrictions and guidelines to keep in mind
  /// when updating a backend service. Read  Restrictions and Guidelines for
  /// more information. This method supports PATCH semantics and uses the JSON
  /// merge patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [backendService] - Name of the BackendService resource to patch.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
      BackendService request, core.String project, core.String backendService,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (backendService == null) {
      throw new core.ArgumentError("Parameter backendService is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/backendServices/' +
        commons.Escaper.ecapeVariable('$backendService');

    var _response = _requester.request(_url, "PATCH",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Updates the specified BackendService resource with the data included in
  /// the request. There are several restrictions and guidelines to keep in mind
  /// when updating a backend service. Read  Restrictions and Guidelines for
  /// more information.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [backendService] - Name of the BackendService resource to update.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
      BackendService request, core.String project, core.String backendService,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (backendService == null) {
      throw new core.ArgumentError("Parameter backendService is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/backendServices/' +
        commons.Escaper.ecapeVariable('$backendService');

    var _response = _requester.request(_url, "PUT",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class DiskTypesResourceApi {
  final commons.ApiRequester _requester;

  DiskTypesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of disk types.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [DiskTypeAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<DiskTypeAggregatedList> aggregatedList(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/aggregated/diskTypes';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new DiskTypeAggregatedList.fromJson(data));
  }

  /// Returns the specified disk type. Get a list of available disk types by
  /// making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [diskType] - Name of the disk type to return.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [DiskType].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<DiskType> get(
      core.String project, core.String zone, core.String diskType,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (diskType == null) {
      throw new core.ArgumentError("Parameter diskType is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/diskTypes/' +
        commons.Escaper.ecapeVariable('$diskType');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new DiskType.fromJson(data));
  }

  /// Retrieves a list of disk types available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [DiskTypeList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<DiskTypeList> list(core.String project, core.String zone,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/diskTypes';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new DiskTypeList.fromJson(data));
  }
}

class DisksResourceApi {
  final commons.ApiRequester _requester;

  DisksResourceApi(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of persistent disks.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [DiskAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<DiskAggregatedList> aggregatedList(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/aggregated/disks';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new DiskAggregatedList.fromJson(data));
  }

  /// Creates a snapshot of a specified persistent disk.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [disk] - Name of the persistent disk to snapshot.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [guestFlush] - null
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> createSnapshot(
      Snapshot request, core.String project, core.String zone, core.String disk,
      {core.bool guestFlush, core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (disk == null) {
      throw new core.ArgumentError("Parameter disk is required.");
    }
    if (guestFlush != null) {
      _queryParams["guestFlush"] = ["${guestFlush}"];
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/disks/' +
        commons.Escaper.ecapeVariable('$disk') +
        '/createSnapshot';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Deletes the specified persistent disk. Deleting a disk removes its data
  /// permanently and is irreversible. However, deleting a disk does not delete
  /// any snapshots previously made from the disk. You must separately delete
  /// snapshots.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [disk] - Name of the persistent disk to delete.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String zone, core.String disk,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (disk == null) {
      throw new core.ArgumentError("Parameter disk is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/disks/' +
        commons.Escaper.ecapeVariable('$disk');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns a specified persistent disk. Get a list of available persistent
  /// disks by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [disk] - Name of the persistent disk to return.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Disk].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Disk> get(
      core.String project, core.String zone, core.String disk,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (disk == null) {
      throw new core.ArgumentError("Parameter disk is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/disks/' +
        commons.Escaper.ecapeVariable('$disk');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Disk.fromJson(data));
  }

  /// Creates a persistent disk in the specified project using the data in the
  /// request. You can create a disk with a sourceImage, a sourceSnapshot, or
  /// create an empty 500 GB data disk by omitting all properties. You can also
  /// create a disk that is larger than the default size by specifying the
  /// sizeGb property.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [sourceImage] - Optional. Source image to restore onto a disk.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      Disk request, core.String project, core.String zone,
      {core.String requestId, core.String sourceImage, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if (sourceImage != null) {
      _queryParams["sourceImage"] = [sourceImage];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/disks';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves a list of persistent disks contained within the specified zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [DiskList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<DiskList> list(core.String project, core.String zone,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/disks';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new DiskList.fromJson(data));
  }

  /// Resizes the specified persistent disk. You can only increase the size of
  /// the disk.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [disk] - The name of the persistent disk.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> resize(DisksResizeRequest request,
      core.String project, core.String zone, core.String disk,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (disk == null) {
      throw new core.ArgumentError("Parameter disk is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/disks/' +
        commons.Escaper.ecapeVariable('$disk') +
        '/resize';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Sets the labels on a disk. To learn more about labels, read the Labeling
  /// Resources documentation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name of the resource for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setLabels(ZoneSetLabelsRequest request,
      core.String project, core.String zone, core.String resource,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/disks/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/setLabels';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class FirewallsResourceApi {
  final commons.ApiRequester _requester;

  FirewallsResourceApi(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified firewall.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [firewall] - Name of the firewall rule to delete.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(core.String project, core.String firewall,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (firewall == null) {
      throw new core.ArgumentError("Parameter firewall is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/firewalls/' +
        commons.Escaper.ecapeVariable('$firewall');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified firewall.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [firewall] - Name of the firewall rule to return.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Firewall].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Firewall> get(core.String project, core.String firewall,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (firewall == null) {
      throw new core.ArgumentError("Parameter firewall is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/firewalls/' +
        commons.Escaper.ecapeVariable('$firewall');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Firewall.fromJson(data));
  }

  /// Creates a firewall rule in the specified project using the data included
  /// in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(Firewall request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/firewalls';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of firewall rules available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [FirewallList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<FirewallList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/firewalls';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new FirewallList.fromJson(data));
  }

  /// Updates the specified firewall rule with the data included in the request.
  /// This method supports PATCH semantics and uses the JSON merge patch format
  /// and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [firewall] - Name of the firewall rule to patch.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
      Firewall request, core.String project, core.String firewall,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (firewall == null) {
      throw new core.ArgumentError("Parameter firewall is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/firewalls/' +
        commons.Escaper.ecapeVariable('$firewall');

    var _response = _requester.request(_url, "PATCH",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Updates the specified firewall rule with the data included in the request.
  /// The PUT method can only update the following fields of firewall rule:
  /// allowed, description, sourceRanges, sourceTags, targetTags.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [firewall] - Name of the firewall rule to update.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
      Firewall request, core.String project, core.String firewall,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (firewall == null) {
      throw new core.ArgumentError("Parameter firewall is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/firewalls/' +
        commons.Escaper.ecapeVariable('$firewall');

    var _response = _requester.request(_url, "PUT",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class ForwardingRulesResourceApi {
  final commons.ApiRequester _requester;

  ForwardingRulesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of forwarding rules.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ForwardingRuleAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ForwardingRuleAggregatedList> aggregatedList(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/aggregated/forwardingRules';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new ForwardingRuleAggregatedList.fromJson(data));
  }

  /// Deletes the specified ForwardingRule resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [forwardingRule] - Name of the ForwardingRule resource to delete.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String region, core.String forwardingRule,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (forwardingRule == null) {
      throw new core.ArgumentError("Parameter forwardingRule is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/forwardingRules/' +
        commons.Escaper.ecapeVariable('$forwardingRule');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified ForwardingRule resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [forwardingRule] - Name of the ForwardingRule resource to return.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ForwardingRule].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ForwardingRule> get(
      core.String project, core.String region, core.String forwardingRule,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (forwardingRule == null) {
      throw new core.ArgumentError("Parameter forwardingRule is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/forwardingRules/' +
        commons.Escaper.ecapeVariable('$forwardingRule');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new ForwardingRule.fromJson(data));
  }

  /// Creates a ForwardingRule resource in the specified project and region
  /// using the data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      ForwardingRule request, core.String project, core.String region,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/forwardingRules';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves a list of ForwardingRule resources available to the specified
  /// project and region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ForwardingRuleList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ForwardingRuleList> list(core.String project, core.String region,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/forwardingRules';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new ForwardingRuleList.fromJson(data));
  }

  /// Changes target URL for forwarding rule. The new target should be of the
  /// same type as the old target.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [forwardingRule] - Name of the ForwardingRule resource in which target is
  /// to be set.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setTarget(TargetReference request,
      core.String project, core.String region, core.String forwardingRule,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (forwardingRule == null) {
      throw new core.ArgumentError("Parameter forwardingRule is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/forwardingRules/' +
        commons.Escaper.ecapeVariable('$forwardingRule') +
        '/setTarget';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class GlobalAddressesResourceApi {
  final commons.ApiRequester _requester;

  GlobalAddressesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified address resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [address] - Name of the address resource to delete.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(core.String project, core.String address,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (address == null) {
      throw new core.ArgumentError("Parameter address is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/addresses/' +
        commons.Escaper.ecapeVariable('$address');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified address resource. Get a list of available addresses
  /// by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [address] - Name of the address resource to return.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Address].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Address> get(core.String project, core.String address,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (address == null) {
      throw new core.ArgumentError("Parameter address is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/addresses/' +
        commons.Escaper.ecapeVariable('$address');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Address.fromJson(data));
  }

  /// Creates an address resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(Address request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/addresses';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves a list of global addresses.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [AddressList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<AddressList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/addresses';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new AddressList.fromJson(data));
  }
}

class GlobalForwardingRulesResourceApi {
  final commons.ApiRequester _requester;

  GlobalForwardingRulesResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified GlobalForwardingRule resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [forwardingRule] - Name of the ForwardingRule resource to delete.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String forwardingRule,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (forwardingRule == null) {
      throw new core.ArgumentError("Parameter forwardingRule is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/forwardingRules/' +
        commons.Escaper.ecapeVariable('$forwardingRule');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified GlobalForwardingRule resource. Get a list of
  /// available forwarding rules by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [forwardingRule] - Name of the ForwardingRule resource to return.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ForwardingRule].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ForwardingRule> get(
      core.String project, core.String forwardingRule,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (forwardingRule == null) {
      throw new core.ArgumentError("Parameter forwardingRule is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/forwardingRules/' +
        commons.Escaper.ecapeVariable('$forwardingRule');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new ForwardingRule.fromJson(data));
  }

  /// Creates a GlobalForwardingRule resource in the specified project using the
  /// data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(ForwardingRule request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/forwardingRules';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves a list of GlobalForwardingRule resources available to the
  /// specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ForwardingRuleList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ForwardingRuleList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/forwardingRules';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new ForwardingRuleList.fromJson(data));
  }

  /// Changes target URL for the GlobalForwardingRule resource. The new target
  /// should be of the same type as the old target.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [forwardingRule] - Name of the ForwardingRule resource in which target is
  /// to be set.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setTarget(
      TargetReference request, core.String project, core.String forwardingRule,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (forwardingRule == null) {
      throw new core.ArgumentError("Parameter forwardingRule is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/forwardingRules/' +
        commons.Escaper.ecapeVariable('$forwardingRule') +
        '/setTarget';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class GlobalOperationsResourceApi {
  final commons.ApiRequester _requester;

  GlobalOperationsResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Retrieves an aggregated list of all operations.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [OperationAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<OperationAggregatedList> aggregatedList(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/aggregated/operations';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new OperationAggregatedList.fromJson(data));
  }

  /// Deletes the specified Operations resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [operation] - Name of the Operations resource to delete.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future delete(core.String project, core.String operation,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (operation == null) {
      throw new core.ArgumentError("Parameter operation is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _downloadOptions = null;

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/operations/' +
        commons.Escaper.ecapeVariable('$operation');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => null);
  }

  /// Retrieves the specified Operations resource. Get a list of operations by
  /// making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [operation] - Name of the Operations resource to return.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> get(core.String project, core.String operation,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (operation == null) {
      throw new core.ArgumentError("Parameter operation is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/operations/' +
        commons.Escaper.ecapeVariable('$operation');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves a list of Operation resources contained within the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [OperationList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<OperationList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/operations';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new OperationList.fromJson(data));
  }
}

class HealthChecksResourceApi {
  final commons.ApiRequester _requester;

  HealthChecksResourceApi(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified HealthCheck resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [healthCheck] - Name of the HealthCheck resource to delete.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(core.String project, core.String healthCheck,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (healthCheck == null) {
      throw new core.ArgumentError("Parameter healthCheck is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/healthChecks/' +
        commons.Escaper.ecapeVariable('$healthCheck');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified HealthCheck resource. Get a list of available health
  /// checks by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [healthCheck] - Name of the HealthCheck resource to return.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [HealthCheck].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<HealthCheck> get(core.String project, core.String healthCheck,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (healthCheck == null) {
      throw new core.ArgumentError("Parameter healthCheck is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/healthChecks/' +
        commons.Escaper.ecapeVariable('$healthCheck');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new HealthCheck.fromJson(data));
  }

  /// Creates a HealthCheck resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(HealthCheck request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/healthChecks';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of HealthCheck resources available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [HealthCheckList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<HealthCheckList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/healthChecks';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new HealthCheckList.fromJson(data));
  }

  /// Updates a HealthCheck resource in the specified project using the data
  /// included in the request. This method supports PATCH semantics and uses the
  /// JSON merge patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [healthCheck] - Name of the HealthCheck resource to patch.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
      HealthCheck request, core.String project, core.String healthCheck,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (healthCheck == null) {
      throw new core.ArgumentError("Parameter healthCheck is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/healthChecks/' +
        commons.Escaper.ecapeVariable('$healthCheck');

    var _response = _requester.request(_url, "PATCH",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Updates a HealthCheck resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [healthCheck] - Name of the HealthCheck resource to update.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
      HealthCheck request, core.String project, core.String healthCheck,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (healthCheck == null) {
      throw new core.ArgumentError("Parameter healthCheck is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/healthChecks/' +
        commons.Escaper.ecapeVariable('$healthCheck');

    var _response = _requester.request(_url, "PUT",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class HttpHealthChecksResourceApi {
  final commons.ApiRequester _requester;

  HttpHealthChecksResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified HttpHealthCheck resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [httpHealthCheck] - Name of the HttpHealthCheck resource to delete.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String httpHealthCheck,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (httpHealthCheck == null) {
      throw new core.ArgumentError("Parameter httpHealthCheck is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/httpHealthChecks/' +
        commons.Escaper.ecapeVariable('$httpHealthCheck');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified HttpHealthCheck resource. Get a list of available
  /// HTTP health checks by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [httpHealthCheck] - Name of the HttpHealthCheck resource to return.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [HttpHealthCheck].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<HttpHealthCheck> get(
      core.String project, core.String httpHealthCheck,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (httpHealthCheck == null) {
      throw new core.ArgumentError("Parameter httpHealthCheck is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/httpHealthChecks/' +
        commons.Escaper.ecapeVariable('$httpHealthCheck');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new HttpHealthCheck.fromJson(data));
  }

  /// Creates a HttpHealthCheck resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(HttpHealthCheck request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/httpHealthChecks';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of HttpHealthCheck resources available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [HttpHealthCheckList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<HttpHealthCheckList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/httpHealthChecks';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new HttpHealthCheckList.fromJson(data));
  }

  /// Updates a HttpHealthCheck resource in the specified project using the data
  /// included in the request. This method supports PATCH semantics and uses the
  /// JSON merge patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [httpHealthCheck] - Name of the HttpHealthCheck resource to patch.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
      HttpHealthCheck request, core.String project, core.String httpHealthCheck,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (httpHealthCheck == null) {
      throw new core.ArgumentError("Parameter httpHealthCheck is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/httpHealthChecks/' +
        commons.Escaper.ecapeVariable('$httpHealthCheck');

    var _response = _requester.request(_url, "PATCH",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Updates a HttpHealthCheck resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [httpHealthCheck] - Name of the HttpHealthCheck resource to update.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
      HttpHealthCheck request, core.String project, core.String httpHealthCheck,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (httpHealthCheck == null) {
      throw new core.ArgumentError("Parameter httpHealthCheck is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/httpHealthChecks/' +
        commons.Escaper.ecapeVariable('$httpHealthCheck');

    var _response = _requester.request(_url, "PUT",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class HttpsHealthChecksResourceApi {
  final commons.ApiRequester _requester;

  HttpsHealthChecksResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified HttpsHealthCheck resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [httpsHealthCheck] - Name of the HttpsHealthCheck resource to delete.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String httpsHealthCheck,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (httpsHealthCheck == null) {
      throw new core.ArgumentError("Parameter httpsHealthCheck is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/httpsHealthChecks/' +
        commons.Escaper.ecapeVariable('$httpsHealthCheck');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified HttpsHealthCheck resource. Get a list of available
  /// HTTPS health checks by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [httpsHealthCheck] - Name of the HttpsHealthCheck resource to return.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [HttpsHealthCheck].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<HttpsHealthCheck> get(
      core.String project, core.String httpsHealthCheck,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (httpsHealthCheck == null) {
      throw new core.ArgumentError("Parameter httpsHealthCheck is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/httpsHealthChecks/' +
        commons.Escaper.ecapeVariable('$httpsHealthCheck');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new HttpsHealthCheck.fromJson(data));
  }

  /// Creates a HttpsHealthCheck resource in the specified project using the
  /// data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(HttpsHealthCheck request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/httpsHealthChecks';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of HttpsHealthCheck resources available to the
  /// specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [HttpsHealthCheckList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<HttpsHealthCheckList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/httpsHealthChecks';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new HttpsHealthCheckList.fromJson(data));
  }

  /// Updates a HttpsHealthCheck resource in the specified project using the
  /// data included in the request. This method supports PATCH semantics and
  /// uses the JSON merge patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [httpsHealthCheck] - Name of the HttpsHealthCheck resource to patch.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(HttpsHealthCheck request, core.String project,
      core.String httpsHealthCheck,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (httpsHealthCheck == null) {
      throw new core.ArgumentError("Parameter httpsHealthCheck is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/httpsHealthChecks/' +
        commons.Escaper.ecapeVariable('$httpsHealthCheck');

    var _response = _requester.request(_url, "PATCH",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Updates a HttpsHealthCheck resource in the specified project using the
  /// data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [httpsHealthCheck] - Name of the HttpsHealthCheck resource to update.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(HttpsHealthCheck request, core.String project,
      core.String httpsHealthCheck,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (httpsHealthCheck == null) {
      throw new core.ArgumentError("Parameter httpsHealthCheck is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/httpsHealthChecks/' +
        commons.Escaper.ecapeVariable('$httpsHealthCheck');

    var _response = _requester.request(_url, "PUT",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class ImagesResourceApi {
  final commons.ApiRequester _requester;

  ImagesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified image.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [image] - Name of the image resource to delete.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(core.String project, core.String image,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (image == null) {
      throw new core.ArgumentError("Parameter image is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/images/' +
        commons.Escaper.ecapeVariable('$image');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Sets the deprecation status of an image.
  ///
  /// If an empty request body is given, clears the deprecation status instead.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [image] - Image name.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> deprecate(
      DeprecationStatus request, core.String project, core.String image,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (image == null) {
      throw new core.ArgumentError("Parameter image is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/images/' +
        commons.Escaper.ecapeVariable('$image') +
        '/deprecate';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified image. Get a list of available images by making a
  /// list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [image] - Name of the image resource to return.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Image].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Image> get(core.String project, core.String image,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (image == null) {
      throw new core.ArgumentError("Parameter image is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/images/' +
        commons.Escaper.ecapeVariable('$image');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Image.fromJson(data));
  }

  /// Returns the latest image that is part of an image family and is not
  /// deprecated.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [family] - Name of the image family to search for.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Image].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Image> getFromFamily(core.String project, core.String family,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (family == null) {
      throw new core.ArgumentError("Parameter family is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/images/family/' +
        commons.Escaper.ecapeVariable('$family');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Image.fromJson(data));
  }

  /// Creates an image in the specified project using the data included in the
  /// request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [forceCreate] - Force image creation if true.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(Image request, core.String project,
      {core.bool forceCreate, core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (forceCreate != null) {
      _queryParams["forceCreate"] = ["${forceCreate}"];
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/images';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of custom images available to the specified project.
  /// Custom images are images you create that belong to your project. This
  /// method does not get any images that belong to other projects, including
  /// publicly-available images, like Debian 8. If you want to get a list of
  /// publicly-available images, use this method to make a request to the
  /// respective image project, such as debian-cloud or windows-cloud.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ImageList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ImageList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/images';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new ImageList.fromJson(data));
  }

  /// Sets the labels on an image. To learn more about labels, read the Labeling
  /// Resources documentation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [resource] - Name of the resource for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9_]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setLabels(
      GlobalSetLabelsRequest request, core.String project, core.String resource,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/images/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/setLabels';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class InstanceGroupManagersResourceApi {
  final commons.ApiRequester _requester;

  InstanceGroupManagersResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Schedules a group action to remove the specified instances from the
  /// managed instance group. Abandoning an instance does not delete the
  /// instance, but it does remove the instance from any target pools that are
  /// applied by the managed instance group. This method reduces the targetSize
  /// of the managed instance group by the number of instances that you abandon.
  /// This operation is marked as DONE when the action is scheduled even if the
  /// instances have not yet been removed from the group. You must separately
  /// verify the status of the abandoning action with the listmanagedinstances
  /// method.
  ///
  /// If the group is part of a backend service that has enabled connection
  /// draining, it can take up to 60 seconds after the connection draining
  /// duration has elapsed before the VM instance is removed or deleted.
  ///
  /// You can specify a maximum of 1000 instances with this method per request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> abandonInstances(
      InstanceGroupManagersAbandonInstancesRequest request,
      core.String project,
      core.String zone,
      core.String instanceGroupManager,
      {core.String requestId,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instanceGroupManager == null) {
      throw new core.ArgumentError(
          "Parameter instanceGroupManager is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/abandonInstances';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of managed instance groups and groups them by zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroupManagerAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroupManagerAggregatedList> aggregatedList(
      core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/aggregated/instanceGroupManagers';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new InstanceGroupManagerAggregatedList.fromJson(data));
  }

  /// Deletes the specified managed instance group and all of the instances in
  /// that group. Note that the instance group must not belong to a backend
  /// service. Read  Deleting an instance group for more information.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [instanceGroupManager] - The name of the managed instance group to delete.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String zone, core.String instanceGroupManager,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instanceGroupManager == null) {
      throw new core.ArgumentError(
          "Parameter instanceGroupManager is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Schedules a group action to delete the specified instances in the managed
  /// instance group. The instances are also removed from any target pools of
  /// which they were a member. This method reduces the targetSize of the
  /// managed instance group by the number of instances that you delete. This
  /// operation is marked as DONE when the action is scheduled even if the
  /// instances are still being deleted. You must separately verify the status
  /// of the deleting action with the listmanagedinstances method.
  ///
  /// If the group is part of a backend service that has enabled connection
  /// draining, it can take up to 60 seconds after the connection draining
  /// duration has elapsed before the VM instance is removed or deleted.
  ///
  /// You can specify a maximum of 1000 instances with this method per request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> deleteInstances(
      InstanceGroupManagersDeleteInstancesRequest request,
      core.String project,
      core.String zone,
      core.String instanceGroupManager,
      {core.String requestId,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instanceGroupManager == null) {
      throw new core.ArgumentError(
          "Parameter instanceGroupManager is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/deleteInstances';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns all of the details about the specified managed instance group. Get
  /// a list of available managed instance groups by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroupManager].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroupManager> get(
      core.String project, core.String zone, core.String instanceGroupManager,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instanceGroupManager == null) {
      throw new core.ArgumentError(
          "Parameter instanceGroupManager is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new InstanceGroupManager.fromJson(data));
  }

  /// Creates a managed instance group using the information that you specify in
  /// the request. After the group is created, it schedules an action to create
  /// instances in the group using the specified instance template. This
  /// operation is marked as DONE when the group is created even if the
  /// instances in the group have not yet been created. You must separately
  /// verify the status of the individual instances with the
  /// listmanagedinstances method.
  ///
  /// A managed instance group can have up to 1000 VM instances per group.
  /// Please contact Cloud Support if you need an increase in this limit.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where you want to create the managed
  /// instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      InstanceGroupManager request, core.String project, core.String zone,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroupManagers';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves a list of managed instance groups that are contained within the
  /// specified project and zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroupManagerList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroupManagerList> list(
      core.String project, core.String zone,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroupManagers';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new InstanceGroupManagerList.fromJson(data));
  }

  /// Lists all of the instances in the managed instance group. Each instance in
  /// the list has a currentAction, which indicates the action that the managed
  /// instance group is performing on the instance. For example, if the group is
  /// still creating an instance, the currentAction is CREATING. If a previous
  /// action failed, the list displays the errors for that failed action.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [filter] - null
  ///
  /// [maxResults] - null
  ///
  /// [orderBy] - null
  ///
  /// [pageToken] - null
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroupManagersListManagedInstancesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroupManagersListManagedInstancesResponse>
      listManagedInstances(core.String project, core.String zone,
          core.String instanceGroupManager,
          {core.String filter,
          core.int maxResults,
          core.String orderBy,
          core.String pageToken,
          core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instanceGroupManager == null) {
      throw new core.ArgumentError(
          "Parameter instanceGroupManager is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["order_by"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/listManagedInstances';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) =>
        new InstanceGroupManagersListManagedInstancesResponse.fromJson(data));
  }

  /// Schedules a group action to recreate the specified instances in the
  /// managed instance group. The instances are deleted and recreated using the
  /// current instance template for the managed instance group. This operation
  /// is marked as DONE when the action is scheduled even if the instances have
  /// not yet been recreated. You must separately verify the status of the
  /// recreating action with the listmanagedinstances method.
  ///
  /// If the group is part of a backend service that has enabled connection
  /// draining, it can take up to 60 seconds after the connection draining
  /// duration has elapsed before the VM instance is removed or deleted.
  ///
  /// You can specify a maximum of 1000 instances with this method per request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> recreateInstances(
      InstanceGroupManagersRecreateInstancesRequest request,
      core.String project,
      core.String zone,
      core.String instanceGroupManager,
      {core.String requestId,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instanceGroupManager == null) {
      throw new core.ArgumentError(
          "Parameter instanceGroupManager is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/recreateInstances';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Resizes the managed instance group. If you increase the size, the group
  /// creates new instances using the current instance template. If you decrease
  /// the size, the group deletes instances. The resize operation is marked DONE
  /// when the resize actions are scheduled even if the group has not yet added
  /// or deleted any instances. You must separately verify the status of the
  /// creating or deleting actions with the listmanagedinstances method.
  ///
  /// If the group is part of a backend service that has enabled connection
  /// draining, it can take up to 60 seconds after the connection draining
  /// duration has elapsed before the VM instance is removed or deleted.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [size] - The number of running instances that the managed instance group
  /// should maintain at any given time. The group automatically adds or removes
  /// instances to maintain the number of instances specified by this parameter.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> resize(core.String project, core.String zone,
      core.String instanceGroupManager, core.int size,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instanceGroupManager == null) {
      throw new core.ArgumentError(
          "Parameter instanceGroupManager is required.");
    }
    if (size == null) {
      throw new core.ArgumentError("Parameter size is required.");
    }
    _queryParams["size"] = ["${size}"];
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/resize';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Specifies the instance template to use when creating new instances in this
  /// group. The templates for existing instances in the group do not change
  /// unless you recreate them.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setInstanceTemplate(
      InstanceGroupManagersSetInstanceTemplateRequest request,
      core.String project,
      core.String zone,
      core.String instanceGroupManager,
      {core.String requestId,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instanceGroupManager == null) {
      throw new core.ArgumentError(
          "Parameter instanceGroupManager is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/setInstanceTemplate';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Modifies the target pools to which all instances in this managed instance
  /// group are assigned. The target pools automatically apply to all of the
  /// instances in the managed instance group. This operation is marked DONE
  /// when you make the request even if the instances have not yet been added to
  /// their target pools. The change might take some time to apply to all of the
  /// instances in the group depending on the size of the group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setTargetPools(
      InstanceGroupManagersSetTargetPoolsRequest request,
      core.String project,
      core.String zone,
      core.String instanceGroupManager,
      {core.String requestId,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instanceGroupManager == null) {
      throw new core.ArgumentError(
          "Parameter instanceGroupManager is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/setTargetPools';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class InstanceGroupsResourceApi {
  final commons.ApiRequester _requester;

  InstanceGroupsResourceApi(commons.ApiRequester client) : _requester = client;

  /// Adds a list of instances to the specified instance group. All of the
  /// instances in the instance group must be in the same network/subnetwork.
  /// Read  Adding instances for more information.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the instance group is located.
  ///
  /// [instanceGroup] - The name of the instance group where you are adding
  /// instances.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addInstances(
      InstanceGroupsAddInstancesRequest request,
      core.String project,
      core.String zone,
      core.String instanceGroup,
      {core.String requestId,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instanceGroup == null) {
      throw new core.ArgumentError("Parameter instanceGroup is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroups/' +
        commons.Escaper.ecapeVariable('$instanceGroup') +
        '/addInstances';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of instance groups and sorts them by zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroupAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroupAggregatedList> aggregatedList(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/aggregated/instanceGroups';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new InstanceGroupAggregatedList.fromJson(data));
  }

  /// Deletes the specified instance group. The instances in the group are not
  /// deleted. Note that instance group must not belong to a backend service.
  /// Read  Deleting an instance group for more information.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the instance group is located.
  ///
  /// [instanceGroup] - The name of the instance group to delete.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String zone, core.String instanceGroup,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instanceGroup == null) {
      throw new core.ArgumentError("Parameter instanceGroup is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroups/' +
        commons.Escaper.ecapeVariable('$instanceGroup');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified instance group. Get a list of available instance
  /// groups by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the instance group is located.
  ///
  /// [instanceGroup] - The name of the instance group.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroup].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroup> get(
      core.String project, core.String zone, core.String instanceGroup,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instanceGroup == null) {
      throw new core.ArgumentError("Parameter instanceGroup is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroups/' +
        commons.Escaper.ecapeVariable('$instanceGroup');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new InstanceGroup.fromJson(data));
  }

  /// Creates an instance group in the specified project using the parameters
  /// that are included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where you want to create the instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      InstanceGroup request, core.String project, core.String zone,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroups';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of instance groups that are located in the specified
  /// project and zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the instance group is located.
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroupList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroupList> list(core.String project, core.String zone,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroups';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new InstanceGroupList.fromJson(data));
  }

  /// Lists the instances in the specified instance group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the instance group is located.
  ///
  /// [instanceGroup] - The name of the instance group from which you want to
  /// generate a list of included instances.
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroupsListInstances].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroupsListInstances> listInstances(
      InstanceGroupsListInstancesRequest request,
      core.String project,
      core.String zone,
      core.String instanceGroup,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instanceGroup == null) {
      throw new core.ArgumentError("Parameter instanceGroup is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroups/' +
        commons.Escaper.ecapeVariable('$instanceGroup') +
        '/listInstances';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new InstanceGroupsListInstances.fromJson(data));
  }

  /// Removes one or more instances from the specified instance group, but does
  /// not delete those instances.
  ///
  /// If the group is part of a backend service that has enabled connection
  /// draining, it can take up to 60 seconds after the connection draining
  /// duration before the VM instance is removed or deleted.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the instance group is located.
  ///
  /// [instanceGroup] - The name of the instance group where the specified
  /// instances will be removed.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> removeInstances(
      InstanceGroupsRemoveInstancesRequest request,
      core.String project,
      core.String zone,
      core.String instanceGroup,
      {core.String requestId,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instanceGroup == null) {
      throw new core.ArgumentError("Parameter instanceGroup is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroups/' +
        commons.Escaper.ecapeVariable('$instanceGroup') +
        '/removeInstances';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Sets the named ports for the specified instance group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the instance group is located.
  ///
  /// [instanceGroup] - The name of the instance group where the named ports are
  /// updated.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setNamedPorts(
      InstanceGroupsSetNamedPortsRequest request,
      core.String project,
      core.String zone,
      core.String instanceGroup,
      {core.String requestId,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instanceGroup == null) {
      throw new core.ArgumentError("Parameter instanceGroup is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroups/' +
        commons.Escaper.ecapeVariable('$instanceGroup') +
        '/setNamedPorts';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class InstanceTemplatesResourceApi {
  final commons.ApiRequester _requester;

  InstanceTemplatesResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified instance template. Deleting an instance template is
  /// permanent and cannot be undone. It's not possible to delete templates
  /// which are in use by an instance group.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [instanceTemplate] - The name of the instance template to delete.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String instanceTemplate,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (instanceTemplate == null) {
      throw new core.ArgumentError("Parameter instanceTemplate is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/instanceTemplates/' +
        commons.Escaper.ecapeVariable('$instanceTemplate');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified instance template. Get a list of available instance
  /// templates by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [instanceTemplate] - The name of the instance template.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceTemplate].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceTemplate> get(
      core.String project, core.String instanceTemplate,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (instanceTemplate == null) {
      throw new core.ArgumentError("Parameter instanceTemplate is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/instanceTemplates/' +
        commons.Escaper.ecapeVariable('$instanceTemplate');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new InstanceTemplate.fromJson(data));
  }

  /// Creates an instance template in the specified project using the data that
  /// is included in the request. If you are creating a new template to update
  /// an existing instance group, your new instance template must use the same
  /// network or, if applicable, the same subnetwork as the original template.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(InstanceTemplate request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/instanceTemplates';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves a list of instance templates that are contained within the
  /// specified project and zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceTemplateList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceTemplateList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/instanceTemplates';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new InstanceTemplateList.fromJson(data));
  }
}

class InstancesResourceApi {
  final commons.ApiRequester _requester;

  InstancesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Adds an access config to an instance's network interface.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - The instance name for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [networkInterface] - The name of the network interface to add to this
  /// instance.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addAccessConfig(
      AccessConfig request,
      core.String project,
      core.String zone,
      core.String instance,
      core.String networkInterface,
      {core.String requestId,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (networkInterface == null) {
      throw new core.ArgumentError("Parameter networkInterface is required.");
    }
    _queryParams["networkInterface"] = [networkInterface];
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/addAccessConfig';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves aggregated list of instances.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceAggregatedList> aggregatedList(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/aggregated/instances';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new InstanceAggregatedList.fromJson(data));
  }

  /// Attaches an existing Disk resource to an instance. You must first create
  /// the disk before you can attach it. It is not possible to create and attach
  /// a disk at the same time. For more information, read Adding a persistent
  /// disk to your instance.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - The instance name for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> attachDisk(AttachedDisk request, core.String project,
      core.String zone, core.String instance,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/attachDisk';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Deletes the specified Instance resource. For more information, see
  /// Stopping or Deleting an Instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance resource to delete.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String zone, core.String instance,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Deletes an access config from an instance's network interface.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - The instance name for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [accessConfig] - The name of the access config to delete.
  ///
  /// [networkInterface] - The name of the network interface.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> deleteAccessConfig(
      core.String project,
      core.String zone,
      core.String instance,
      core.String accessConfig,
      core.String networkInterface,
      {core.String requestId,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (accessConfig == null) {
      throw new core.ArgumentError("Parameter accessConfig is required.");
    }
    _queryParams["accessConfig"] = [accessConfig];
    if (networkInterface == null) {
      throw new core.ArgumentError("Parameter networkInterface is required.");
    }
    _queryParams["networkInterface"] = [networkInterface];
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/deleteAccessConfig';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Detaches a disk from an instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Instance name.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [deviceName] - Disk device name to detach.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> detachDisk(core.String project, core.String zone,
      core.String instance, core.String deviceName,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (deviceName == null) {
      throw new core.ArgumentError("Parameter deviceName is required.");
    }
    _queryParams["deviceName"] = [deviceName];
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/detachDisk';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified Instance resource. Get a list of available instances
  /// by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance resource to return.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Instance].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Instance> get(
      core.String project, core.String zone, core.String instance,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Instance.fromJson(data));
  }

  /// Returns the specified instance's serial port output.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [port] - Specifies which COM or serial port to retrieve data from.
  /// Value must be between "1" and "4".
  ///
  /// [start_1] - Returns output starting from a specific byte position. Use
  /// this to page through output when the output is too large to return in a
  /// single request. For the initial request, leave this field unspecified. For
  /// subsequent calls, this field should be set to the next value returned in
  /// the previous call.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SerialPortOutput].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SerialPortOutput> getSerialPortOutput(
      core.String project, core.String zone, core.String instance,
      {core.int port, core.String start_1, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (port != null) {
      _queryParams["port"] = ["${port}"];
    }
    if (start_1 != null) {
      _queryParams["start"] = [start_1];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/serialPort';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new SerialPortOutput.fromJson(data));
  }

  /// Creates an instance resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      Instance request, core.String project, core.String zone,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of instances contained within the specified zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceList> list(core.String project, core.String zone,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new InstanceList.fromJson(data));
  }

  /// Retrieves the list of referrers to instances contained within the
  /// specified zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the target instance scoping this request, or '-' if
  /// the request should span over all instances in the container.
  /// Value must have pattern "-|[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceListReferrers].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceListReferrers> listReferrers(
      core.String project, core.String zone, core.String instance,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/referrers';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new InstanceListReferrers.fromJson(data));
  }

  /// Performs a reset on the instance. For more information, see Resetting an
  /// instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> reset(
      core.String project, core.String zone, core.String instance,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/reset';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Sets deletion protection on the instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name of the resource for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [deletionProtection] - Whether the resource should be protected against
  /// deletion.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setDeletionProtection(
      core.String project, core.String zone, core.String resource,
      {core.bool deletionProtection,
      core.String requestId,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if (deletionProtection != null) {
      _queryParams["deletionProtection"] = ["${deletionProtection}"];
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/setDeletionProtection';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Sets the auto-delete flag for a disk attached to an instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - The instance name.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [autoDelete] - Whether to auto-delete the disk when the instance is
  /// deleted.
  ///
  /// [deviceName] - The device name of the disk to modify.
  /// Value must have pattern "\w[\w.-]{0,254}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setDiskAutoDelete(
      core.String project,
      core.String zone,
      core.String instance,
      core.bool autoDelete,
      core.String deviceName,
      {core.String requestId,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (autoDelete == null) {
      throw new core.ArgumentError("Parameter autoDelete is required.");
    }
    _queryParams["autoDelete"] = ["${autoDelete}"];
    if (deviceName == null) {
      throw new core.ArgumentError("Parameter deviceName is required.");
    }
    _queryParams["deviceName"] = [deviceName];
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/setDiskAutoDelete';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Sets labels on an instance. To learn more about labels, read the Labeling
  /// Resources documentation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setLabels(InstancesSetLabelsRequest request,
      core.String project, core.String zone, core.String instance,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/setLabels';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Changes the number and/or type of accelerator for a stopped instance to
  /// the values specified in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setMachineResources(
      InstancesSetMachineResourcesRequest request,
      core.String project,
      core.String zone,
      core.String instance,
      {core.String requestId,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/setMachineResources';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Changes the machine type for a stopped instance to the machine type
  /// specified in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setMachineType(InstancesSetMachineTypeRequest request,
      core.String project, core.String zone, core.String instance,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/setMachineType';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Sets metadata for the specified instance to the data included in the
  /// request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setMetadata(Metadata request, core.String project,
      core.String zone, core.String instance,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/setMetadata';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Changes the minimum CPU platform that this instance should use. This
  /// method can only be called on a stopped instance. For more information,
  /// read Specifying a Minimum CPU Platform.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setMinCpuPlatform(
      InstancesSetMinCpuPlatformRequest request,
      core.String project,
      core.String zone,
      core.String instance,
      {core.String requestId,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/setMinCpuPlatform';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Sets an instance's scheduling options.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Instance name.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setScheduling(Scheduling request, core.String project,
      core.String zone, core.String instance,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/setScheduling';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Sets the service account on the instance. For more information, read
  /// Changing the service account and access scopes for an instance.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance resource to start.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setServiceAccount(
      InstancesSetServiceAccountRequest request,
      core.String project,
      core.String zone,
      core.String instance,
      {core.String requestId,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/setServiceAccount';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Sets tags for the specified instance to the data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setTags(
      Tags request, core.String project, core.String zone, core.String instance,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/setTags';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Starts an instance that was stopped using the using the instances().stop
  /// method. For more information, see Restart an instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance resource to start.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> start(
      core.String project, core.String zone, core.String instance,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/start';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Starts an instance that was stopped using the using the instances().stop
  /// method. For more information, see Restart an instance.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance resource to start.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> startWithEncryptionKey(
      InstancesStartWithEncryptionKeyRequest request,
      core.String project,
      core.String zone,
      core.String instance,
      {core.String requestId,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/startWithEncryptionKey';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Stops a running instance, shutting it down cleanly, and allows you to
  /// restart the instance at a later time. Stopped instances do not incur VM
  /// usage charges while they are stopped. However, resources that the VM is
  /// using, such as persistent disks and static IP addresses, will continue to
  /// be charged until they are deleted. For more information, see Stopping an
  /// instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance resource to stop.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> stop(
      core.String project, core.String zone, core.String instance,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/stop';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Updates the specified access config from an instance's network interface
  /// with the data included in the request. This method supports PATCH
  /// semantics and uses the JSON merge patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - The instance name for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [networkInterface] - The name of the network interface where the access
  /// config is attached.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> updateAccessConfig(
      AccessConfig request,
      core.String project,
      core.String zone,
      core.String instance,
      core.String networkInterface,
      {core.String requestId,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (networkInterface == null) {
      throw new core.ArgumentError("Parameter networkInterface is required.");
    }
    _queryParams["networkInterface"] = [networkInterface];
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/updateAccessConfig';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class InterconnectAttachmentsResourceApi {
  final commons.ApiRequester _requester;

  InterconnectAttachmentsResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Retrieves an aggregated list of interconnect attachments.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InterconnectAttachmentAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InterconnectAttachmentAggregatedList> aggregatedList(
      core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/aggregated/interconnectAttachments';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then(
        (data) => new InterconnectAttachmentAggregatedList.fromJson(data));
  }

  /// Deletes the specified interconnect attachment.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [interconnectAttachment] - Name of the interconnect attachment to delete.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(core.String project, core.String region,
      core.String interconnectAttachment,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (interconnectAttachment == null) {
      throw new core.ArgumentError(
          "Parameter interconnectAttachment is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/interconnectAttachments/' +
        commons.Escaper.ecapeVariable('$interconnectAttachment');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified interconnect attachment.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [interconnectAttachment] - Name of the interconnect attachment to return.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InterconnectAttachment].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InterconnectAttachment> get(core.String project,
      core.String region, core.String interconnectAttachment,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (interconnectAttachment == null) {
      throw new core.ArgumentError(
          "Parameter interconnectAttachment is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/interconnectAttachments/' +
        commons.Escaper.ecapeVariable('$interconnectAttachment');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new InterconnectAttachment.fromJson(data));
  }

  /// Creates an InterconnectAttachment in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      InterconnectAttachment request, core.String project, core.String region,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/interconnectAttachments';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of interconnect attachments contained within the
  /// specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InterconnectAttachmentList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InterconnectAttachmentList> list(
      core.String project, core.String region,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/interconnectAttachments';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new InterconnectAttachmentList.fromJson(data));
  }
}

class InterconnectLocationsResourceApi {
  final commons.ApiRequester _requester;

  InterconnectLocationsResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Returns the details for the specified interconnect location. Get a list of
  /// available interconnect locations by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [interconnectLocation] - Name of the interconnect location to return.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InterconnectLocation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InterconnectLocation> get(
      core.String project, core.String interconnectLocation,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (interconnectLocation == null) {
      throw new core.ArgumentError(
          "Parameter interconnectLocation is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/interconnectLocations/' +
        commons.Escaper.ecapeVariable('$interconnectLocation');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new InterconnectLocation.fromJson(data));
  }

  /// Retrieves the list of interconnect locations available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InterconnectLocationList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InterconnectLocationList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/interconnectLocations';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new InterconnectLocationList.fromJson(data));
  }
}

class InterconnectsResourceApi {
  final commons.ApiRequester _requester;

  InterconnectsResourceApi(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified interconnect.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [interconnect] - Name of the interconnect to delete.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(core.String project, core.String interconnect,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (interconnect == null) {
      throw new core.ArgumentError("Parameter interconnect is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/interconnects/' +
        commons.Escaper.ecapeVariable('$interconnect');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified interconnect. Get a list of available interconnects
  /// by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [interconnect] - Name of the interconnect to return.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Interconnect].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Interconnect> get(core.String project, core.String interconnect,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (interconnect == null) {
      throw new core.ArgumentError("Parameter interconnect is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/interconnects/' +
        commons.Escaper.ecapeVariable('$interconnect');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Interconnect.fromJson(data));
  }

  /// Creates a Interconnect in the specified project using the data included in
  /// the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(Interconnect request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/interconnects';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of interconnect available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InterconnectList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InterconnectList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/interconnects';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new InterconnectList.fromJson(data));
  }

  /// Updates the specified interconnect with the data included in the request.
  /// This method supports PATCH semantics and uses the JSON merge patch format
  /// and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [interconnect] - Name of the interconnect to update.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
      Interconnect request, core.String project, core.String interconnect,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (interconnect == null) {
      throw new core.ArgumentError("Parameter interconnect is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/interconnects/' +
        commons.Escaper.ecapeVariable('$interconnect');

    var _response = _requester.request(_url, "PATCH",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class LicensesResourceApi {
  final commons.ApiRequester _requester;

  LicensesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Returns the specified License resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [license] - Name of the License resource to return.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [License].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<License> get(core.String project, core.String license,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (license == null) {
      throw new core.ArgumentError("Parameter license is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/licenses/' +
        commons.Escaper.ecapeVariable('$license');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new License.fromJson(data));
  }
}

class MachineTypesResourceApi {
  final commons.ApiRequester _requester;

  MachineTypesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of machine types.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [MachineTypeAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<MachineTypeAggregatedList> aggregatedList(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/aggregated/machineTypes';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new MachineTypeAggregatedList.fromJson(data));
  }

  /// Returns the specified machine type. Get a list of available machine types
  /// by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [machineType] - Name of the machine type to return.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [MachineType].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<MachineType> get(
      core.String project, core.String zone, core.String machineType,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (machineType == null) {
      throw new core.ArgumentError("Parameter machineType is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/machineTypes/' +
        commons.Escaper.ecapeVariable('$machineType');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new MachineType.fromJson(data));
  }

  /// Retrieves a list of machine types available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [MachineTypeList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<MachineTypeList> list(core.String project, core.String zone,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/machineTypes';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new MachineTypeList.fromJson(data));
  }
}

class NetworksResourceApi {
  final commons.ApiRequester _requester;

  NetworksResourceApi(commons.ApiRequester client) : _requester = client;

  /// Adds a peering to the specified network.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [network] - Name of the network resource to add peering to.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addPeering(NetworksAddPeeringRequest request,
      core.String project, core.String network,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (network == null) {
      throw new core.ArgumentError("Parameter network is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/networks/' +
        commons.Escaper.ecapeVariable('$network') +
        '/addPeering';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Deletes the specified network.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [network] - Name of the network to delete.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(core.String project, core.String network,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (network == null) {
      throw new core.ArgumentError("Parameter network is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/networks/' +
        commons.Escaper.ecapeVariable('$network');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified network. Get a list of available networks by making
  /// a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [network] - Name of the network to return.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Network].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Network> get(core.String project, core.String network,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (network == null) {
      throw new core.ArgumentError("Parameter network is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/networks/' +
        commons.Escaper.ecapeVariable('$network');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Network.fromJson(data));
  }

  /// Creates a network in the specified project using the data included in the
  /// request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(Network request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/networks';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of networks available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NetworkList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NetworkList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/networks';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new NetworkList.fromJson(data));
  }

  /// Patches the specified network with the data included in the request. Only
  /// the following fields can be modified: routingConfig.routingMode.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [network] - Name of the network to update.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
      Network request, core.String project, core.String network,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (network == null) {
      throw new core.ArgumentError("Parameter network is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/networks/' +
        commons.Escaper.ecapeVariable('$network');

    var _response = _requester.request(_url, "PATCH",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Removes a peering from the specified network.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [network] - Name of the network resource to remove peering from.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> removePeering(NetworksRemovePeeringRequest request,
      core.String project, core.String network,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (network == null) {
      throw new core.ArgumentError("Parameter network is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/networks/' +
        commons.Escaper.ecapeVariable('$network') +
        '/removePeering';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Switches the network mode from auto subnet mode to custom subnet mode.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [network] - Name of the network to be updated.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> switchToCustomMode(
      core.String project, core.String network,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (network == null) {
      throw new core.ArgumentError("Parameter network is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/networks/' +
        commons.Escaper.ecapeVariable('$network') +
        '/switchToCustomMode';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class ProjectsResourceApi {
  final commons.ApiRequester _requester;

  ProjectsResourceApi(commons.ApiRequester client) : _requester = client;

  /// Disable this project as a shared VPC host project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> disableXpnHost(core.String project,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/disableXpnHost';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Disable a serivce resource (a.k.a service project) associated with this
  /// host project.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> disableXpnResource(
      ProjectsDisableXpnResourceRequest request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/disableXpnResource';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Enable this project as a shared VPC host project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> enableXpnHost(core.String project,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/enableXpnHost';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Enable service resource (a.k.a service project) for a host project, so
  /// that subnets in the host project can be used by instances in the service
  /// project.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> enableXpnResource(
      ProjectsEnableXpnResourceRequest request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/enableXpnResource';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified Project resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Project].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Project> get(core.String project, {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Project.fromJson(data));
  }

  /// Get the shared VPC host project that this project links to. May be empty
  /// if no link exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Project].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Project> getXpnHost(core.String project, {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/getXpnHost';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Project.fromJson(data));
  }

  /// Get service resources (a.k.a service project) associated with this host
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - null
  ///
  /// [maxResults] - null
  ///
  /// [orderBy] - null
  ///
  /// [pageToken] - null
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ProjectsGetXpnResources].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ProjectsGetXpnResources> getXpnResources(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["order_by"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/getXpnResources';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new ProjectsGetXpnResources.fromJson(data));
  }

  /// List all shared VPC host projects visible to the user in an organization.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - null
  ///
  /// [maxResults] - null
  ///
  /// [orderBy] - null
  ///
  /// [pageToken] - null
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [XpnHostList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<XpnHostList> listXpnHosts(
      ProjectsListXpnHostsRequest request, core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["order_by"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/listXpnHosts';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new XpnHostList.fromJson(data));
  }

  /// Moves a persistent disk from one zone to another.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> moveDisk(DiskMoveRequest request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/moveDisk';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Moves an instance and its attached persistent disks from one zone to
  /// another.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> moveInstance(
      InstanceMoveRequest request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/moveInstance';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Sets metadata common to all instances within the specified project using
  /// the data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setCommonInstanceMetadata(
      Metadata request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/setCommonInstanceMetadata';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Enables the usage export feature and sets the usage export bucket where
  /// reports are stored. If you provide an empty request body using this
  /// method, the usage export feature will be disabled.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setUsageExportBucket(
      UsageExportLocation request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/setUsageExportBucket';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class RegionAutoscalersResourceApi {
  final commons.ApiRequester _requester;

  RegionAutoscalersResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified autoscaler.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [autoscaler] - Name of the autoscaler to delete.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String region, core.String autoscaler,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (autoscaler == null) {
      throw new core.ArgumentError("Parameter autoscaler is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/autoscalers/' +
        commons.Escaper.ecapeVariable('$autoscaler');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified autoscaler.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [autoscaler] - Name of the autoscaler to return.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Autoscaler].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Autoscaler> get(
      core.String project, core.String region, core.String autoscaler,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (autoscaler == null) {
      throw new core.ArgumentError("Parameter autoscaler is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/autoscalers/' +
        commons.Escaper.ecapeVariable('$autoscaler');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Autoscaler.fromJson(data));
  }

  /// Creates an autoscaler in the specified project using the data included in
  /// the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      Autoscaler request, core.String project, core.String region,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/autoscalers';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves a list of autoscalers contained within the specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RegionAutoscalerList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RegionAutoscalerList> list(
      core.String project, core.String region,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/autoscalers';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new RegionAutoscalerList.fromJson(data));
  }

  /// Updates an autoscaler in the specified project using the data included in
  /// the request. This method supports PATCH semantics and uses the JSON merge
  /// patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [autoscaler] - Name of the autoscaler to patch.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
      Autoscaler request, core.String project, core.String region,
      {core.String autoscaler, core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (autoscaler != null) {
      _queryParams["autoscaler"] = [autoscaler];
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/autoscalers';

    var _response = _requester.request(_url, "PATCH",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Updates an autoscaler in the specified project using the data included in
  /// the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [autoscaler] - Name of the autoscaler to update.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
      Autoscaler request, core.String project, core.String region,
      {core.String autoscaler, core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (autoscaler != null) {
      _queryParams["autoscaler"] = [autoscaler];
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/autoscalers';

    var _response = _requester.request(_url, "PUT",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class RegionBackendServicesResourceApi {
  final commons.ApiRequester _requester;

  RegionBackendServicesResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified regional BackendService resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [backendService] - Name of the BackendService resource to delete.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String region, core.String backendService,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (backendService == null) {
      throw new core.ArgumentError("Parameter backendService is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/backendServices/' +
        commons.Escaper.ecapeVariable('$backendService');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified regional BackendService resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [backendService] - Name of the BackendService resource to return.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [BackendService].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<BackendService> get(
      core.String project, core.String region, core.String backendService,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (backendService == null) {
      throw new core.ArgumentError("Parameter backendService is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/backendServices/' +
        commons.Escaper.ecapeVariable('$backendService');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new BackendService.fromJson(data));
  }

  /// Gets the most recent health check results for this regional
  /// BackendService.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - null
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [backendService] - Name of the BackendService resource for which to get
  /// health.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [BackendServiceGroupHealth].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<BackendServiceGroupHealth> getHealth(
      ResourceGroupReference request,
      core.String project,
      core.String region,
      core.String backendService,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (backendService == null) {
      throw new core.ArgumentError("Parameter backendService is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/backendServices/' +
        commons.Escaper.ecapeVariable('$backendService') +
        '/getHealth';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new BackendServiceGroupHealth.fromJson(data));
  }

  /// Creates a regional BackendService resource in the specified project using
  /// the data included in the request. There are several restrictions and
  /// guidelines to keep in mind when creating a regional backend service. Read
  /// Restrictions and Guidelines for more information.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      BackendService request, core.String project, core.String region,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/backendServices';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of regional BackendService resources available to the
  /// specified project in the given region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [BackendServiceList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<BackendServiceList> list(core.String project, core.String region,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/backendServices';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new BackendServiceList.fromJson(data));
  }

  /// Updates the specified regional BackendService resource with the data
  /// included in the request. There are several restrictions and guidelines to
  /// keep in mind when updating a backend service. Read  Restrictions and
  /// Guidelines for more information. This method supports PATCH semantics and
  /// uses the JSON merge patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [backendService] - Name of the BackendService resource to patch.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(BackendService request, core.String project,
      core.String region, core.String backendService,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (backendService == null) {
      throw new core.ArgumentError("Parameter backendService is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/backendServices/' +
        commons.Escaper.ecapeVariable('$backendService');

    var _response = _requester.request(_url, "PATCH",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Updates the specified regional BackendService resource with the data
  /// included in the request. There are several restrictions and guidelines to
  /// keep in mind when updating a backend service. Read  Restrictions and
  /// Guidelines for more information.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [backendService] - Name of the BackendService resource to update.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(BackendService request, core.String project,
      core.String region, core.String backendService,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (backendService == null) {
      throw new core.ArgumentError("Parameter backendService is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/backendServices/' +
        commons.Escaper.ecapeVariable('$backendService');

    var _response = _requester.request(_url, "PUT",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class RegionCommitmentsResourceApi {
  final commons.ApiRequester _requester;

  RegionCommitmentsResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Retrieves an aggregated list of commitments.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [CommitmentAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<CommitmentAggregatedList> aggregatedList(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/aggregated/commitments';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new CommitmentAggregatedList.fromJson(data));
  }

  /// Returns the specified commitment resource. Get a list of available
  /// commitments by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [commitment] - Name of the commitment to return.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Commitment].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Commitment> get(
      core.String project, core.String region, core.String commitment,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (commitment == null) {
      throw new core.ArgumentError("Parameter commitment is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/commitments/' +
        commons.Escaper.ecapeVariable('$commitment');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Commitment.fromJson(data));
  }

  /// Creates a commitment in the specified project using the data included in
  /// the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      Commitment request, core.String project, core.String region,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/commitments';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves a list of commitments contained within the specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [CommitmentList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<CommitmentList> list(core.String project, core.String region,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/commitments';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new CommitmentList.fromJson(data));
  }
}

class RegionInstanceGroupManagersResourceApi {
  final commons.ApiRequester _requester;

  RegionInstanceGroupManagersResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Schedules a group action to remove the specified instances from the
  /// managed instance group. Abandoning an instance does not delete the
  /// instance, but it does remove the instance from any target pools that are
  /// applied by the managed instance group. This method reduces the targetSize
  /// of the managed instance group by the number of instances that you abandon.
  /// This operation is marked as DONE when the action is scheduled even if the
  /// instances have not yet been removed from the group. You must separately
  /// verify the status of the abandoning action with the listmanagedinstances
  /// method.
  ///
  /// If the group is part of a backend service that has enabled connection
  /// draining, it can take up to 60 seconds after the connection draining
  /// duration has elapsed before the VM instance is removed or deleted.
  ///
  /// You can specify a maximum of 1000 instances with this method per request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - Name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> abandonInstances(
      RegionInstanceGroupManagersAbandonInstancesRequest request,
      core.String project,
      core.String region,
      core.String instanceGroupManager,
      {core.String requestId,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (instanceGroupManager == null) {
      throw new core.ArgumentError(
          "Parameter instanceGroupManager is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/abandonInstances';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Deletes the specified managed instance group and all of the instances in
  /// that group.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - Name of the managed instance group to delete.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String region, core.String instanceGroupManager,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (instanceGroupManager == null) {
      throw new core.ArgumentError(
          "Parameter instanceGroupManager is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Schedules a group action to delete the specified instances in the managed
  /// instance group. The instances are also removed from any target pools of
  /// which they were a member. This method reduces the targetSize of the
  /// managed instance group by the number of instances that you delete. This
  /// operation is marked as DONE when the action is scheduled even if the
  /// instances are still being deleted. You must separately verify the status
  /// of the deleting action with the listmanagedinstances method.
  ///
  /// If the group is part of a backend service that has enabled connection
  /// draining, it can take up to 60 seconds after the connection draining
  /// duration has elapsed before the VM instance is removed or deleted.
  ///
  /// You can specify a maximum of 1000 instances with this method per request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - Name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> deleteInstances(
      RegionInstanceGroupManagersDeleteInstancesRequest request,
      core.String project,
      core.String region,
      core.String instanceGroupManager,
      {core.String requestId,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (instanceGroupManager == null) {
      throw new core.ArgumentError(
          "Parameter instanceGroupManager is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/deleteInstances';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns all of the details about the specified managed instance group.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - Name of the managed instance group to return.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroupManager].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroupManager> get(
      core.String project, core.String region, core.String instanceGroupManager,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (instanceGroupManager == null) {
      throw new core.ArgumentError(
          "Parameter instanceGroupManager is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new InstanceGroupManager.fromJson(data));
  }

  /// Creates a managed instance group using the information that you specify in
  /// the request. After the group is created, it schedules an action to create
  /// instances in the group using the specified instance template. This
  /// operation is marked as DONE when the group is created even if the
  /// instances in the group have not yet been created. You must separately
  /// verify the status of the individual instances with the
  /// listmanagedinstances method.
  ///
  /// A regional managed instance group can contain up to 2000 instances.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      InstanceGroupManager request, core.String project, core.String region,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroupManagers';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of managed instance groups that are contained within
  /// the specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RegionInstanceGroupManagerList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RegionInstanceGroupManagerList> list(
      core.String project, core.String region,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroupManagers';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new RegionInstanceGroupManagerList.fromJson(data));
  }

  /// Lists the instances in the managed instance group and instances that are
  /// scheduled to be created. The list includes any current actions that the
  /// group has scheduled for its instances.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [filter] - null
  ///
  /// [maxResults] - null
  ///
  /// [orderBy] - null
  ///
  /// [pageToken] - null
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RegionInstanceGroupManagersListInstancesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RegionInstanceGroupManagersListInstancesResponse>
      listManagedInstances(core.String project, core.String region,
          core.String instanceGroupManager,
          {core.String filter,
          core.int maxResults,
          core.String orderBy,
          core.String pageToken,
          core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (instanceGroupManager == null) {
      throw new core.ArgumentError(
          "Parameter instanceGroupManager is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["order_by"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/listManagedInstances';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) =>
        new RegionInstanceGroupManagersListInstancesResponse.fromJson(data));
  }

  /// Schedules a group action to recreate the specified instances in the
  /// managed instance group. The instances are deleted and recreated using the
  /// current instance template for the managed instance group. This operation
  /// is marked as DONE when the action is scheduled even if the instances have
  /// not yet been recreated. You must separately verify the status of the
  /// recreating action with the listmanagedinstances method.
  ///
  /// If the group is part of a backend service that has enabled connection
  /// draining, it can take up to 60 seconds after the connection draining
  /// duration has elapsed before the VM instance is removed or deleted.
  ///
  /// You can specify a maximum of 1000 instances with this method per request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - Name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> recreateInstances(
      RegionInstanceGroupManagersRecreateRequest request,
      core.String project,
      core.String region,
      core.String instanceGroupManager,
      {core.String requestId,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (instanceGroupManager == null) {
      throw new core.ArgumentError(
          "Parameter instanceGroupManager is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/recreateInstances';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Changes the intended size for the managed instance group. If you increase
  /// the size, the group schedules actions to create new instances using the
  /// current instance template. If you decrease the size, the group schedules
  /// delete actions on one or more instances. The resize operation is marked
  /// DONE when the resize actions are scheduled even if the group has not yet
  /// added or deleted any instances. You must separately verify the status of
  /// the creating or deleting actions with the listmanagedinstances method.
  ///
  /// If the group is part of a backend service that has enabled connection
  /// draining, it can take up to 60 seconds after the connection draining
  /// duration has elapsed before the VM instance is removed or deleted.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - Name of the managed instance group.
  ///
  /// [size] - Number of instances that should exist in this instance group
  /// manager.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> resize(core.String project, core.String region,
      core.String instanceGroupManager, core.int size,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (instanceGroupManager == null) {
      throw new core.ArgumentError(
          "Parameter instanceGroupManager is required.");
    }
    if (size == null) {
      throw new core.ArgumentError("Parameter size is required.");
    }
    _queryParams["size"] = ["${size}"];
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/resize';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Sets the instance template to use when creating new instances or
  /// recreating instances in this group. Existing instances are not affected.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setInstanceTemplate(
      RegionInstanceGroupManagersSetTemplateRequest request,
      core.String project,
      core.String region,
      core.String instanceGroupManager,
      {core.String requestId,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (instanceGroupManager == null) {
      throw new core.ArgumentError(
          "Parameter instanceGroupManager is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/setInstanceTemplate';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Modifies the target pools to which all new instances in this group are
  /// assigned. Existing instances in the group are not affected.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - Name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setTargetPools(
      RegionInstanceGroupManagersSetTargetPoolsRequest request,
      core.String project,
      core.String region,
      core.String instanceGroupManager,
      {core.String requestId,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (instanceGroupManager == null) {
      throw new core.ArgumentError(
          "Parameter instanceGroupManager is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/setTargetPools';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class RegionInstanceGroupsResourceApi {
  final commons.ApiRequester _requester;

  RegionInstanceGroupsResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Returns the specified instance group resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroup] - Name of the instance group resource to return.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroup].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroup> get(
      core.String project, core.String region, core.String instanceGroup,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (instanceGroup == null) {
      throw new core.ArgumentError("Parameter instanceGroup is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroups/' +
        commons.Escaper.ecapeVariable('$instanceGroup');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new InstanceGroup.fromJson(data));
  }

  /// Retrieves the list of instance group resources contained within the
  /// specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RegionInstanceGroupList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RegionInstanceGroupList> list(
      core.String project, core.String region,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroups';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new RegionInstanceGroupList.fromJson(data));
  }

  /// Lists the instances in the specified instance group and displays
  /// information about the named ports. Depending on the specified options,
  /// this method can list all instances or only the instances that are running.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroup] - Name of the regional instance group for which we want to
  /// list the instances.
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RegionInstanceGroupsListInstances].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RegionInstanceGroupsListInstances> listInstances(
      RegionInstanceGroupsListInstancesRequest request,
      core.String project,
      core.String region,
      core.String instanceGroup,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (instanceGroup == null) {
      throw new core.ArgumentError("Parameter instanceGroup is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroups/' +
        commons.Escaper.ecapeVariable('$instanceGroup') +
        '/listInstances';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new RegionInstanceGroupsListInstances.fromJson(data));
  }

  /// Sets the named ports for the specified regional instance group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroup] - The name of the regional instance group where the named
  /// ports are updated.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setNamedPorts(
      RegionInstanceGroupsSetNamedPortsRequest request,
      core.String project,
      core.String region,
      core.String instanceGroup,
      {core.String requestId,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (instanceGroup == null) {
      throw new core.ArgumentError("Parameter instanceGroup is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroups/' +
        commons.Escaper.ecapeVariable('$instanceGroup') +
        '/setNamedPorts';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class RegionOperationsResourceApi {
  final commons.ApiRequester _requester;

  RegionOperationsResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified region-specific Operations resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [operation] - Name of the Operations resource to delete.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future delete(
      core.String project, core.String region, core.String operation,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (operation == null) {
      throw new core.ArgumentError("Parameter operation is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _downloadOptions = null;

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/operations/' +
        commons.Escaper.ecapeVariable('$operation');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => null);
  }

  /// Retrieves the specified region-specific Operations resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [operation] - Name of the Operations resource to return.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> get(
      core.String project, core.String region, core.String operation,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (operation == null) {
      throw new core.ArgumentError("Parameter operation is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/operations/' +
        commons.Escaper.ecapeVariable('$operation');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves a list of Operation resources contained within the specified
  /// region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [OperationList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<OperationList> list(core.String project, core.String region,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/operations';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new OperationList.fromJson(data));
  }
}

class RegionsResourceApi {
  final commons.ApiRequester _requester;

  RegionsResourceApi(commons.ApiRequester client) : _requester = client;

  /// Returns the specified Region resource. Get a list of available regions by
  /// making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region resource to return.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Region].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Region> get(core.String project, core.String region,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Region.fromJson(data));
  }

  /// Retrieves the list of region resources available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RegionList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RegionList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/regions';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new RegionList.fromJson(data));
  }
}

class RoutersResourceApi {
  final commons.ApiRequester _requester;

  RoutersResourceApi(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of routers.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RouterAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RouterAggregatedList> aggregatedList(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/aggregated/routers';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new RouterAggregatedList.fromJson(data));
  }

  /// Deletes the specified Router resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [router] - Name of the Router resource to delete.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String region, core.String router,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (router == null) {
      throw new core.ArgumentError("Parameter router is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/routers/' +
        commons.Escaper.ecapeVariable('$router');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified Router resource. Get a list of available routers by
  /// making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [router] - Name of the Router resource to return.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Router].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Router> get(
      core.String project, core.String region, core.String router,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (router == null) {
      throw new core.ArgumentError("Parameter router is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/routers/' +
        commons.Escaper.ecapeVariable('$router');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Router.fromJson(data));
  }

  /// Retrieves runtime information of the specified router.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [router] - Name of the Router resource to query.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RouterStatusResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RouterStatusResponse> getRouterStatus(
      core.String project, core.String region, core.String router,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (router == null) {
      throw new core.ArgumentError("Parameter router is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/routers/' +
        commons.Escaper.ecapeVariable('$router') +
        '/getRouterStatus';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new RouterStatusResponse.fromJson(data));
  }

  /// Creates a Router resource in the specified project and region using the
  /// data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      Router request, core.String project, core.String region,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/routers';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves a list of Router resources available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RouterList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RouterList> list(core.String project, core.String region,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/routers';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new RouterList.fromJson(data));
  }

  /// Patches the specified Router resource with the data included in the
  /// request. This method supports PATCH semantics and uses JSON merge patch
  /// format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [router] - Name of the Router resource to patch.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(Router request, core.String project,
      core.String region, core.String router,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (router == null) {
      throw new core.ArgumentError("Parameter router is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/routers/' +
        commons.Escaper.ecapeVariable('$router');

    var _response = _requester.request(_url, "PATCH",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Preview fields auto-generated during router create and update operations.
  /// Calling this method does NOT create or update the router.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [router] - Name of the Router resource to query.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RoutersPreviewResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RoutersPreviewResponse> preview(Router request,
      core.String project, core.String region, core.String router,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (router == null) {
      throw new core.ArgumentError("Parameter router is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/routers/' +
        commons.Escaper.ecapeVariable('$router') +
        '/preview';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new RoutersPreviewResponse.fromJson(data));
  }

  /// Updates the specified Router resource with the data included in the
  /// request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [router] - Name of the Router resource to update.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(Router request, core.String project,
      core.String region, core.String router,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (router == null) {
      throw new core.ArgumentError("Parameter router is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/routers/' +
        commons.Escaper.ecapeVariable('$router');

    var _response = _requester.request(_url, "PUT",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class RoutesResourceApi {
  final commons.ApiRequester _requester;

  RoutesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified Route resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [route] - Name of the Route resource to delete.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(core.String project, core.String route,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (route == null) {
      throw new core.ArgumentError("Parameter route is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/routes/' +
        commons.Escaper.ecapeVariable('$route');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified Route resource. Get a list of available routes by
  /// making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [route] - Name of the Route resource to return.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Route].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Route> get(core.String project, core.String route,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (route == null) {
      throw new core.ArgumentError("Parameter route is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/routes/' +
        commons.Escaper.ecapeVariable('$route');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Route.fromJson(data));
  }

  /// Creates a Route resource in the specified project using the data included
  /// in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(Route request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/routes';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of Route resources available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RouteList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RouteList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/routes';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new RouteList.fromJson(data));
  }
}

class SnapshotsResourceApi {
  final commons.ApiRequester _requester;

  SnapshotsResourceApi(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified Snapshot resource. Keep in mind that deleting a
  /// single snapshot might not necessarily delete all the data on that
  /// snapshot. If any data on the snapshot that is marked for deletion is
  /// needed for subsequent snapshots, the data will be moved to the next
  /// corresponding snapshot.
  ///
  /// For more information, see Deleting snaphots.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [snapshot] - Name of the Snapshot resource to delete.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(core.String project, core.String snapshot,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (snapshot == null) {
      throw new core.ArgumentError("Parameter snapshot is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/snapshots/' +
        commons.Escaper.ecapeVariable('$snapshot');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified Snapshot resource. Get a list of available snapshots
  /// by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [snapshot] - Name of the Snapshot resource to return.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Snapshot].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Snapshot> get(core.String project, core.String snapshot,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (snapshot == null) {
      throw new core.ArgumentError("Parameter snapshot is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/snapshots/' +
        commons.Escaper.ecapeVariable('$snapshot');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Snapshot.fromJson(data));
  }

  /// Retrieves the list of Snapshot resources contained within the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SnapshotList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SnapshotList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/snapshots';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new SnapshotList.fromJson(data));
  }

  /// Sets the labels on a snapshot. To learn more about labels, read the
  /// Labeling Resources documentation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [resource] - Name of the resource for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9_]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setLabels(
      GlobalSetLabelsRequest request, core.String project, core.String resource,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/snapshots/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/setLabels';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class SslCertificatesResourceApi {
  final commons.ApiRequester _requester;

  SslCertificatesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified SslCertificate resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [sslCertificate] - Name of the SslCertificate resource to delete.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String sslCertificate,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (sslCertificate == null) {
      throw new core.ArgumentError("Parameter sslCertificate is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/sslCertificates/' +
        commons.Escaper.ecapeVariable('$sslCertificate');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified SslCertificate resource. Get a list of available SSL
  /// certificates by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [sslCertificate] - Name of the SslCertificate resource to return.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SslCertificate].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SslCertificate> get(
      core.String project, core.String sslCertificate,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (sslCertificate == null) {
      throw new core.ArgumentError("Parameter sslCertificate is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/sslCertificates/' +
        commons.Escaper.ecapeVariable('$sslCertificate');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new SslCertificate.fromJson(data));
  }

  /// Creates a SslCertificate resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(SslCertificate request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/sslCertificates';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of SslCertificate resources available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SslCertificateList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SslCertificateList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/sslCertificates';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new SslCertificateList.fromJson(data));
  }
}

class SubnetworksResourceApi {
  final commons.ApiRequester _requester;

  SubnetworksResourceApi(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of subnetworks.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SubnetworkAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SubnetworkAggregatedList> aggregatedList(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/aggregated/subnetworks';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new SubnetworkAggregatedList.fromJson(data));
  }

  /// Deletes the specified subnetwork.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [subnetwork] - Name of the Subnetwork resource to delete.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String region, core.String subnetwork,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (subnetwork == null) {
      throw new core.ArgumentError("Parameter subnetwork is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/subnetworks/' +
        commons.Escaper.ecapeVariable('$subnetwork');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Expands the IP CIDR range of the subnetwork to a specified value.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [subnetwork] - Name of the Subnetwork resource to update.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> expandIpCidrRange(
      SubnetworksExpandIpCidrRangeRequest request,
      core.String project,
      core.String region,
      core.String subnetwork,
      {core.String requestId,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (subnetwork == null) {
      throw new core.ArgumentError("Parameter subnetwork is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/subnetworks/' +
        commons.Escaper.ecapeVariable('$subnetwork') +
        '/expandIpCidrRange';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified subnetwork. Get a list of available subnetworks
  /// list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [subnetwork] - Name of the Subnetwork resource to return.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Subnetwork].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Subnetwork> get(
      core.String project, core.String region, core.String subnetwork,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (subnetwork == null) {
      throw new core.ArgumentError("Parameter subnetwork is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/subnetworks/' +
        commons.Escaper.ecapeVariable('$subnetwork');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Subnetwork.fromJson(data));
  }

  /// Creates a subnetwork in the specified project using the data included in
  /// the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      Subnetwork request, core.String project, core.String region,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/subnetworks';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves a list of subnetworks available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SubnetworkList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SubnetworkList> list(core.String project, core.String region,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/subnetworks';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new SubnetworkList.fromJson(data));
  }

  /// Set whether VMs in this subnet can access Google services without
  /// assigning external IP addresses through Private Google Access.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [subnetwork] - Name of the Subnetwork resource.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setPrivateIpGoogleAccess(
      SubnetworksSetPrivateIpGoogleAccessRequest request,
      core.String project,
      core.String region,
      core.String subnetwork,
      {core.String requestId,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (subnetwork == null) {
      throw new core.ArgumentError("Parameter subnetwork is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/subnetworks/' +
        commons.Escaper.ecapeVariable('$subnetwork') +
        '/setPrivateIpGoogleAccess';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class TargetHttpProxiesResourceApi {
  final commons.ApiRequester _requester;

  TargetHttpProxiesResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified TargetHttpProxy resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetHttpProxy] - Name of the TargetHttpProxy resource to delete.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String targetHttpProxy,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (targetHttpProxy == null) {
      throw new core.ArgumentError("Parameter targetHttpProxy is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetHttpProxies/' +
        commons.Escaper.ecapeVariable('$targetHttpProxy');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified TargetHttpProxy resource. Get a list of available
  /// target HTTP proxies by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetHttpProxy] - Name of the TargetHttpProxy resource to return.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetHttpProxy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetHttpProxy> get(
      core.String project, core.String targetHttpProxy,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (targetHttpProxy == null) {
      throw new core.ArgumentError("Parameter targetHttpProxy is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetHttpProxies/' +
        commons.Escaper.ecapeVariable('$targetHttpProxy');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TargetHttpProxy.fromJson(data));
  }

  /// Creates a TargetHttpProxy resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(TargetHttpProxy request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/targetHttpProxies';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of TargetHttpProxy resources available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetHttpProxyList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetHttpProxyList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/targetHttpProxies';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TargetHttpProxyList.fromJson(data));
  }

  /// Changes the URL map for TargetHttpProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetHttpProxy] - Name of the TargetHttpProxy to set a URL map for.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setUrlMap(
      UrlMapReference request, core.String project, core.String targetHttpProxy,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (targetHttpProxy == null) {
      throw new core.ArgumentError("Parameter targetHttpProxy is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/targetHttpProxies/' +
        commons.Escaper.ecapeVariable('$targetHttpProxy') +
        '/setUrlMap';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class TargetHttpsProxiesResourceApi {
  final commons.ApiRequester _requester;

  TargetHttpsProxiesResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified TargetHttpsProxy resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetHttpsProxy] - Name of the TargetHttpsProxy resource to delete.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String targetHttpsProxy,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (targetHttpsProxy == null) {
      throw new core.ArgumentError("Parameter targetHttpsProxy is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetHttpsProxies/' +
        commons.Escaper.ecapeVariable('$targetHttpsProxy');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified TargetHttpsProxy resource. Get a list of available
  /// target HTTPS proxies by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetHttpsProxy] - Name of the TargetHttpsProxy resource to return.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetHttpsProxy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetHttpsProxy> get(
      core.String project, core.String targetHttpsProxy,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (targetHttpsProxy == null) {
      throw new core.ArgumentError("Parameter targetHttpsProxy is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetHttpsProxies/' +
        commons.Escaper.ecapeVariable('$targetHttpsProxy');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TargetHttpsProxy.fromJson(data));
  }

  /// Creates a TargetHttpsProxy resource in the specified project using the
  /// data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(TargetHttpsProxy request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetHttpsProxies';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of TargetHttpsProxy resources available to the
  /// specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetHttpsProxyList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetHttpsProxyList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetHttpsProxies';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TargetHttpsProxyList.fromJson(data));
  }

  /// Replaces SslCertificates for TargetHttpsProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetHttpsProxy] - Name of the TargetHttpsProxy resource to set an
  /// SslCertificates resource for.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setSslCertificates(
      TargetHttpsProxiesSetSslCertificatesRequest request,
      core.String project,
      core.String targetHttpsProxy,
      {core.String requestId,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (targetHttpsProxy == null) {
      throw new core.ArgumentError("Parameter targetHttpsProxy is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/targetHttpsProxies/' +
        commons.Escaper.ecapeVariable('$targetHttpsProxy') +
        '/setSslCertificates';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Changes the URL map for TargetHttpsProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetHttpsProxy] - Name of the TargetHttpsProxy resource whose URL map
  /// is to be set.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setUrlMap(UrlMapReference request,
      core.String project, core.String targetHttpsProxy,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (targetHttpsProxy == null) {
      throw new core.ArgumentError("Parameter targetHttpsProxy is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/targetHttpsProxies/' +
        commons.Escaper.ecapeVariable('$targetHttpsProxy') +
        '/setUrlMap';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class TargetInstancesResourceApi {
  final commons.ApiRequester _requester;

  TargetInstancesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of target instances.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetInstanceAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetInstanceAggregatedList> aggregatedList(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/aggregated/targetInstances';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new TargetInstanceAggregatedList.fromJson(data));
  }

  /// Deletes the specified TargetInstance resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetInstance] - Name of the TargetInstance resource to delete.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String zone, core.String targetInstance,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (targetInstance == null) {
      throw new core.ArgumentError("Parameter targetInstance is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/targetInstances/' +
        commons.Escaper.ecapeVariable('$targetInstance');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified TargetInstance resource. Get a list of available
  /// target instances by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetInstance] - Name of the TargetInstance resource to return.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetInstance].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetInstance> get(
      core.String project, core.String zone, core.String targetInstance,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (targetInstance == null) {
      throw new core.ArgumentError("Parameter targetInstance is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/targetInstances/' +
        commons.Escaper.ecapeVariable('$targetInstance');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TargetInstance.fromJson(data));
  }

  /// Creates a TargetInstance resource in the specified project and zone using
  /// the data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      TargetInstance request, core.String project, core.String zone,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/targetInstances';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves a list of TargetInstance resources available to the specified
  /// project and zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetInstanceList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetInstanceList> list(core.String project, core.String zone,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/targetInstances';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TargetInstanceList.fromJson(data));
  }
}

class TargetPoolsResourceApi {
  final commons.ApiRequester _requester;

  TargetPoolsResourceApi(commons.ApiRequester client) : _requester = client;

  /// Adds health check URLs to a target pool.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetPool] - Name of the target pool to add a health check to.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addHealthCheck(
      TargetPoolsAddHealthCheckRequest request,
      core.String project,
      core.String region,
      core.String targetPool,
      {core.String requestId,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (targetPool == null) {
      throw new core.ArgumentError("Parameter targetPool is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetPools/' +
        commons.Escaper.ecapeVariable('$targetPool') +
        '/addHealthCheck';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Adds an instance to a target pool.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetPool] - Name of the TargetPool resource to add instances to.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addInstance(TargetPoolsAddInstanceRequest request,
      core.String project, core.String region, core.String targetPool,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (targetPool == null) {
      throw new core.ArgumentError("Parameter targetPool is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetPools/' +
        commons.Escaper.ecapeVariable('$targetPool') +
        '/addInstance';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves an aggregated list of target pools.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetPoolAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetPoolAggregatedList> aggregatedList(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/aggregated/targetPools';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new TargetPoolAggregatedList.fromJson(data));
  }

  /// Deletes the specified target pool.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetPool] - Name of the TargetPool resource to delete.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String region, core.String targetPool,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (targetPool == null) {
      throw new core.ArgumentError("Parameter targetPool is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetPools/' +
        commons.Escaper.ecapeVariable('$targetPool');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified target pool. Get a list of available target pools by
  /// making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetPool] - Name of the TargetPool resource to return.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetPool].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetPool> get(
      core.String project, core.String region, core.String targetPool,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (targetPool == null) {
      throw new core.ArgumentError("Parameter targetPool is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetPools/' +
        commons.Escaper.ecapeVariable('$targetPool');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TargetPool.fromJson(data));
  }

  /// Gets the most recent health check results for each IP for the instance
  /// that is referenced by the given target pool.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetPool] - Name of the TargetPool resource to which the queried
  /// instance belongs.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetPoolInstanceHealth].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetPoolInstanceHealth> getHealth(InstanceReference request,
      core.String project, core.String region, core.String targetPool,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (targetPool == null) {
      throw new core.ArgumentError("Parameter targetPool is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetPools/' +
        commons.Escaper.ecapeVariable('$targetPool') +
        '/getHealth';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new TargetPoolInstanceHealth.fromJson(data));
  }

  /// Creates a target pool in the specified project and region using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      TargetPool request, core.String project, core.String region,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetPools';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves a list of target pools available to the specified project and
  /// region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetPoolList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetPoolList> list(core.String project, core.String region,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetPools';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TargetPoolList.fromJson(data));
  }

  /// Removes health check URL from a target pool.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetPool] - Name of the target pool to remove health checks from.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> removeHealthCheck(
      TargetPoolsRemoveHealthCheckRequest request,
      core.String project,
      core.String region,
      core.String targetPool,
      {core.String requestId,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (targetPool == null) {
      throw new core.ArgumentError("Parameter targetPool is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetPools/' +
        commons.Escaper.ecapeVariable('$targetPool') +
        '/removeHealthCheck';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Removes instance URL from a target pool.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetPool] - Name of the TargetPool resource to remove instances from.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> removeInstance(
      TargetPoolsRemoveInstanceRequest request,
      core.String project,
      core.String region,
      core.String targetPool,
      {core.String requestId,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (targetPool == null) {
      throw new core.ArgumentError("Parameter targetPool is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetPools/' +
        commons.Escaper.ecapeVariable('$targetPool') +
        '/removeInstance';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Changes a backup target pool's configurations.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetPool] - Name of the TargetPool resource to set a backup pool for.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [failoverRatio] - New failoverRatio value for the target pool.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setBackup(TargetReference request,
      core.String project, core.String region, core.String targetPool,
      {core.double failoverRatio, core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (targetPool == null) {
      throw new core.ArgumentError("Parameter targetPool is required.");
    }
    if (failoverRatio != null) {
      _queryParams["failoverRatio"] = ["${failoverRatio}"];
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetPools/' +
        commons.Escaper.ecapeVariable('$targetPool') +
        '/setBackup';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class TargetSslProxiesResourceApi {
  final commons.ApiRequester _requester;

  TargetSslProxiesResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified TargetSslProxy resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetSslProxy] - Name of the TargetSslProxy resource to delete.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String targetSslProxy,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (targetSslProxy == null) {
      throw new core.ArgumentError("Parameter targetSslProxy is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetSslProxies/' +
        commons.Escaper.ecapeVariable('$targetSslProxy');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified TargetSslProxy resource. Get a list of available
  /// target SSL proxies by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetSslProxy] - Name of the TargetSslProxy resource to return.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetSslProxy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetSslProxy> get(
      core.String project, core.String targetSslProxy,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (targetSslProxy == null) {
      throw new core.ArgumentError("Parameter targetSslProxy is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetSslProxies/' +
        commons.Escaper.ecapeVariable('$targetSslProxy');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TargetSslProxy.fromJson(data));
  }

  /// Creates a TargetSslProxy resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(TargetSslProxy request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/targetSslProxies';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of TargetSslProxy resources available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetSslProxyList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetSslProxyList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/targetSslProxies';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TargetSslProxyList.fromJson(data));
  }

  /// Changes the BackendService for TargetSslProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetSslProxy] - Name of the TargetSslProxy resource whose
  /// BackendService resource is to be set.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setBackendService(
      TargetSslProxiesSetBackendServiceRequest request,
      core.String project,
      core.String targetSslProxy,
      {core.String requestId,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (targetSslProxy == null) {
      throw new core.ArgumentError("Parameter targetSslProxy is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetSslProxies/' +
        commons.Escaper.ecapeVariable('$targetSslProxy') +
        '/setBackendService';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Changes the ProxyHeaderType for TargetSslProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetSslProxy] - Name of the TargetSslProxy resource whose ProxyHeader
  /// is to be set.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setProxyHeader(
      TargetSslProxiesSetProxyHeaderRequest request,
      core.String project,
      core.String targetSslProxy,
      {core.String requestId,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (targetSslProxy == null) {
      throw new core.ArgumentError("Parameter targetSslProxy is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetSslProxies/' +
        commons.Escaper.ecapeVariable('$targetSslProxy') +
        '/setProxyHeader';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Changes SslCertificates for TargetSslProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetSslProxy] - Name of the TargetSslProxy resource whose
  /// SslCertificate resource is to be set.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setSslCertificates(
      TargetSslProxiesSetSslCertificatesRequest request,
      core.String project,
      core.String targetSslProxy,
      {core.String requestId,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (targetSslProxy == null) {
      throw new core.ArgumentError("Parameter targetSslProxy is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetSslProxies/' +
        commons.Escaper.ecapeVariable('$targetSslProxy') +
        '/setSslCertificates';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class TargetTcpProxiesResourceApi {
  final commons.ApiRequester _requester;

  TargetTcpProxiesResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified TargetTcpProxy resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetTcpProxy] - Name of the TargetTcpProxy resource to delete.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String targetTcpProxy,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (targetTcpProxy == null) {
      throw new core.ArgumentError("Parameter targetTcpProxy is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetTcpProxies/' +
        commons.Escaper.ecapeVariable('$targetTcpProxy');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified TargetTcpProxy resource. Get a list of available
  /// target TCP proxies by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetTcpProxy] - Name of the TargetTcpProxy resource to return.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetTcpProxy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetTcpProxy> get(
      core.String project, core.String targetTcpProxy,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (targetTcpProxy == null) {
      throw new core.ArgumentError("Parameter targetTcpProxy is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetTcpProxies/' +
        commons.Escaper.ecapeVariable('$targetTcpProxy');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TargetTcpProxy.fromJson(data));
  }

  /// Creates a TargetTcpProxy resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(TargetTcpProxy request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/targetTcpProxies';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of TargetTcpProxy resources available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetTcpProxyList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetTcpProxyList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/targetTcpProxies';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TargetTcpProxyList.fromJson(data));
  }

  /// Changes the BackendService for TargetTcpProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetTcpProxy] - Name of the TargetTcpProxy resource whose
  /// BackendService resource is to be set.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setBackendService(
      TargetTcpProxiesSetBackendServiceRequest request,
      core.String project,
      core.String targetTcpProxy,
      {core.String requestId,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (targetTcpProxy == null) {
      throw new core.ArgumentError("Parameter targetTcpProxy is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetTcpProxies/' +
        commons.Escaper.ecapeVariable('$targetTcpProxy') +
        '/setBackendService';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Changes the ProxyHeaderType for TargetTcpProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetTcpProxy] - Name of the TargetTcpProxy resource whose ProxyHeader
  /// is to be set.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setProxyHeader(
      TargetTcpProxiesSetProxyHeaderRequest request,
      core.String project,
      core.String targetTcpProxy,
      {core.String requestId,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (targetTcpProxy == null) {
      throw new core.ArgumentError("Parameter targetTcpProxy is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetTcpProxies/' +
        commons.Escaper.ecapeVariable('$targetTcpProxy') +
        '/setProxyHeader';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class TargetVpnGatewaysResourceApi {
  final commons.ApiRequester _requester;

  TargetVpnGatewaysResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Retrieves an aggregated list of target VPN gateways.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetVpnGatewayAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetVpnGatewayAggregatedList> aggregatedList(
      core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/aggregated/targetVpnGateways';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new TargetVpnGatewayAggregatedList.fromJson(data));
  }

  /// Deletes the specified target VPN gateway.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetVpnGateway] - Name of the target VPN gateway to delete.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String region, core.String targetVpnGateway,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (targetVpnGateway == null) {
      throw new core.ArgumentError("Parameter targetVpnGateway is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetVpnGateways/' +
        commons.Escaper.ecapeVariable('$targetVpnGateway');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified target VPN gateway. Get a list of available target
  /// VPN gateways by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetVpnGateway] - Name of the target VPN gateway to return.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetVpnGateway].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetVpnGateway> get(
      core.String project, core.String region, core.String targetVpnGateway,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (targetVpnGateway == null) {
      throw new core.ArgumentError("Parameter targetVpnGateway is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetVpnGateways/' +
        commons.Escaper.ecapeVariable('$targetVpnGateway');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TargetVpnGateway.fromJson(data));
  }

  /// Creates a target VPN gateway in the specified project and region using the
  /// data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      TargetVpnGateway request, core.String project, core.String region,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetVpnGateways';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves a list of target VPN gateways available to the specified project
  /// and region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetVpnGatewayList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetVpnGatewayList> list(
      core.String project, core.String region,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetVpnGateways';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TargetVpnGatewayList.fromJson(data));
  }
}

class UrlMapsResourceApi {
  final commons.ApiRequester _requester;

  UrlMapsResourceApi(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified UrlMap resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [urlMap] - Name of the UrlMap resource to delete.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(core.String project, core.String urlMap,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (urlMap == null) {
      throw new core.ArgumentError("Parameter urlMap is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/urlMaps/' +
        commons.Escaper.ecapeVariable('$urlMap');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified UrlMap resource. Get a list of available URL maps by
  /// making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [urlMap] - Name of the UrlMap resource to return.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [UrlMap].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<UrlMap> get(core.String project, core.String urlMap,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (urlMap == null) {
      throw new core.ArgumentError("Parameter urlMap is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/urlMaps/' +
        commons.Escaper.ecapeVariable('$urlMap');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new UrlMap.fromJson(data));
  }

  /// Creates a UrlMap resource in the specified project using the data included
  /// in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(UrlMap request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/urlMaps';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Initiates a cache invalidation operation, invalidating the specified path,
  /// scoped to the specified UrlMap.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [urlMap] - Name of the UrlMap scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> invalidateCache(
      CacheInvalidationRule request, core.String project, core.String urlMap,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (urlMap == null) {
      throw new core.ArgumentError("Parameter urlMap is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/urlMaps/' +
        commons.Escaper.ecapeVariable('$urlMap') +
        '/invalidateCache';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of UrlMap resources available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [UrlMapList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<UrlMapList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/urlMaps';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new UrlMapList.fromJson(data));
  }

  /// Patches the specified UrlMap resource with the data included in the
  /// request. This method supports PATCH semantics and uses the JSON merge
  /// patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [urlMap] - Name of the UrlMap resource to patch.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
      UrlMap request, core.String project, core.String urlMap,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (urlMap == null) {
      throw new core.ArgumentError("Parameter urlMap is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/urlMaps/' +
        commons.Escaper.ecapeVariable('$urlMap');

    var _response = _requester.request(_url, "PATCH",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Updates the specified UrlMap resource with the data included in the
  /// request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [urlMap] - Name of the UrlMap resource to update.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
      UrlMap request, core.String project, core.String urlMap,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (urlMap == null) {
      throw new core.ArgumentError("Parameter urlMap is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/urlMaps/' +
        commons.Escaper.ecapeVariable('$urlMap');

    var _response = _requester.request(_url, "PUT",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Runs static validation for the UrlMap. In particular, the tests of the
  /// provided UrlMap will be run. Calling this method does NOT create the
  /// UrlMap.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [urlMap] - Name of the UrlMap resource to be validated as.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [UrlMapsValidateResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<UrlMapsValidateResponse> validate(
      UrlMapsValidateRequest request, core.String project, core.String urlMap,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (urlMap == null) {
      throw new core.ArgumentError("Parameter urlMap is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/urlMaps/' +
        commons.Escaper.ecapeVariable('$urlMap') +
        '/validate';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new UrlMapsValidateResponse.fromJson(data));
  }
}

class VpnTunnelsResourceApi {
  final commons.ApiRequester _requester;

  VpnTunnelsResourceApi(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of VPN tunnels.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [VpnTunnelAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<VpnTunnelAggregatedList> aggregatedList(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/aggregated/vpnTunnels';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new VpnTunnelAggregatedList.fromJson(data));
  }

  /// Deletes the specified VpnTunnel resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [vpnTunnel] - Name of the VpnTunnel resource to delete.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String region, core.String vpnTunnel,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (vpnTunnel == null) {
      throw new core.ArgumentError("Parameter vpnTunnel is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/vpnTunnels/' +
        commons.Escaper.ecapeVariable('$vpnTunnel');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified VpnTunnel resource. Get a list of available VPN
  /// tunnels by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [vpnTunnel] - Name of the VpnTunnel resource to return.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [VpnTunnel].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<VpnTunnel> get(
      core.String project, core.String region, core.String vpnTunnel,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (vpnTunnel == null) {
      throw new core.ArgumentError("Parameter vpnTunnel is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/vpnTunnels/' +
        commons.Escaper.ecapeVariable('$vpnTunnel');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new VpnTunnel.fromJson(data));
  }

  /// Creates a VpnTunnel resource in the specified project and region using the
  /// data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      VpnTunnel request, core.String project, core.String region,
      {core.String requestId, core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (request != null) {
      _body = convert.JSON.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/vpnTunnels';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves a list of VpnTunnel resources contained in the specified project
  /// and region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [VpnTunnelList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<VpnTunnelList> list(core.String project, core.String region,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/vpnTunnels';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new VpnTunnelList.fromJson(data));
  }
}

class ZoneOperationsResourceApi {
  final commons.ApiRequester _requester;

  ZoneOperationsResourceApi(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified zone-specific Operations resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [operation] - Name of the Operations resource to delete.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future delete(
      core.String project, core.String zone, core.String operation,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (operation == null) {
      throw new core.ArgumentError("Parameter operation is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _downloadOptions = null;

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/operations/' +
        commons.Escaper.ecapeVariable('$operation');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => null);
  }

  /// Retrieves the specified zone-specific Operations resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [operation] - Name of the Operations resource to return.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> get(
      core.String project, core.String zone, core.String operation,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (operation == null) {
      throw new core.ArgumentError("Parameter operation is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/operations/' +
        commons.Escaper.ecapeVariable('$operation');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves a list of Operation resources contained within the specified
  /// zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone for request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [OperationList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<OperationList> list(core.String project, core.String zone,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/operations';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new OperationList.fromJson(data));
  }
}

class ZonesResourceApi {
  final commons.ApiRequester _requester;

  ZonesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Returns the specified Zone resource. Get a list of available zones by
  /// making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone resource to return.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Zone].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Zone> get(core.String project, core.String zone,
      {core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Zone.fromJson(data));
  }

  /// Retrieves the list of Zone resources available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - Sets a filter {expression} for filtering listed resources. Your
  /// {expression} must be in the format: field_name comparison_string
  /// literal_string.
  ///
  /// The field_name is the name of the field you want to compare. Only atomic
  /// field types are supported (string, number, boolean). The comparison_string
  /// must be either eq (equals) or ne (not equals). The literal_string is the
  /// string value to filter to. The literal value must be valid for the type of
  /// field you are filtering by (string, number, boolean). For string fields,
  /// the literal value is interpreted as a regular expression using RE2 syntax.
  /// The literal value must match the entire field.
  ///
  /// For example, to filter for instances that do not have a name of
  /// example-instance, you would use name ne example-instance.
  ///
  /// You can filter on nested fields. For example, you could filter on
  /// instances that have set the scheduling.automaticRestart field to true. Use
  /// filtering on nested fields to take advantage of labels to organize and
  /// search for results based on label values.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example, (scheduling.automaticRestart eq true) (zone eq
  /// us-central1-f). Multiple expressions are treated as AND expressions,
  /// meaning that resources must match all expressions to pass the filters.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than maxResults,
  /// Compute Engine returns a nextPageToken that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are 0 to
  /// 500, inclusive. (Default: 500)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using orderBy="creationTimestamp desc". This sorts results based
  /// on the creationTimestamp field in reverse chronological order (newest
  /// result first). Use this to sort resources like operations so that the
  /// newest operation is returned first.
  ///
  /// Currently, only sorting by name or creationTimestamp desc is supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set pageToken to the
  /// nextPageToken returned by a previous list request to get the next page of
  /// results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ZoneList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ZoneList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url = null;
    var _queryParams = new core.Map();
    var _uploadMedia = null;
    var _uploadOptions = null;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body = null;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/zones';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new ZoneList.fromJson(data));
  }
}

/// A specification of the type and number of accelerator cards attached to the
/// instance.
class AcceleratorConfig {
  /// The number of the guest accelerator cards exposed to this instance.
  core.int acceleratorCount;

  /// Full or partial URL of the accelerator type resource to attach to this
  /// instance. If you are creating an instance template, specify only the
  /// accelerator name.
  core.String acceleratorType;

  AcceleratorConfig();

  AcceleratorConfig.fromJson(core.Map _json) {
    if (_json.containsKey("acceleratorCount")) {
      acceleratorCount = _json["acceleratorCount"];
    }
    if (_json.containsKey("acceleratorType")) {
      acceleratorType = _json["acceleratorType"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (acceleratorCount != null) {
      _json["acceleratorCount"] = acceleratorCount;
    }
    if (acceleratorType != null) {
      _json["acceleratorType"] = acceleratorType;
    }
    return _json;
  }
}

/// An Accelerator Type resource. (== resource_for beta.acceleratorTypes ==) (==
/// resource_for v1.acceleratorTypes ==)
class AcceleratorType {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// [Output Only] The deprecation status associated with this accelerator
  /// type.
  DeprecationStatus deprecated;

  /// [Output Only] An optional textual description of the resource.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] The type of the resource. Always compute#acceleratorType for
  /// accelerator types.
  core.String kind;

  /// [Output Only] Maximum accelerator cards allowed per instance.
  core.int maximumCardsPerInstance;

  /// [Output Only] Name of the resource.
  core.String name;

  /// [Output Only] Server-defined fully-qualified URL for this resource.
  core.String selfLink;

  /// [Output Only] The name of the zone where the accelerator type resides,
  /// such as us-central1-a. You must specify this field as part of the HTTP
  /// request URL. It is not settable as a field in the request body.
  core.String zone;

  AcceleratorType();

  AcceleratorType.fromJson(core.Map _json) {
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("deprecated")) {
      deprecated = new DeprecationStatus.fromJson(_json["deprecated"]);
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("maximumCardsPerInstance")) {
      maximumCardsPerInstance = _json["maximumCardsPerInstance"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("zone")) {
      zone = _json["zone"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (deprecated != null) {
      _json["deprecated"] = (deprecated).toJson();
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (maximumCardsPerInstance != null) {
      _json["maximumCardsPerInstance"] = maximumCardsPerInstance;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (zone != null) {
      _json["zone"] = zone;
    }
    return _json;
  }
}

class AcceleratorTypeAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  AcceleratorTypeAggregatedListWarningData();

  AcceleratorTypeAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class AcceleratorTypeAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<AcceleratorTypeAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  AcceleratorTypeAggregatedListWarning();

  AcceleratorTypeAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) =>
              new AcceleratorTypeAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class AcceleratorTypeAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of AcceleratorTypesScopedList resources.
  core.Map<core.String, AcceleratorTypesScopedList> items;

  /// [Output Only] Type of resource. Always
  /// compute#acceleratorTypeAggregatedList for aggregated lists of accelerator
  /// types.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  AcceleratorTypeAggregatedListWarning warning;

  AcceleratorTypeAggregatedList();

  AcceleratorTypeAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons.mapMap<core.Map<core.String, core.Object>,
              AcceleratorTypesScopedList>(
          _json["items"],
          (core.Map<core.String, core.Object> item) =>
              new AcceleratorTypesScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning =
          new AcceleratorTypeAggregatedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = commons.mapMap<AcceleratorTypesScopedList,
              core.Map<core.String, core.Object>>(
          items, (AcceleratorTypesScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class AcceleratorTypeListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  AcceleratorTypeListWarningData();

  AcceleratorTypeListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class AcceleratorTypeListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<AcceleratorTypeListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  AcceleratorTypeListWarning();

  AcceleratorTypeListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new AcceleratorTypeListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of accelerator types.
class AcceleratorTypeList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of AcceleratorType resources.
  core.List<AcceleratorType> items;

  /// [Output Only] Type of resource. Always compute#acceleratorTypeList for
  /// lists of accelerator types.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  AcceleratorTypeListWarning warning;

  AcceleratorTypeList();

  AcceleratorTypeList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = _json["items"]
          .map((value) => new AcceleratorType.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new AcceleratorTypeListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class AcceleratorTypesScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  AcceleratorTypesScopedListWarningData();

  AcceleratorTypesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] An informational warning that appears when the accelerator
/// types list is empty.
class AcceleratorTypesScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<AcceleratorTypesScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  AcceleratorTypesScopedListWarning();

  AcceleratorTypesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) =>
              new AcceleratorTypesScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class AcceleratorTypesScopedList {
  /// [Output Only] List of accelerator types contained in this scope.
  core.List<AcceleratorType> acceleratorTypes;

  /// [Output Only] An informational warning that appears when the accelerator
  /// types list is empty.
  AcceleratorTypesScopedListWarning warning;

  AcceleratorTypesScopedList();

  AcceleratorTypesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("acceleratorTypes")) {
      acceleratorTypes = _json["acceleratorTypes"]
          .map((value) => new AcceleratorType.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning =
          new AcceleratorTypesScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (acceleratorTypes != null) {
      _json["acceleratorTypes"] =
          acceleratorTypes.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// An access configuration attached to an instance's network interface. Only
/// one access config per instance is supported.
class AccessConfig {
  /// [Output Only] Type of the resource. Always compute#accessConfig for access
  /// configs.
  core.String kind;

  /// The name of this access configuration. The default and recommended name is
  /// External NAT but you can use any arbitrary string you would like. For
  /// example, My external IP or Network Access.
  core.String name;

  /// An external IP address associated with this instance. Specify an unused
  /// static external IP address available to the project or leave this field
  /// undefined to use an IP from a shared ephemeral IP address pool. If you
  /// specify a static external IP address, it must live in the same region as
  /// the zone of the instance.
  core.String natIP;

  /// The DNS domain name for the public PTR record. This field can only be set
  /// when the set_public_ptr field is enabled.
  core.String publicPtrDomainName;

  /// Specifies whether a public DNS ?PTR? record should be created to map the
  /// external IP address of the instance to a DNS domain name.
  core.bool setPublicPtr;

  /// The type of configuration. The default and only option is ONE_TO_ONE_NAT.
  /// Possible string values are:
  /// - "ONE_TO_ONE_NAT"
  core.String type;

  AccessConfig();

  AccessConfig.fromJson(core.Map _json) {
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("natIP")) {
      natIP = _json["natIP"];
    }
    if (_json.containsKey("publicPtrDomainName")) {
      publicPtrDomainName = _json["publicPtrDomainName"];
    }
    if (_json.containsKey("setPublicPtr")) {
      setPublicPtr = _json["setPublicPtr"];
    }
    if (_json.containsKey("type")) {
      type = _json["type"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (natIP != null) {
      _json["natIP"] = natIP;
    }
    if (publicPtrDomainName != null) {
      _json["publicPtrDomainName"] = publicPtrDomainName;
    }
    if (setPublicPtr != null) {
      _json["setPublicPtr"] = setPublicPtr;
    }
    if (type != null) {
      _json["type"] = type;
    }
    return _json;
  }
}

/// A reserved address resource. (== resource_for beta.addresses ==) (==
/// resource_for v1.addresses ==) (== resource_for beta.globalAddresses ==) (==
/// resource_for v1.globalAddresses ==)
class Address {
  /// The static IP address represented by this resource.
  core.String address;

  /// The type of address to reserve, either INTERNAL or EXTERNAL. If
  /// unspecified, defaults to EXTERNAL.
  /// Possible string values are:
  /// - "EXTERNAL"
  /// - "INTERNAL"
  /// - "UNSPECIFIED_TYPE"
  core.String addressType;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// The IP Version that will be used by this address. Valid options are IPV4
  /// or IPV6. This can only be specified for a global address.
  /// Possible string values are:
  /// - "IPV4"
  /// - "IPV6"
  /// - "UNSPECIFIED_VERSION"
  core.String ipVersion;

  /// [Output Only] Type of the resource. Always compute#address for addresses.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
  /// be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// [Output Only] URL of the region where the regional address resides. This
  /// field is not applicable to global addresses. You must specify this field
  /// as part of the HTTP request URL. You cannot set this field in the request
  /// body.
  core.String region;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] The status of the address, which can be one of RESERVING,
  /// RESERVED, or IN_USE. An address that is RESERVING is currently in the
  /// process of being reserved. A RESERVED address is currently reserved and
  /// available to use. An IN_USE address is currently being used by another
  /// resource and is not available.
  /// Possible string values are:
  /// - "IN_USE"
  /// - "RESERVED"
  core.String status;

  /// The URL of the subnetwork in which to reserve the address. If an IP
  /// address is specified, it must be within the subnetwork's IP range. This
  /// field can only be used with INTERNAL type with GCE_ENDPOINT/DNS_RESOLVER
  /// purposes.
  core.String subnetwork;

  /// [Output Only] The URLs of the resources that are using this address.
  core.List<core.String> users;

  Address();

  Address.fromJson(core.Map _json) {
    if (_json.containsKey("address")) {
      address = _json["address"];
    }
    if (_json.containsKey("addressType")) {
      addressType = _json["addressType"];
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("ipVersion")) {
      ipVersion = _json["ipVersion"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("region")) {
      region = _json["region"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("status")) {
      status = _json["status"];
    }
    if (_json.containsKey("subnetwork")) {
      subnetwork = _json["subnetwork"];
    }
    if (_json.containsKey("users")) {
      users = _json["users"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (address != null) {
      _json["address"] = address;
    }
    if (addressType != null) {
      _json["addressType"] = addressType;
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (ipVersion != null) {
      _json["ipVersion"] = ipVersion;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (region != null) {
      _json["region"] = region;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (status != null) {
      _json["status"] = status;
    }
    if (subnetwork != null) {
      _json["subnetwork"] = subnetwork;
    }
    if (users != null) {
      _json["users"] = users;
    }
    return _json;
  }
}

class AddressAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  AddressAggregatedListWarningData();

  AddressAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class AddressAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<AddressAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  AddressAggregatedListWarning();

  AddressAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new AddressAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class AddressAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of AddressesScopedList resources.
  core.Map<core.String, AddressesScopedList> items;

  /// [Output Only] Type of resource. Always compute#addressAggregatedList for
  /// aggregated lists of addresses.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  AddressAggregatedListWarning warning;

  AddressAggregatedList();

  AddressAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons
          .mapMap<core.Map<core.String, core.Object>, AddressesScopedList>(
              _json["items"],
              (core.Map<core.String, core.Object> item) =>
                  new AddressesScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new AddressAggregatedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = commons
          .mapMap<AddressesScopedList, core.Map<core.String, core.Object>>(
              items, (AddressesScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class AddressListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  AddressListWarningData();

  AddressListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class AddressListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<AddressListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  AddressListWarning();

  AddressListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new AddressListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of addresses.
class AddressList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Address resources.
  core.List<Address> items;

  /// [Output Only] Type of resource. Always compute#addressList for lists of
  /// addresses.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  AddressListWarning warning;

  AddressList();

  AddressList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items =
          _json["items"].map((value) => new Address.fromJson(value)).toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new AddressListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class AddressesScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  AddressesScopedListWarningData();

  AddressesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning which replaces the list of addresses
/// when the list is empty.
class AddressesScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<AddressesScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  AddressesScopedListWarning();

  AddressesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new AddressesScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class AddressesScopedList {
  /// [Output Only] List of addresses contained in this scope.
  core.List<Address> addresses;

  /// [Output Only] Informational warning which replaces the list of addresses
  /// when the list is empty.
  AddressesScopedListWarning warning;

  AddressesScopedList();

  AddressesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("addresses")) {
      addresses = _json["addresses"]
          .map((value) => new Address.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning = new AddressesScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (addresses != null) {
      _json["addresses"] = addresses.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// An alias IP range attached to an instance's network interface.
class AliasIpRange {
  /// The IP CIDR range represented by this alias IP range. This IP CIDR range
  /// must belong to the specified subnetwork and cannot contain IP addresses
  /// reserved by system or used by other network interfaces. This range may be
  /// a single IP address (e.g. 10.2.3.4), a netmask (e.g. /24) or a CIDR format
  /// string (e.g. 10.1.2.0/24).
  core.String ipCidrRange;

  /// Optional subnetwork secondary range name specifying the secondary range
  /// from which to allocate the IP CIDR range for this alias IP range. If left
  /// unspecified, the primary range of the subnetwork will be used.
  core.String subnetworkRangeName;

  AliasIpRange();

  AliasIpRange.fromJson(core.Map _json) {
    if (_json.containsKey("ipCidrRange")) {
      ipCidrRange = _json["ipCidrRange"];
    }
    if (_json.containsKey("subnetworkRangeName")) {
      subnetworkRangeName = _json["subnetworkRangeName"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (ipCidrRange != null) {
      _json["ipCidrRange"] = ipCidrRange;
    }
    if (subnetworkRangeName != null) {
      _json["subnetworkRangeName"] = subnetworkRangeName;
    }
    return _json;
  }
}

/// An instance-attached disk resource.
class AttachedDisk {
  /// Specifies whether the disk will be auto-deleted when the instance is
  /// deleted (but not when the disk is detached from the instance).
  core.bool autoDelete;

  /// Indicates that this is a boot disk. The virtual machine will use the first
  /// partition of the disk for its root filesystem.
  core.bool boot;

  /// Specifies a unique device name of your choice that is reflected into the
  /// /dev/disk/by-id/google-* tree of a Linux operating system running within
  /// the instance. This name can be used to reference the device for mounting,
  /// resizing, and so on, from within the instance.
  ///
  /// If not specified, the server chooses a default device name to apply to
  /// this disk, in the form persistent-disks-x, where x is a number assigned by
  /// Google Compute Engine. This field is only applicable for persistent disks.
  core.String deviceName;

  /// Encrypts or decrypts a disk using a customer-supplied encryption key.
  ///
  /// If you are creating a new disk, this field encrypts the new disk using an
  /// encryption key that you provide. If you are attaching an existing disk
  /// that is already encrypted, this field decrypts the disk using the
  /// customer-supplied encryption key.
  ///
  /// If you encrypt a disk using a customer-supplied key, you must provide the
  /// same key again when you attempt to use this resource at a later time. For
  /// example, you must provide the key when you create a snapshot or an image
  /// from the disk or when you attach the disk to a virtual machine instance.
  ///
  /// If you do not provide an encryption key, then the disk will be encrypted
  /// using an automatically generated key and you do not need to provide a key
  /// to use the disk later.
  ///
  /// Instance templates do not store customer-supplied encryption keys, so you
  /// cannot use your own keys to encrypt disks in a managed instance group.
  CustomerEncryptionKey diskEncryptionKey;

  /// [Output Only] A zero-based index to this disk, where 0 is reserved for the
  /// boot disk. If you have many disks attached to an instance, each disk would
  /// have a unique index number.
  core.int index;

  /// [Input Only] Specifies the parameters for a new disk that will be created
  /// alongside the new instance. Use initialization parameters to create boot
  /// disks or local SSDs attached to the new instance.
  ///
  /// This property is mutually exclusive with the source property; you can only
  /// define one or the other, but not both.
  AttachedDiskInitializeParams initializeParams;

  /// Specifies the disk interface to use for attaching this disk, which is
  /// either SCSI or NVME. The default is SCSI. Persistent disks must always use
  /// SCSI and the request will fail if you attempt to attach a persistent disk
  /// in any other format than SCSI. Local SSDs can use either NVME or SCSI. For
  /// performance characteristics of SCSI over NVMe, see Local SSD performance.
  /// Possible string values are:
  /// - "NVME"
  /// - "SCSI"
  core.String interface;

  /// [Output Only] Type of the resource. Always compute#attachedDisk for
  /// attached disks.
  core.String kind;

  /// [Output Only] Any valid publicly visible licenses.
  core.List<core.String> licenses;

  /// The mode in which to attach this disk, either READ_WRITE or READ_ONLY. If
  /// not specified, the default is to attach the disk in READ_WRITE mode.
  /// Possible string values are:
  /// - "READ_ONLY"
  /// - "READ_WRITE"
  core.String mode;

  /// Specifies a valid partial or full URL to an existing Persistent Disk
  /// resource. When creating a new instance, one of
  /// initializeParams.sourceImage or disks.source is required except for local
  /// SSD.
  ///
  /// If desired, you can also attach existing non-root persistent disks using
  /// this property. This field is only applicable for persistent disks.
  ///
  /// Note that for InstanceTemplate, specify the disk name, not the URL for the
  /// disk.
  core.String source;

  /// Specifies the type of the disk, either SCRATCH or PERSISTENT. If not
  /// specified, the default is PERSISTENT.
  /// Possible string values are:
  /// - "PERSISTENT"
  /// - "SCRATCH"
  core.String type;

  AttachedDisk();

  AttachedDisk.fromJson(core.Map _json) {
    if (_json.containsKey("autoDelete")) {
      autoDelete = _json["autoDelete"];
    }
    if (_json.containsKey("boot")) {
      boot = _json["boot"];
    }
    if (_json.containsKey("deviceName")) {
      deviceName = _json["deviceName"];
    }
    if (_json.containsKey("diskEncryptionKey")) {
      diskEncryptionKey =
          new CustomerEncryptionKey.fromJson(_json["diskEncryptionKey"]);
    }
    if (_json.containsKey("index")) {
      index = _json["index"];
    }
    if (_json.containsKey("initializeParams")) {
      initializeParams =
          new AttachedDiskInitializeParams.fromJson(_json["initializeParams"]);
    }
    if (_json.containsKey("interface")) {
      interface = _json["interface"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("licenses")) {
      licenses = _json["licenses"];
    }
    if (_json.containsKey("mode")) {
      mode = _json["mode"];
    }
    if (_json.containsKey("source")) {
      source = _json["source"];
    }
    if (_json.containsKey("type")) {
      type = _json["type"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (autoDelete != null) {
      _json["autoDelete"] = autoDelete;
    }
    if (boot != null) {
      _json["boot"] = boot;
    }
    if (deviceName != null) {
      _json["deviceName"] = deviceName;
    }
    if (diskEncryptionKey != null) {
      _json["diskEncryptionKey"] = (diskEncryptionKey).toJson();
    }
    if (index != null) {
      _json["index"] = index;
    }
    if (initializeParams != null) {
      _json["initializeParams"] = (initializeParams).toJson();
    }
    if (interface != null) {
      _json["interface"] = interface;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (licenses != null) {
      _json["licenses"] = licenses;
    }
    if (mode != null) {
      _json["mode"] = mode;
    }
    if (source != null) {
      _json["source"] = source;
    }
    if (type != null) {
      _json["type"] = type;
    }
    return _json;
  }
}

/// [Input Only] Specifies the parameters for a new disk that will be created
/// alongside the new instance. Use initialization parameters to create boot
/// disks or local SSDs attached to the new instance.
///
/// This property is mutually exclusive with the source property; you can only
/// define one or the other, but not both.
class AttachedDiskInitializeParams {
  /// Specifies the disk name. If not specified, the default is to use the name
  /// of the instance.
  core.String diskName;

  /// Specifies the size of the disk in base-2 GB.
  core.String diskSizeGb;

  /// Specifies the disk type to use to create the instance. If not specified,
  /// the default is pd-standard, specified using the full URL. For example:
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone/diskTypes/pd-standard
  ///
  ///
  /// Other values include pd-ssd and local-ssd. If you define this field, you
  /// can provide either the full or partial URL. For example, the following are
  /// valid values:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone/diskTypes/diskType
  /// - projects/project/zones/zone/diskTypes/diskType
  /// - zones/zone/diskTypes/diskType  Note that for InstanceTemplate, this is
  /// the name of the disk type, not URL.
  core.String diskType;

  /// Labels to apply to this disk. These can be later modified by the
  /// disks.setLabels method. This field is only applicable for persistent
  /// disks.
  core.Map<core.String, core.String> labels;

  /// The source image to create this disk. When creating a new instance, one of
  /// initializeParams.sourceImage or disks.source is required except for local
  /// SSD.
  ///
  /// To create a disk with one of the public operating system images, specify
  /// the image by its family name. For example, specify family/debian-8 to use
  /// the latest Debian 8 image:
  /// projects/debian-cloud/global/images/family/debian-8
  ///
  ///
  /// Alternatively, use a specific version of a public operating system image:
  /// projects/debian-cloud/global/images/debian-8-jessie-vYYYYMMDD
  ///
  ///
  /// To create a disk with a custom image that you created, specify the image
  /// name in the following format:
  /// global/images/my-custom-image
  ///
  ///
  /// You can also specify a custom image by its image family, which returns the
  /// latest version of the image in that family. Replace the image name with
  /// family/family-name:
  /// global/images/family/my-image-family
  ///
  ///
  /// If the source image is deleted later, this field will not be set.
  core.String sourceImage;

  /// The customer-supplied encryption key of the source image. Required if the
  /// source image is protected by a customer-supplied encryption key.
  ///
  /// Instance templates do not store customer-supplied encryption keys, so you
  /// cannot create disks for instances in a managed instance group if the
  /// source images are encrypted with your own keys.
  CustomerEncryptionKey sourceImageEncryptionKey;

  AttachedDiskInitializeParams();

  AttachedDiskInitializeParams.fromJson(core.Map _json) {
    if (_json.containsKey("diskName")) {
      diskName = _json["diskName"];
    }
    if (_json.containsKey("diskSizeGb")) {
      diskSizeGb = _json["diskSizeGb"];
    }
    if (_json.containsKey("diskType")) {
      diskType = _json["diskType"];
    }
    if (_json.containsKey("labels")) {
      labels = _json["labels"];
    }
    if (_json.containsKey("sourceImage")) {
      sourceImage = _json["sourceImage"];
    }
    if (_json.containsKey("sourceImageEncryptionKey")) {
      sourceImageEncryptionKey =
          new CustomerEncryptionKey.fromJson(_json["sourceImageEncryptionKey"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (diskName != null) {
      _json["diskName"] = diskName;
    }
    if (diskSizeGb != null) {
      _json["diskSizeGb"] = diskSizeGb;
    }
    if (diskType != null) {
      _json["diskType"] = diskType;
    }
    if (labels != null) {
      _json["labels"] = labels;
    }
    if (sourceImage != null) {
      _json["sourceImage"] = sourceImage;
    }
    if (sourceImageEncryptionKey != null) {
      _json["sourceImageEncryptionKey"] = (sourceImageEncryptionKey).toJson();
    }
    return _json;
  }
}

/// Represents an Autoscaler resource. Autoscalers allow you to automatically
/// scale virtual machine instances in managed instance groups according to an
/// autoscaling policy that you define. For more information, read Autoscaling
/// Groups of Instances. (== resource_for beta.autoscalers ==) (== resource_for
/// v1.autoscalers ==) (== resource_for beta.regionAutoscalers ==) (==
/// resource_for v1.regionAutoscalers ==)
class Autoscaler {
  /// The configuration parameters for the autoscaling algorithm. You can define
  /// one or more of the policies for an autoscaler: cpuUtilization,
  /// customMetricUtilizations, and loadBalancingUtilization.
  ///
  /// If none of these are specified, the default will be to autoscale based on
  /// cpuUtilization to 0.6 or 60%.
  AutoscalingPolicy autoscalingPolicy;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#autoscaler for
  /// autoscalers.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
  /// be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// [Output Only] URL of the region where the instance group resides (for
  /// autoscalers living in regional scope).
  core.String region;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] The status of the autoscaler configuration.
  /// Possible string values are:
  /// - "ACTIVE"
  /// - "DELETING"
  /// - "ERROR"
  /// - "PENDING"
  core.String status;

  /// [Output Only] Human-readable details about the current state of the
  /// autoscaler. Read the documentation for Commonly returned status messages
  /// for examples of status messages you might encounter.
  core.List<AutoscalerStatusDetails> statusDetails;

  /// URL of the managed instance group that this autoscaler will scale.
  core.String target;

  /// [Output Only] URL of the zone where the instance group resides (for
  /// autoscalers living in zonal scope).
  core.String zone;

  Autoscaler();

  Autoscaler.fromJson(core.Map _json) {
    if (_json.containsKey("autoscalingPolicy")) {
      autoscalingPolicy =
          new AutoscalingPolicy.fromJson(_json["autoscalingPolicy"]);
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("region")) {
      region = _json["region"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("status")) {
      status = _json["status"];
    }
    if (_json.containsKey("statusDetails")) {
      statusDetails = _json["statusDetails"]
          .map((value) => new AutoscalerStatusDetails.fromJson(value))
          .toList();
    }
    if (_json.containsKey("target")) {
      target = _json["target"];
    }
    if (_json.containsKey("zone")) {
      zone = _json["zone"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (autoscalingPolicy != null) {
      _json["autoscalingPolicy"] = (autoscalingPolicy).toJson();
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (region != null) {
      _json["region"] = region;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (status != null) {
      _json["status"] = status;
    }
    if (statusDetails != null) {
      _json["statusDetails"] =
          statusDetails.map((value) => (value).toJson()).toList();
    }
    if (target != null) {
      _json["target"] = target;
    }
    if (zone != null) {
      _json["zone"] = zone;
    }
    return _json;
  }
}

class AutoscalerAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  AutoscalerAggregatedListWarningData();

  AutoscalerAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class AutoscalerAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<AutoscalerAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  AutoscalerAggregatedListWarning();

  AutoscalerAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) =>
              new AutoscalerAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class AutoscalerAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of AutoscalersScopedList resources.
  core.Map<core.String, AutoscalersScopedList> items;

  /// [Output Only] Type of resource. Always compute#autoscalerAggregatedList
  /// for aggregated lists of autoscalers.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  AutoscalerAggregatedListWarning warning;

  AutoscalerAggregatedList();

  AutoscalerAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons
          .mapMap<core.Map<core.String, core.Object>, AutoscalersScopedList>(
              _json["items"],
              (core.Map<core.String, core.Object> item) =>
                  new AutoscalersScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new AutoscalerAggregatedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = commons
          .mapMap<AutoscalersScopedList, core.Map<core.String, core.Object>>(
              items, (AutoscalersScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class AutoscalerListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  AutoscalerListWarningData();

  AutoscalerListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class AutoscalerListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<AutoscalerListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  AutoscalerListWarning();

  AutoscalerListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new AutoscalerListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of Autoscaler resources.
class AutoscalerList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Autoscaler resources.
  core.List<Autoscaler> items;

  /// [Output Only] Type of resource. Always compute#autoscalerList for lists of
  /// autoscalers.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  AutoscalerListWarning warning;

  AutoscalerList();

  AutoscalerList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = _json["items"]
          .map((value) => new Autoscaler.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new AutoscalerListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class AutoscalerStatusDetails {
  /// The status message.
  core.String message;

  /// The type of error returned.
  /// Possible string values are:
  /// - "ALL_INSTANCES_UNHEALTHY"
  /// - "BACKEND_SERVICE_DOES_NOT_EXIST"
  /// - "CAPPED_AT_MAX_NUM_REPLICAS"
  /// - "CUSTOM_METRIC_DATA_POINTS_TOO_SPARSE"
  /// - "CUSTOM_METRIC_INVALID"
  /// - "MIN_EQUALS_MAX"
  /// - "MISSING_CUSTOM_METRIC_DATA_POINTS"
  /// - "MISSING_LOAD_BALANCING_DATA_POINTS"
  /// - "MORE_THAN_ONE_BACKEND_SERVICE"
  /// - "NOT_ENOUGH_QUOTA_AVAILABLE"
  /// - "REGION_RESOURCE_STOCKOUT"
  /// - "SCALING_TARGET_DOES_NOT_EXIST"
  /// - "UNKNOWN"
  /// - "UNSUPPORTED_MAX_RATE_LOAD_BALANCING_CONFIGURATION"
  /// - "ZONE_RESOURCE_STOCKOUT"
  core.String type;

  AutoscalerStatusDetails();

  AutoscalerStatusDetails.fromJson(core.Map _json) {
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
    if (_json.containsKey("type")) {
      type = _json["type"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (message != null) {
      _json["message"] = message;
    }
    if (type != null) {
      _json["type"] = type;
    }
    return _json;
  }
}

class AutoscalersScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  AutoscalersScopedListWarningData();

  AutoscalersScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning which replaces the list of autoscalers
/// when the list is empty.
class AutoscalersScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<AutoscalersScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  AutoscalersScopedListWarning();

  AutoscalersScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new AutoscalersScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class AutoscalersScopedList {
  /// [Output Only] List of autoscalers contained in this scope.
  core.List<Autoscaler> autoscalers;

  /// [Output Only] Informational warning which replaces the list of autoscalers
  /// when the list is empty.
  AutoscalersScopedListWarning warning;

  AutoscalersScopedList();

  AutoscalersScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("autoscalers")) {
      autoscalers = _json["autoscalers"]
          .map((value) => new Autoscaler.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning = new AutoscalersScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (autoscalers != null) {
      _json["autoscalers"] =
          autoscalers.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// Cloud Autoscaler policy.
class AutoscalingPolicy {
  /// The number of seconds that the autoscaler should wait before it starts
  /// collecting information from a new instance. This prevents the autoscaler
  /// from collecting information when the instance is initializing, during
  /// which the collected usage would not be reliable. The default time
  /// autoscaler waits is 60 seconds.
  ///
  /// Virtual machine initialization times might vary because of numerous
  /// factors. We recommend that you test how long an instance may take to
  /// initialize. To do this, create an instance and time the startup process.
  core.int coolDownPeriodSec;

  /// Defines the CPU utilization policy that allows the autoscaler to scale
  /// based on the average CPU utilization of a managed instance group.
  AutoscalingPolicyCpuUtilization cpuUtilization;

  /// Configuration parameters of autoscaling based on a custom metric.
  core.List<AutoscalingPolicyCustomMetricUtilization> customMetricUtilizations;

  /// Configuration parameters of autoscaling based on load balancer.
  AutoscalingPolicyLoadBalancingUtilization loadBalancingUtilization;

  /// The maximum number of instances that the autoscaler can scale up to. This
  /// is required when creating or updating an autoscaler. The maximum number of
  /// replicas should not be lower than minimal number of replicas.
  core.int maxNumReplicas;

  /// The minimum number of replicas that the autoscaler can scale down to. This
  /// cannot be less than 0. If not provided, autoscaler will choose a default
  /// value depending on maximum number of instances allowed.
  core.int minNumReplicas;

  AutoscalingPolicy();

  AutoscalingPolicy.fromJson(core.Map _json) {
    if (_json.containsKey("coolDownPeriodSec")) {
      coolDownPeriodSec = _json["coolDownPeriodSec"];
    }
    if (_json.containsKey("cpuUtilization")) {
      cpuUtilization =
          new AutoscalingPolicyCpuUtilization.fromJson(_json["cpuUtilization"]);
    }
    if (_json.containsKey("customMetricUtilizations")) {
      customMetricUtilizations = _json["customMetricUtilizations"]
          .map((value) =>
              new AutoscalingPolicyCustomMetricUtilization.fromJson(value))
          .toList();
    }
    if (_json.containsKey("loadBalancingUtilization")) {
      loadBalancingUtilization =
          new AutoscalingPolicyLoadBalancingUtilization.fromJson(
              _json["loadBalancingUtilization"]);
    }
    if (_json.containsKey("maxNumReplicas")) {
      maxNumReplicas = _json["maxNumReplicas"];
    }
    if (_json.containsKey("minNumReplicas")) {
      minNumReplicas = _json["minNumReplicas"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (coolDownPeriodSec != null) {
      _json["coolDownPeriodSec"] = coolDownPeriodSec;
    }
    if (cpuUtilization != null) {
      _json["cpuUtilization"] = (cpuUtilization).toJson();
    }
    if (customMetricUtilizations != null) {
      _json["customMetricUtilizations"] =
          customMetricUtilizations.map((value) => (value).toJson()).toList();
    }
    if (loadBalancingUtilization != null) {
      _json["loadBalancingUtilization"] = (loadBalancingUtilization).toJson();
    }
    if (maxNumReplicas != null) {
      _json["maxNumReplicas"] = maxNumReplicas;
    }
    if (minNumReplicas != null) {
      _json["minNumReplicas"] = minNumReplicas;
    }
    return _json;
  }
}

/// CPU utilization policy.
class AutoscalingPolicyCpuUtilization {
  /// The target CPU utilization that the autoscaler should maintain. Must be a
  /// float value in the range (0, 1]. If not specified, the default is 0.6.
  ///
  /// If the CPU level is below the target utilization, the autoscaler scales
  /// down the number of instances until it reaches the minimum number of
  /// instances you specified or until the average CPU of your instances reaches
  /// the target utilization.
  ///
  /// If the average CPU is above the target utilization, the autoscaler scales
  /// up until it reaches the maximum number of instances you specified or until
  /// the average utilization reaches the target utilization.
  core.double utilizationTarget;

  AutoscalingPolicyCpuUtilization();

  AutoscalingPolicyCpuUtilization.fromJson(core.Map _json) {
    if (_json.containsKey("utilizationTarget")) {
      utilizationTarget = _json["utilizationTarget"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (utilizationTarget != null) {
      _json["utilizationTarget"] = utilizationTarget;
    }
    return _json;
  }
}

/// Custom utilization metric policy.
class AutoscalingPolicyCustomMetricUtilization {
  /// The identifier (type) of the Stackdriver Monitoring metric. The metric
  /// cannot have negative values.
  ///
  /// The metric must have a value type of INT64 or DOUBLE.
  core.String metric;

  /// The target value of the metric that autoscaler should maintain. This must
  /// be a positive value. A utilization metric scales number of virtual
  /// machines handling requests to increase or decrease proportionally to the
  /// metric.
  ///
  /// For example, a good metric to use as a utilization_target is
  /// compute.googleapis.com/instance/network/received_bytes_count. The
  /// autoscaler will work to keep this value constant for each of the
  /// instances.
  core.double utilizationTarget;

  /// Defines how target utilization value is expressed for a Stackdriver
  /// Monitoring metric. Either GAUGE, DELTA_PER_SECOND, or DELTA_PER_MINUTE. If
  /// not specified, the default is GAUGE.
  /// Possible string values are:
  /// - "DELTA_PER_MINUTE"
  /// - "DELTA_PER_SECOND"
  /// - "GAUGE"
  core.String utilizationTargetType;

  AutoscalingPolicyCustomMetricUtilization();

  AutoscalingPolicyCustomMetricUtilization.fromJson(core.Map _json) {
    if (_json.containsKey("metric")) {
      metric = _json["metric"];
    }
    if (_json.containsKey("utilizationTarget")) {
      utilizationTarget = _json["utilizationTarget"];
    }
    if (_json.containsKey("utilizationTargetType")) {
      utilizationTargetType = _json["utilizationTargetType"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (metric != null) {
      _json["metric"] = metric;
    }
    if (utilizationTarget != null) {
      _json["utilizationTarget"] = utilizationTarget;
    }
    if (utilizationTargetType != null) {
      _json["utilizationTargetType"] = utilizationTargetType;
    }
    return _json;
  }
}

/// Configuration parameters of autoscaling based on load balancing.
class AutoscalingPolicyLoadBalancingUtilization {
  /// Fraction of backend capacity utilization (set in HTTP(s) load balancing
  /// configuration) that autoscaler should maintain. Must be a positive float
  /// value. If not defined, the default is 0.8.
  core.double utilizationTarget;

  AutoscalingPolicyLoadBalancingUtilization();

  AutoscalingPolicyLoadBalancingUtilization.fromJson(core.Map _json) {
    if (_json.containsKey("utilizationTarget")) {
      utilizationTarget = _json["utilizationTarget"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (utilizationTarget != null) {
      _json["utilizationTarget"] = utilizationTarget;
    }
    return _json;
  }
}

/// Message containing information of one individual backend.
class Backend {
  /// Specifies the balancing mode for this backend. For global HTTP(S) or
  /// TCP/SSL load balancing, the default is UTILIZATION. Valid values are
  /// UTILIZATION, RATE (for HTTP(S)) and CONNECTION (for TCP/SSL).
  ///
  /// For Internal Load Balancing, the default and only supported mode is
  /// CONNECTION.
  /// Possible string values are:
  /// - "CONNECTION"
  /// - "RATE"
  /// - "UTILIZATION"
  core.String balancingMode;

  /// A multiplier applied to the group's maximum servicing capacity (based on
  /// UTILIZATION, RATE or CONNECTION). Default value is 1, which means the
  /// group will serve up to 100% of its configured capacity (depending on
  /// balancingMode). A setting of 0 means the group is completely drained,
  /// offering 0% of its available Capacity. Valid range is [0.0,1.0].
  ///
  /// This cannot be used for internal load balancing.
  core.double capacityScaler;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// The fully-qualified URL of a Instance Group resource. This instance group
  /// defines the list of instances that serve traffic. Member virtual machine
  /// instances from each instance group must live in the same zone as the
  /// instance group itself. No two backends in a backend service are allowed to
  /// use same Instance Group resource.
  ///
  /// Note that you must specify an Instance Group resource using the
  /// fully-qualified URL, rather than a partial URL.
  ///
  /// When the BackendService has load balancing scheme INTERNAL, the instance
  /// group must be within the same region as the BackendService.
  core.String group;

  /// The max number of simultaneous connections for the group. Can be used with
  /// either CONNECTION or UTILIZATION balancing modes. For CONNECTION mode,
  /// either maxConnections or maxConnectionsPerInstance must be set.
  ///
  /// This cannot be used for internal load balancing.
  core.int maxConnections;

  /// The max number of simultaneous connections that a single backend instance
  /// can handle. This is used to calculate the capacity of the group. Can be
  /// used in either CONNECTION or UTILIZATION balancing modes. For CONNECTION
  /// mode, either maxConnections or maxConnectionsPerInstance must be set.
  ///
  /// This cannot be used for internal load balancing.
  core.int maxConnectionsPerInstance;

  /// The max requests per second (RPS) of the group. Can be used with either
  /// RATE or UTILIZATION balancing modes, but required if RATE mode. For RATE
  /// mode, either maxRate or maxRatePerInstance must be set.
  ///
  /// This cannot be used for internal load balancing.
  core.int maxRate;

  /// The max requests per second (RPS) that a single backend instance can
  /// handle. This is used to calculate the capacity of the group. Can be used
  /// in either balancing mode. For RATE mode, either maxRate or
  /// maxRatePerInstance must be set.
  ///
  /// This cannot be used for internal load balancing.
  core.double maxRatePerInstance;

  /// Used when balancingMode is UTILIZATION. This ratio defines the CPU
  /// utilization target for the group. The default is 0.8. Valid range is [0.0,
  /// 1.0].
  ///
  /// This cannot be used for internal load balancing.
  core.double maxUtilization;

  Backend();

  Backend.fromJson(core.Map _json) {
    if (_json.containsKey("balancingMode")) {
      balancingMode = _json["balancingMode"];
    }
    if (_json.containsKey("capacityScaler")) {
      capacityScaler = _json["capacityScaler"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("group")) {
      group = _json["group"];
    }
    if (_json.containsKey("maxConnections")) {
      maxConnections = _json["maxConnections"];
    }
    if (_json.containsKey("maxConnectionsPerInstance")) {
      maxConnectionsPerInstance = _json["maxConnectionsPerInstance"];
    }
    if (_json.containsKey("maxRate")) {
      maxRate = _json["maxRate"];
    }
    if (_json.containsKey("maxRatePerInstance")) {
      maxRatePerInstance = _json["maxRatePerInstance"];
    }
    if (_json.containsKey("maxUtilization")) {
      maxUtilization = _json["maxUtilization"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (balancingMode != null) {
      _json["balancingMode"] = balancingMode;
    }
    if (capacityScaler != null) {
      _json["capacityScaler"] = capacityScaler;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (group != null) {
      _json["group"] = group;
    }
    if (maxConnections != null) {
      _json["maxConnections"] = maxConnections;
    }
    if (maxConnectionsPerInstance != null) {
      _json["maxConnectionsPerInstance"] = maxConnectionsPerInstance;
    }
    if (maxRate != null) {
      _json["maxRate"] = maxRate;
    }
    if (maxRatePerInstance != null) {
      _json["maxRatePerInstance"] = maxRatePerInstance;
    }
    if (maxUtilization != null) {
      _json["maxUtilization"] = maxUtilization;
    }
    return _json;
  }
}

/// A BackendBucket resource. This resource defines a Cloud Storage bucket.
class BackendBucket {
  /// Cloud Storage bucket name.
  core.String bucketName;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional textual description of the resource; provided by the client
  /// when the resource is created.
  core.String description;

  /// If true, enable Cloud CDN for this BackendBucket.
  core.bool enableCdn;

  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// Type of the resource.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
  /// be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  BackendBucket();

  BackendBucket.fromJson(core.Map _json) {
    if (_json.containsKey("bucketName")) {
      bucketName = _json["bucketName"];
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("enableCdn")) {
      enableCdn = _json["enableCdn"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (bucketName != null) {
      _json["bucketName"] = bucketName;
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (enableCdn != null) {
      _json["enableCdn"] = enableCdn;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    return _json;
  }
}

class BackendBucketListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  BackendBucketListWarningData();

  BackendBucketListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class BackendBucketListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<BackendBucketListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  BackendBucketListWarning();

  BackendBucketListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new BackendBucketListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of BackendBucket resources.
class BackendBucketList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of BackendBucket resources.
  core.List<BackendBucket> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  BackendBucketListWarning warning;

  BackendBucketList();

  BackendBucketList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = _json["items"]
          .map((value) => new BackendBucket.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new BackendBucketListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// A BackendService resource. This resource defines a group of backend virtual
/// machines and their serving capacity. (== resource_for v1.backendService ==)
/// (== resource_for beta.backendService ==)
class BackendService {
  /// Lifetime of cookies in seconds if session_affinity is GENERATED_COOKIE. If
  /// set to 0, the cookie is non-persistent and lasts only until the end of the
  /// browser session (or equivalent). The maximum allowed value for TTL is one
  /// day.
  ///
  /// When the load balancing scheme is INTERNAL, this field is not used.
  core.int affinityCookieTtlSec;

  /// The list of backends that serve this BackendService.
  core.List<Backend> backends;

  /// Cloud CDN configuration for this BackendService.
  BackendServiceCdnPolicy cdnPolicy;
  ConnectionDraining connectionDraining;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// If true, enable Cloud CDN for this BackendService.
  ///
  /// When the load balancing scheme is INTERNAL, this field is not used.
  core.bool enableCDN;

  /// Fingerprint of this resource. A hash of the contents stored in this
  /// object. This field is used in optimistic locking. This field will be
  /// ignored when inserting a BackendService. An up-to-date fingerprint must be
  /// provided in order to update the BackendService.
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes {
    return convert.BASE64.decode(fingerprint);
  }

  void set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.BASE64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  /// The list of URLs to the HttpHealthCheck or HttpsHealthCheck resource for
  /// health checking this BackendService. Currently at most one health check
  /// can be specified, and a health check is required for Compute Engine
  /// backend services. A health check must not be specified for App Engine
  /// backend and Cloud Function backend.
  ///
  /// For internal load balancing, a URL to a HealthCheck resource must be
  /// specified instead.
  core.List<core.String> healthChecks;
  BackendServiceIAP iap;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of resource. Always compute#backendService for backend
  /// services.
  core.String kind;

  /// Indicates whether the backend service will be used with internal or
  /// external load balancing. A backend service created for one type of load
  /// balancing cannot be used with the other. Possible values are INTERNAL and
  /// EXTERNAL.
  /// Possible string values are:
  /// - "EXTERNAL"
  /// - "INTERNAL"
  /// - "INVALID_LOAD_BALANCING_SCHEME"
  core.String loadBalancingScheme;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
  /// be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// Deprecated in favor of portName. The TCP port to connect on the backend.
  /// The default value is 80.
  ///
  /// This cannot be used for internal load balancing.
  core.int port;

  /// Name of backend port. The same name should appear in the instance groups
  /// referenced by this service. Required when the load balancing scheme is
  /// EXTERNAL.
  ///
  /// When the load balancing scheme is INTERNAL, this field is not used.
  core.String portName;

  /// The protocol this BackendService uses to communicate with backends.
  ///
  /// Possible values are HTTP, HTTPS, TCP, and SSL. The default is HTTP.
  ///
  /// For internal load balancing, the possible values are TCP and UDP, and the
  /// default is TCP.
  /// Possible string values are:
  /// - "HTTP"
  /// - "HTTPS"
  /// - "SSL"
  /// - "TCP"
  /// - "UDP"
  core.String protocol;

  /// [Output Only] URL of the region where the regional backend service
  /// resides. This field is not applicable to global backend services. You must
  /// specify this field as part of the HTTP request URL. It is not settable as
  /// a field in the request body.
  core.String region;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// Type of session affinity to use. The default is NONE.
  ///
  /// When the load balancing scheme is EXTERNAL, can be NONE, CLIENT_IP, or
  /// GENERATED_COOKIE.
  ///
  /// When the load balancing scheme is INTERNAL, can be NONE, CLIENT_IP,
  /// CLIENT_IP_PROTO, or CLIENT_IP_PORT_PROTO.
  ///
  /// When the protocol is UDP, this field is not used.
  /// Possible string values are:
  /// - "CLIENT_IP"
  /// - "CLIENT_IP_PORT_PROTO"
  /// - "CLIENT_IP_PROTO"
  /// - "GENERATED_COOKIE"
  /// - "NONE"
  core.String sessionAffinity;

  /// How many seconds to wait for the backend before considering it a failed
  /// request. Default is 30 seconds.
  core.int timeoutSec;

  BackendService();

  BackendService.fromJson(core.Map _json) {
    if (_json.containsKey("affinityCookieTtlSec")) {
      affinityCookieTtlSec = _json["affinityCookieTtlSec"];
    }
    if (_json.containsKey("backends")) {
      backends = _json["backends"]
          .map((value) => new Backend.fromJson(value))
          .toList();
    }
    if (_json.containsKey("cdnPolicy")) {
      cdnPolicy = new BackendServiceCdnPolicy.fromJson(_json["cdnPolicy"]);
    }
    if (_json.containsKey("connectionDraining")) {
      connectionDraining =
          new ConnectionDraining.fromJson(_json["connectionDraining"]);
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("enableCDN")) {
      enableCDN = _json["enableCDN"];
    }
    if (_json.containsKey("fingerprint")) {
      fingerprint = _json["fingerprint"];
    }
    if (_json.containsKey("healthChecks")) {
      healthChecks = _json["healthChecks"];
    }
    if (_json.containsKey("iap")) {
      iap = new BackendServiceIAP.fromJson(_json["iap"]);
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("loadBalancingScheme")) {
      loadBalancingScheme = _json["loadBalancingScheme"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("port")) {
      port = _json["port"];
    }
    if (_json.containsKey("portName")) {
      portName = _json["portName"];
    }
    if (_json.containsKey("protocol")) {
      protocol = _json["protocol"];
    }
    if (_json.containsKey("region")) {
      region = _json["region"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("sessionAffinity")) {
      sessionAffinity = _json["sessionAffinity"];
    }
    if (_json.containsKey("timeoutSec")) {
      timeoutSec = _json["timeoutSec"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (affinityCookieTtlSec != null) {
      _json["affinityCookieTtlSec"] = affinityCookieTtlSec;
    }
    if (backends != null) {
      _json["backends"] = backends.map((value) => (value).toJson()).toList();
    }
    if (cdnPolicy != null) {
      _json["cdnPolicy"] = (cdnPolicy).toJson();
    }
    if (connectionDraining != null) {
      _json["connectionDraining"] = (connectionDraining).toJson();
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (enableCDN != null) {
      _json["enableCDN"] = enableCDN;
    }
    if (fingerprint != null) {
      _json["fingerprint"] = fingerprint;
    }
    if (healthChecks != null) {
      _json["healthChecks"] = healthChecks;
    }
    if (iap != null) {
      _json["iap"] = (iap).toJson();
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (loadBalancingScheme != null) {
      _json["loadBalancingScheme"] = loadBalancingScheme;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (port != null) {
      _json["port"] = port;
    }
    if (portName != null) {
      _json["portName"] = portName;
    }
    if (protocol != null) {
      _json["protocol"] = protocol;
    }
    if (region != null) {
      _json["region"] = region;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (sessionAffinity != null) {
      _json["sessionAffinity"] = sessionAffinity;
    }
    if (timeoutSec != null) {
      _json["timeoutSec"] = timeoutSec;
    }
    return _json;
  }
}

class BackendServiceAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  BackendServiceAggregatedListWarningData();

  BackendServiceAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class BackendServiceAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<BackendServiceAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  BackendServiceAggregatedListWarning();

  BackendServiceAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) =>
              new BackendServiceAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of BackendServicesScopedList.
class BackendServiceAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of BackendServicesScopedList resources.
  core.Map<core.String, BackendServicesScopedList> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  BackendServiceAggregatedListWarning warning;

  BackendServiceAggregatedList();

  BackendServiceAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons.mapMap<core.Map<core.String, core.Object>,
              BackendServicesScopedList>(
          _json["items"],
          (core.Map<core.String, core.Object> item) =>
              new BackendServicesScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning =
          new BackendServiceAggregatedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = commons.mapMap<BackendServicesScopedList,
              core.Map<core.String, core.Object>>(
          items, (BackendServicesScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// Message containing Cloud CDN configuration for a backend service.
class BackendServiceCdnPolicy {
  /// The CacheKeyPolicy for this CdnPolicy.
  CacheKeyPolicy cacheKeyPolicy;

  BackendServiceCdnPolicy();

  BackendServiceCdnPolicy.fromJson(core.Map _json) {
    if (_json.containsKey("cacheKeyPolicy")) {
      cacheKeyPolicy = new CacheKeyPolicy.fromJson(_json["cacheKeyPolicy"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (cacheKeyPolicy != null) {
      _json["cacheKeyPolicy"] = (cacheKeyPolicy).toJson();
    }
    return _json;
  }
}

class BackendServiceGroupHealth {
  core.List<HealthStatus> healthStatus;

  /// [Output Only] Type of resource. Always compute#backendServiceGroupHealth
  /// for the health of backend services.
  core.String kind;

  BackendServiceGroupHealth();

  BackendServiceGroupHealth.fromJson(core.Map _json) {
    if (_json.containsKey("healthStatus")) {
      healthStatus = _json["healthStatus"]
          .map((value) => new HealthStatus.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (healthStatus != null) {
      _json["healthStatus"] =
          healthStatus.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    return _json;
  }
}

/// Identity-Aware Proxy
class BackendServiceIAP {
  core.bool enabled;
  core.String oauth2ClientId;
  core.String oauth2ClientSecret;

  /// [Output Only] SHA256 hash value for the field oauth2_client_secret above.
  core.String oauth2ClientSecretSha256;

  BackendServiceIAP();

  BackendServiceIAP.fromJson(core.Map _json) {
    if (_json.containsKey("enabled")) {
      enabled = _json["enabled"];
    }
    if (_json.containsKey("oauth2ClientId")) {
      oauth2ClientId = _json["oauth2ClientId"];
    }
    if (_json.containsKey("oauth2ClientSecret")) {
      oauth2ClientSecret = _json["oauth2ClientSecret"];
    }
    if (_json.containsKey("oauth2ClientSecretSha256")) {
      oauth2ClientSecretSha256 = _json["oauth2ClientSecretSha256"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (enabled != null) {
      _json["enabled"] = enabled;
    }
    if (oauth2ClientId != null) {
      _json["oauth2ClientId"] = oauth2ClientId;
    }
    if (oauth2ClientSecret != null) {
      _json["oauth2ClientSecret"] = oauth2ClientSecret;
    }
    if (oauth2ClientSecretSha256 != null) {
      _json["oauth2ClientSecretSha256"] = oauth2ClientSecretSha256;
    }
    return _json;
  }
}

class BackendServiceListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  BackendServiceListWarningData();

  BackendServiceListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class BackendServiceListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<BackendServiceListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  BackendServiceListWarning();

  BackendServiceListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new BackendServiceListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of BackendService resources.
class BackendServiceList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of BackendService resources.
  core.List<BackendService> items;

  /// [Output Only] Type of resource. Always compute#backendServiceList for
  /// lists of backend services.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  BackendServiceListWarning warning;

  BackendServiceList();

  BackendServiceList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = _json["items"]
          .map((value) => new BackendService.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new BackendServiceListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class BackendServicesScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  BackendServicesScopedListWarningData();

  BackendServicesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// Informational warning which replaces the list of backend services when the
/// list is empty.
class BackendServicesScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<BackendServicesScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  BackendServicesScopedListWarning();

  BackendServicesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) =>
              new BackendServicesScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class BackendServicesScopedList {
  /// List of BackendServices contained in this scope.
  core.List<BackendService> backendServices;

  /// Informational warning which replaces the list of backend services when the
  /// list is empty.
  BackendServicesScopedListWarning warning;

  BackendServicesScopedList();

  BackendServicesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("backendServices")) {
      backendServices = _json["backendServices"]
          .map((value) => new BackendService.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning = new BackendServicesScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (backendServices != null) {
      _json["backendServices"] =
          backendServices.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class CacheInvalidationRule {
  /// If set, this invalidation rule will only apply to requests with a Host
  /// header matching host.
  core.String host;
  core.String path;

  CacheInvalidationRule();

  CacheInvalidationRule.fromJson(core.Map _json) {
    if (_json.containsKey("host")) {
      host = _json["host"];
    }
    if (_json.containsKey("path")) {
      path = _json["path"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (host != null) {
      _json["host"] = host;
    }
    if (path != null) {
      _json["path"] = path;
    }
    return _json;
  }
}

/// Message containing what to include in the cache key for a request for Cloud
/// CDN.
class CacheKeyPolicy {
  /// If true, requests to different hosts will be cached separately.
  core.bool includeHost;

  /// If true, http and https requests will be cached separately.
  core.bool includeProtocol;

  /// If true, include query string parameters in the cache key according to
  /// query_string_whitelist and query_string_blacklist. If neither is set, the
  /// entire query string will be included. If false, the query string will be
  /// excluded from the cache key entirely.
  core.bool includeQueryString;

  /// Names of query string parameters to exclude in cache keys. All other
  /// parameters will be included. Either specify query_string_whitelist or
  /// query_string_blacklist, not both. '&' and '=' will be percent encoded and
  /// not treated as delimiters.
  core.List<core.String> queryStringBlacklist;

  /// Names of query string parameters to include in cache keys. All other
  /// parameters will be excluded. Either specify query_string_whitelist or
  /// query_string_blacklist, not both. '&' and '=' will be percent encoded and
  /// not treated as delimiters.
  core.List<core.String> queryStringWhitelist;

  CacheKeyPolicy();

  CacheKeyPolicy.fromJson(core.Map _json) {
    if (_json.containsKey("includeHost")) {
      includeHost = _json["includeHost"];
    }
    if (_json.containsKey("includeProtocol")) {
      includeProtocol = _json["includeProtocol"];
    }
    if (_json.containsKey("includeQueryString")) {
      includeQueryString = _json["includeQueryString"];
    }
    if (_json.containsKey("queryStringBlacklist")) {
      queryStringBlacklist = _json["queryStringBlacklist"];
    }
    if (_json.containsKey("queryStringWhitelist")) {
      queryStringWhitelist = _json["queryStringWhitelist"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (includeHost != null) {
      _json["includeHost"] = includeHost;
    }
    if (includeProtocol != null) {
      _json["includeProtocol"] = includeProtocol;
    }
    if (includeQueryString != null) {
      _json["includeQueryString"] = includeQueryString;
    }
    if (queryStringBlacklist != null) {
      _json["queryStringBlacklist"] = queryStringBlacklist;
    }
    if (queryStringWhitelist != null) {
      _json["queryStringWhitelist"] = queryStringWhitelist;
    }
    return _json;
  }
}

/// Represents a Commitment resource. Creating a Commitment resource means that
/// you are purchasing a committed use contract with an explicit start and end
/// time. You can create commitments based on vCPUs and memory usage and receive
/// discounted rates. For full details, read Signing Up for Committed Use
/// Discounts.
///
/// Committed use discounts are subject to Google Cloud Platform's Service
/// Specific Terms. By purchasing a committed use discount, you agree to these
/// terms. Committed use discounts will not renew, so you must purchase a new
/// commitment to continue receiving discounts. (== resource_for
/// beta.commitments ==) (== resource_for v1.commitments ==)
class Commitment {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] Commitment end time in RFC3339 text format.
  core.String endTimestamp;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#commitment for
  /// commitments.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
  /// be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// The plan for this commitment, which determines duration and discount rate.
  /// The currently supported plans are TWELVE_MONTH (1 year), and
  /// THIRTY_SIX_MONTH (3 years).
  /// Possible string values are:
  /// - "INVALID"
  /// - "THIRTY_SIX_MONTH"
  /// - "TWELVE_MONTH"
  core.String plan;

  /// [Output Only] URL of the region where this commitment may be used.
  core.String region;

  /// List of commitment amounts for particular resources. Note that VCPU and
  /// MEMORY resource commitments must occur together.
  core.List<ResourceCommitment> resources;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] Commitment start time in RFC3339 text format.
  core.String startTimestamp;

  /// [Output Only] Status of the commitment with regards to eventual expiration
  /// (each commitment has an end date defined). One of the following values:
  /// NOT_YET_ACTIVE, ACTIVE, EXPIRED.
  /// Possible string values are:
  /// - "ACTIVE"
  /// - "CREATING"
  /// - "EXPIRED"
  /// - "NOT_YET_ACTIVE"
  core.String status;

  /// [Output Only] An optional, human-readable explanation of the status.
  core.String statusMessage;

  Commitment();

  Commitment.fromJson(core.Map _json) {
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("endTimestamp")) {
      endTimestamp = _json["endTimestamp"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("plan")) {
      plan = _json["plan"];
    }
    if (_json.containsKey("region")) {
      region = _json["region"];
    }
    if (_json.containsKey("resources")) {
      resources = _json["resources"]
          .map((value) => new ResourceCommitment.fromJson(value))
          .toList();
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("startTimestamp")) {
      startTimestamp = _json["startTimestamp"];
    }
    if (_json.containsKey("status")) {
      status = _json["status"];
    }
    if (_json.containsKey("statusMessage")) {
      statusMessage = _json["statusMessage"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (endTimestamp != null) {
      _json["endTimestamp"] = endTimestamp;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (plan != null) {
      _json["plan"] = plan;
    }
    if (region != null) {
      _json["region"] = region;
    }
    if (resources != null) {
      _json["resources"] = resources.map((value) => (value).toJson()).toList();
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (startTimestamp != null) {
      _json["startTimestamp"] = startTimestamp;
    }
    if (status != null) {
      _json["status"] = status;
    }
    if (statusMessage != null) {
      _json["statusMessage"] = statusMessage;
    }
    return _json;
  }
}

class CommitmentAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  CommitmentAggregatedListWarningData();

  CommitmentAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class CommitmentAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<CommitmentAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  CommitmentAggregatedListWarning();

  CommitmentAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) =>
              new CommitmentAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class CommitmentAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of CommitmentsScopedList resources.
  core.Map<core.String, CommitmentsScopedList> items;

  /// [Output Only] Type of resource. Always compute#commitmentAggregatedList
  /// for aggregated lists of commitments.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  CommitmentAggregatedListWarning warning;

  CommitmentAggregatedList();

  CommitmentAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons
          .mapMap<core.Map<core.String, core.Object>, CommitmentsScopedList>(
              _json["items"],
              (core.Map<core.String, core.Object> item) =>
                  new CommitmentsScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new CommitmentAggregatedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = commons
          .mapMap<CommitmentsScopedList, core.Map<core.String, core.Object>>(
              items, (CommitmentsScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class CommitmentListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  CommitmentListWarningData();

  CommitmentListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class CommitmentListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<CommitmentListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  CommitmentListWarning();

  CommitmentListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new CommitmentListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of Commitment resources.
class CommitmentList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Commitment resources.
  core.List<Commitment> items;

  /// [Output Only] Type of resource. Always compute#commitmentList for lists of
  /// commitments.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  CommitmentListWarning warning;

  CommitmentList();

  CommitmentList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = _json["items"]
          .map((value) => new Commitment.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new CommitmentListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class CommitmentsScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  CommitmentsScopedListWarningData();

  CommitmentsScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning which replaces the list of commitments
/// when the list is empty.
class CommitmentsScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<CommitmentsScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  CommitmentsScopedListWarning();

  CommitmentsScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new CommitmentsScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class CommitmentsScopedList {
  /// [Output Only] List of commitments contained in this scope.
  core.List<Commitment> commitments;

  /// [Output Only] Informational warning which replaces the list of commitments
  /// when the list is empty.
  CommitmentsScopedListWarning warning;

  CommitmentsScopedList();

  CommitmentsScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("commitments")) {
      commitments = _json["commitments"]
          .map((value) => new Commitment.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning = new CommitmentsScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (commitments != null) {
      _json["commitments"] =
          commitments.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// Message containing connection draining configuration.
class ConnectionDraining {
  /// Time for which instance will be drained (not accept new connections, but
  /// still work to finish started).
  core.int drainingTimeoutSec;

  ConnectionDraining();

  ConnectionDraining.fromJson(core.Map _json) {
    if (_json.containsKey("drainingTimeoutSec")) {
      drainingTimeoutSec = _json["drainingTimeoutSec"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (drainingTimeoutSec != null) {
      _json["drainingTimeoutSec"] = drainingTimeoutSec;
    }
    return _json;
  }
}

/// Represents a customer-supplied encryption key
class CustomerEncryptionKey {
  /// Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648
  /// base64 to either encrypt or decrypt this resource.
  core.String rawKey;

  /// [Output only] The RFC 4648 base64 encoded SHA-256 hash of the
  /// customer-supplied encryption key that protects this resource.
  core.String sha256;

  CustomerEncryptionKey();

  CustomerEncryptionKey.fromJson(core.Map _json) {
    if (_json.containsKey("rawKey")) {
      rawKey = _json["rawKey"];
    }
    if (_json.containsKey("sha256")) {
      sha256 = _json["sha256"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (rawKey != null) {
      _json["rawKey"] = rawKey;
    }
    if (sha256 != null) {
      _json["sha256"] = sha256;
    }
    return _json;
  }
}

class CustomerEncryptionKeyProtectedDisk {
  /// Decrypts data associated with the disk with a customer-supplied encryption
  /// key.
  CustomerEncryptionKey diskEncryptionKey;

  /// Specifies a valid partial or full URL to an existing Persistent Disk
  /// resource. This field is only applicable for persistent disks.
  core.String source;

  CustomerEncryptionKeyProtectedDisk();

  CustomerEncryptionKeyProtectedDisk.fromJson(core.Map _json) {
    if (_json.containsKey("diskEncryptionKey")) {
      diskEncryptionKey =
          new CustomerEncryptionKey.fromJson(_json["diskEncryptionKey"]);
    }
    if (_json.containsKey("source")) {
      source = _json["source"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (diskEncryptionKey != null) {
      _json["diskEncryptionKey"] = (diskEncryptionKey).toJson();
    }
    if (source != null) {
      _json["source"] = source;
    }
    return _json;
  }
}

/// Deprecation status for a public resource.
class DeprecationStatus {
  /// An optional RFC3339 timestamp on or after which the state of this resource
  /// is intended to change to DELETED. This is only informational and the
  /// status will not change unless the client explicitly changes it.
  core.String deleted;

  /// An optional RFC3339 timestamp on or after which the state of this resource
  /// is intended to change to DEPRECATED. This is only informational and the
  /// status will not change unless the client explicitly changes it.
  core.String deprecated;

  /// An optional RFC3339 timestamp on or after which the state of this resource
  /// is intended to change to OBSOLETE. This is only informational and the
  /// status will not change unless the client explicitly changes it.
  core.String obsolete;

  /// The URL of the suggested replacement for a deprecated resource. The
  /// suggested replacement resource must be the same kind of resource as the
  /// deprecated resource.
  core.String replacement;

  /// The deprecation state of this resource. This can be DEPRECATED, OBSOLETE,
  /// or DELETED. Operations which create a new resource using a DEPRECATED
  /// resource will return successfully, but with a warning indicating the
  /// deprecated resource and recommending its replacement. Operations which use
  /// OBSOLETE or DELETED resources will be rejected and result in an error.
  /// Possible string values are:
  /// - "DELETED"
  /// - "DEPRECATED"
  /// - "OBSOLETE"
  core.String state;

  DeprecationStatus();

  DeprecationStatus.fromJson(core.Map _json) {
    if (_json.containsKey("deleted")) {
      deleted = _json["deleted"];
    }
    if (_json.containsKey("deprecated")) {
      deprecated = _json["deprecated"];
    }
    if (_json.containsKey("obsolete")) {
      obsolete = _json["obsolete"];
    }
    if (_json.containsKey("replacement")) {
      replacement = _json["replacement"];
    }
    if (_json.containsKey("state")) {
      state = _json["state"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (deleted != null) {
      _json["deleted"] = deleted;
    }
    if (deprecated != null) {
      _json["deprecated"] = deprecated;
    }
    if (obsolete != null) {
      _json["obsolete"] = obsolete;
    }
    if (replacement != null) {
      _json["replacement"] = replacement;
    }
    if (state != null) {
      _json["state"] = state;
    }
    return _json;
  }
}

/// A Disk resource. (== resource_for beta.disks ==) (== resource_for v1.disks
/// ==)
class Disk {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// Encrypts the disk using a customer-supplied encryption key.
  ///
  /// After you encrypt a disk with a customer-supplied key, you must provide
  /// the same key if you use the disk later (e.g. to create a disk snapshot or
  /// an image, or to attach the disk to a virtual machine).
  ///
  /// Customer-supplied encryption keys do not protect access to metadata of the
  /// disk.
  ///
  /// If you do not provide an encryption key when creating the disk, then the
  /// disk will be encrypted using an automatically generated key and you do not
  /// need to provide a key to use the disk later.
  CustomerEncryptionKey diskEncryptionKey;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#disk for disks.
  core.String kind;

  /// A fingerprint for the labels being applied to this disk, which is
  /// essentially a hash of the labels set used for optimistic locking. The
  /// fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update labels. You must always provide an
  /// up-to-date fingerprint hash in order to update or change labels.
  ///
  /// To see the latest fingerprint, make a get() request to retrieve a disk.
  core.String labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes {
    return convert.BASE64.decode(labelFingerprint);
  }

  void set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.BASE64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  /// Labels to apply to this disk. These can be later modified by the setLabels
  /// method.
  core.Map<core.String, core.String> labels;

  /// [Output Only] Last attach timestamp in RFC3339 text format.
  core.String lastAttachTimestamp;

  /// [Output Only] Last detach timestamp in RFC3339 text format.
  core.String lastDetachTimestamp;

  /// Any applicable publicly visible licenses.
  core.List<core.String> licenses;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
  /// be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// Internal use only.
  core.String options;

  /// [Output Only] Server-defined fully-qualified URL for this resource.
  core.String selfLink;

  /// Size of the persistent disk, specified in GB. You can specify this field
  /// when creating a persistent disk using the sourceImage or sourceSnapshot
  /// parameter, or specify it alone to create an empty persistent disk.
  ///
  /// If you specify this field along with sourceImage or sourceSnapshot, the
  /// value of sizeGb must not be less than the size of the sourceImage or the
  /// size of the snapshot. Acceptable values are 1 to 65536, inclusive.
  core.String sizeGb;

  /// The source image used to create this disk. If the source image is deleted,
  /// this field will not be set.
  ///
  /// To create a disk with one of the public operating system images, specify
  /// the image by its family name. For example, specify family/debian-8 to use
  /// the latest Debian 8 image:
  /// projects/debian-cloud/global/images/family/debian-8
  ///
  ///
  /// Alternatively, use a specific version of a public operating system image:
  /// projects/debian-cloud/global/images/debian-8-jessie-vYYYYMMDD
  ///
  ///
  /// To create a disk with a custom image that you created, specify the image
  /// name in the following format:
  /// global/images/my-custom-image
  ///
  ///
  /// You can also specify a custom image by its image family, which returns the
  /// latest version of the image in that family. Replace the image name with
  /// family/family-name:
  /// global/images/family/my-image-family
  core.String sourceImage;

  /// The customer-supplied encryption key of the source image. Required if the
  /// source image is protected by a customer-supplied encryption key.
  CustomerEncryptionKey sourceImageEncryptionKey;

  /// [Output Only] The ID value of the image used to create this disk. This
  /// value identifies the exact image that was used to create this persistent
  /// disk. For example, if you created the persistent disk from an image that
  /// was later deleted and recreated under the same name, the source image ID
  /// would identify the exact version of the image that was used.
  core.String sourceImageId;

  /// The source snapshot used to create this disk. You can provide this as a
  /// partial or full URL to the resource. For example, the following are valid
  /// values:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/global/snapshots/snapshot
  /// - projects/project/global/snapshots/snapshot
  /// - global/snapshots/snapshot
  core.String sourceSnapshot;

  /// The customer-supplied encryption key of the source snapshot. Required if
  /// the source snapshot is protected by a customer-supplied encryption key.
  CustomerEncryptionKey sourceSnapshotEncryptionKey;

  /// [Output Only] The unique ID of the snapshot used to create this disk. This
  /// value identifies the exact snapshot that was used to create this
  /// persistent disk. For example, if you created the persistent disk from a
  /// snapshot that was later deleted and recreated under the same name, the
  /// source snapshot ID would identify the exact version of the snapshot that
  /// was used.
  core.String sourceSnapshotId;

  /// [Output Only] The status of disk creation.
  /// Possible string values are:
  /// - "CREATING"
  /// - "FAILED"
  /// - "READY"
  /// - "RESTORING"
  core.String status;

  /// URL of the disk type resource describing which disk type to use to create
  /// the disk. Provide this when creating the disk. For example:
  /// project/zones/zone/diskTypes/pd-standard or pd-ssd
  core.String type;

  /// [Output Only] Links to the users of the disk (attached instances) in form:
  /// project/zones/zone/instances/instance
  core.List<core.String> users;

  /// [Output Only] URL of the zone where the disk resides. You must specify
  /// this field as part of the HTTP request URL. It is not settable as a field
  /// in the request body.
  core.String zone;

  Disk();

  Disk.fromJson(core.Map _json) {
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("diskEncryptionKey")) {
      diskEncryptionKey =
          new CustomerEncryptionKey.fromJson(_json["diskEncryptionKey"]);
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("labelFingerprint")) {
      labelFingerprint = _json["labelFingerprint"];
    }
    if (_json.containsKey("labels")) {
      labels = _json["labels"];
    }
    if (_json.containsKey("lastAttachTimestamp")) {
      lastAttachTimestamp = _json["lastAttachTimestamp"];
    }
    if (_json.containsKey("lastDetachTimestamp")) {
      lastDetachTimestamp = _json["lastDetachTimestamp"];
    }
    if (_json.containsKey("licenses")) {
      licenses = _json["licenses"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("options")) {
      options = _json["options"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("sizeGb")) {
      sizeGb = _json["sizeGb"];
    }
    if (_json.containsKey("sourceImage")) {
      sourceImage = _json["sourceImage"];
    }
    if (_json.containsKey("sourceImageEncryptionKey")) {
      sourceImageEncryptionKey =
          new CustomerEncryptionKey.fromJson(_json["sourceImageEncryptionKey"]);
    }
    if (_json.containsKey("sourceImageId")) {
      sourceImageId = _json["sourceImageId"];
    }
    if (_json.containsKey("sourceSnapshot")) {
      sourceSnapshot = _json["sourceSnapshot"];
    }
    if (_json.containsKey("sourceSnapshotEncryptionKey")) {
      sourceSnapshotEncryptionKey = new CustomerEncryptionKey.fromJson(
          _json["sourceSnapshotEncryptionKey"]);
    }
    if (_json.containsKey("sourceSnapshotId")) {
      sourceSnapshotId = _json["sourceSnapshotId"];
    }
    if (_json.containsKey("status")) {
      status = _json["status"];
    }
    if (_json.containsKey("type")) {
      type = _json["type"];
    }
    if (_json.containsKey("users")) {
      users = _json["users"];
    }
    if (_json.containsKey("zone")) {
      zone = _json["zone"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (diskEncryptionKey != null) {
      _json["diskEncryptionKey"] = (diskEncryptionKey).toJson();
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (labelFingerprint != null) {
      _json["labelFingerprint"] = labelFingerprint;
    }
    if (labels != null) {
      _json["labels"] = labels;
    }
    if (lastAttachTimestamp != null) {
      _json["lastAttachTimestamp"] = lastAttachTimestamp;
    }
    if (lastDetachTimestamp != null) {
      _json["lastDetachTimestamp"] = lastDetachTimestamp;
    }
    if (licenses != null) {
      _json["licenses"] = licenses;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (options != null) {
      _json["options"] = options;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (sizeGb != null) {
      _json["sizeGb"] = sizeGb;
    }
    if (sourceImage != null) {
      _json["sourceImage"] = sourceImage;
    }
    if (sourceImageEncryptionKey != null) {
      _json["sourceImageEncryptionKey"] = (sourceImageEncryptionKey).toJson();
    }
    if (sourceImageId != null) {
      _json["sourceImageId"] = sourceImageId;
    }
    if (sourceSnapshot != null) {
      _json["sourceSnapshot"] = sourceSnapshot;
    }
    if (sourceSnapshotEncryptionKey != null) {
      _json["sourceSnapshotEncryptionKey"] =
          (sourceSnapshotEncryptionKey).toJson();
    }
    if (sourceSnapshotId != null) {
      _json["sourceSnapshotId"] = sourceSnapshotId;
    }
    if (status != null) {
      _json["status"] = status;
    }
    if (type != null) {
      _json["type"] = type;
    }
    if (users != null) {
      _json["users"] = users;
    }
    if (zone != null) {
      _json["zone"] = zone;
    }
    return _json;
  }
}

class DiskAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  DiskAggregatedListWarningData();

  DiskAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class DiskAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<DiskAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  DiskAggregatedListWarning();

  DiskAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new DiskAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class DiskAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of DisksScopedList resources.
  core.Map<core.String, DisksScopedList> items;

  /// [Output Only] Type of resource. Always compute#diskAggregatedList for
  /// aggregated lists of persistent disks.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  DiskAggregatedListWarning warning;

  DiskAggregatedList();

  DiskAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items =
          commons.mapMap<core.Map<core.String, core.Object>, DisksScopedList>(
              _json["items"],
              (core.Map<core.String, core.Object> item) =>
                  new DisksScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new DiskAggregatedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] =
          commons.mapMap<DisksScopedList, core.Map<core.String, core.Object>>(
              items, (DisksScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class DiskListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  DiskListWarningData();

  DiskListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class DiskListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<DiskListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  DiskListWarning();

  DiskListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new DiskListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// A list of Disk resources.
class DiskList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Disk resources.
  core.List<Disk> items;

  /// [Output Only] Type of resource. Always compute#diskList for lists of
  /// disks.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  DiskListWarning warning;

  DiskList();

  DiskList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = _json["items"].map((value) => new Disk.fromJson(value)).toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new DiskListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class DiskMoveRequest {
  /// The URL of the destination zone to move the disk. This can be a full or
  /// partial URL. For example, the following are all valid URLs to a zone:
  /// - https://www.googleapis.com/compute/v1/projects/project/zones/zone
  /// - projects/project/zones/zone
  /// - zones/zone
  core.String destinationZone;

  /// The URL of the target disk to move. This can be a full or partial URL. For
  /// example, the following are all valid URLs to a disk:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone/disks/disk
  /// - projects/project/zones/zone/disks/disk
  /// - zones/zone/disks/disk
  core.String targetDisk;

  DiskMoveRequest();

  DiskMoveRequest.fromJson(core.Map _json) {
    if (_json.containsKey("destinationZone")) {
      destinationZone = _json["destinationZone"];
    }
    if (_json.containsKey("targetDisk")) {
      targetDisk = _json["targetDisk"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (destinationZone != null) {
      _json["destinationZone"] = destinationZone;
    }
    if (targetDisk != null) {
      _json["targetDisk"] = targetDisk;
    }
    return _json;
  }
}

/// A DiskType resource. (== resource_for beta.diskTypes ==) (== resource_for
/// v1.diskTypes ==)
class DiskType {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// [Output Only] Server-defined default disk size in GB.
  core.String defaultDiskSizeGb;

  /// [Output Only] The deprecation status associated with this disk type.
  DeprecationStatus deprecated;

  /// [Output Only] An optional description of this resource.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#diskType for disk
  /// types.
  core.String kind;

  /// [Output Only] Name of the resource.
  core.String name;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] An optional textual description of the valid disk size, such
  /// as "10GB-10TB".
  core.String validDiskSize;

  /// [Output Only] URL of the zone where the disk type resides. You must
  /// specify this field as part of the HTTP request URL. It is not settable as
  /// a field in the request body.
  core.String zone;

  DiskType();

  DiskType.fromJson(core.Map _json) {
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("defaultDiskSizeGb")) {
      defaultDiskSizeGb = _json["defaultDiskSizeGb"];
    }
    if (_json.containsKey("deprecated")) {
      deprecated = new DeprecationStatus.fromJson(_json["deprecated"]);
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("validDiskSize")) {
      validDiskSize = _json["validDiskSize"];
    }
    if (_json.containsKey("zone")) {
      zone = _json["zone"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (defaultDiskSizeGb != null) {
      _json["defaultDiskSizeGb"] = defaultDiskSizeGb;
    }
    if (deprecated != null) {
      _json["deprecated"] = (deprecated).toJson();
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (validDiskSize != null) {
      _json["validDiskSize"] = validDiskSize;
    }
    if (zone != null) {
      _json["zone"] = zone;
    }
    return _json;
  }
}

class DiskTypeAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  DiskTypeAggregatedListWarningData();

  DiskTypeAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class DiskTypeAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<DiskTypeAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  DiskTypeAggregatedListWarning();

  DiskTypeAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new DiskTypeAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class DiskTypeAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of DiskTypesScopedList resources.
  core.Map<core.String, DiskTypesScopedList> items;

  /// [Output Only] Type of resource. Always compute#diskTypeAggregatedList.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  DiskTypeAggregatedListWarning warning;

  DiskTypeAggregatedList();

  DiskTypeAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons
          .mapMap<core.Map<core.String, core.Object>, DiskTypesScopedList>(
              _json["items"],
              (core.Map<core.String, core.Object> item) =>
                  new DiskTypesScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new DiskTypeAggregatedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = commons
          .mapMap<DiskTypesScopedList, core.Map<core.String, core.Object>>(
              items, (DiskTypesScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class DiskTypeListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  DiskTypeListWarningData();

  DiskTypeListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class DiskTypeListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<DiskTypeListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  DiskTypeListWarning();

  DiskTypeListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new DiskTypeListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of disk types.
class DiskTypeList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of DiskType resources.
  core.List<DiskType> items;

  /// [Output Only] Type of resource. Always compute#diskTypeList for disk
  /// types.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  DiskTypeListWarning warning;

  DiskTypeList();

  DiskTypeList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items =
          _json["items"].map((value) => new DiskType.fromJson(value)).toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new DiskTypeListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class DiskTypesScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  DiskTypesScopedListWarningData();

  DiskTypesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning which replaces the list of disk types
/// when the list is empty.
class DiskTypesScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<DiskTypesScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  DiskTypesScopedListWarning();

  DiskTypesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new DiskTypesScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class DiskTypesScopedList {
  /// [Output Only] List of disk types contained in this scope.
  core.List<DiskType> diskTypes;

  /// [Output Only] Informational warning which replaces the list of disk types
  /// when the list is empty.
  DiskTypesScopedListWarning warning;

  DiskTypesScopedList();

  DiskTypesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("diskTypes")) {
      diskTypes = _json["diskTypes"]
          .map((value) => new DiskType.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning = new DiskTypesScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (diskTypes != null) {
      _json["diskTypes"] = diskTypes.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class DisksResizeRequest {
  /// The new size of the persistent disk, which is specified in GB.
  core.String sizeGb;

  DisksResizeRequest();

  DisksResizeRequest.fromJson(core.Map _json) {
    if (_json.containsKey("sizeGb")) {
      sizeGb = _json["sizeGb"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (sizeGb != null) {
      _json["sizeGb"] = sizeGb;
    }
    return _json;
  }
}

class DisksScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  DisksScopedListWarningData();

  DisksScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning which replaces the list of disks when
/// the list is empty.
class DisksScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<DisksScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  DisksScopedListWarning();

  DisksScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new DisksScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class DisksScopedList {
  /// [Output Only] List of disks contained in this scope.
  core.List<Disk> disks;

  /// [Output Only] Informational warning which replaces the list of disks when
  /// the list is empty.
  DisksScopedListWarning warning;

  DisksScopedList();

  DisksScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("disks")) {
      disks = _json["disks"].map((value) => new Disk.fromJson(value)).toList();
    }
    if (_json.containsKey("warning")) {
      warning = new DisksScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (disks != null) {
      _json["disks"] = disks.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class FirewallAllowed {
  /// The IP protocol to which this rule applies. The protocol type is required
  /// when creating a firewall rule. This value can either be one of the
  /// following well known protocol strings (tcp, udp, icmp, esp, ah, ipip,
  /// sctp), or the IP protocol number.
  core.String IPProtocol;

  /// An optional list of ports to which this rule applies. This field is only
  /// applicable for UDP or TCP protocol. Each entry must be either an integer
  /// or a range. If not specified, this rule applies to connections through any
  /// port.
  ///
  /// Example inputs include: ["22"], ["80","443"], and ["12345-12349"].
  core.List<core.String> ports;

  FirewallAllowed();

  FirewallAllowed.fromJson(core.Map _json) {
    if (_json.containsKey("IPProtocol")) {
      IPProtocol = _json["IPProtocol"];
    }
    if (_json.containsKey("ports")) {
      ports = _json["ports"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (IPProtocol != null) {
      _json["IPProtocol"] = IPProtocol;
    }
    if (ports != null) {
      _json["ports"] = ports;
    }
    return _json;
  }
}

class FirewallDenied {
  /// The IP protocol to which this rule applies. The protocol type is required
  /// when creating a firewall rule. This value can either be one of the
  /// following well known protocol strings (tcp, udp, icmp, esp, ah, ipip,
  /// sctp), or the IP protocol number.
  core.String IPProtocol;

  /// An optional list of ports to which this rule applies. This field is only
  /// applicable for UDP or TCP protocol. Each entry must be either an integer
  /// or a range. If not specified, this rule applies to connections through any
  /// port.
  ///
  /// Example inputs include: ["22"], ["80","443"], and ["12345-12349"].
  core.List<core.String> ports;

  FirewallDenied();

  FirewallDenied.fromJson(core.Map _json) {
    if (_json.containsKey("IPProtocol")) {
      IPProtocol = _json["IPProtocol"];
    }
    if (_json.containsKey("ports")) {
      ports = _json["ports"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (IPProtocol != null) {
      _json["IPProtocol"] = IPProtocol;
    }
    if (ports != null) {
      _json["ports"] = ports;
    }
    return _json;
  }
}

/// Represents a Firewall resource.
class Firewall {
  /// The list of ALLOW rules specified by this firewall. Each rule specifies a
  /// protocol and port-range tuple that describes a permitted connection.
  core.List<FirewallAllowed> allowed;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// The list of DENY rules specified by this firewall. Each rule specifies a
  /// protocol and port-range tuple that describes a denied connection.
  core.List<FirewallDenied> denied;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// If destination ranges are specified, the firewall will apply only to
  /// traffic that has destination IP address in these ranges. These ranges must
  /// be expressed in CIDR format. Only IPv4 is supported.
  core.List<core.String> destinationRanges;

  /// Direction of traffic to which this firewall applies; default is INGRESS.
  /// Note: For INGRESS traffic, it is NOT supported to specify
  /// destinationRanges; For EGRESS traffic, it is NOT supported to specify
  /// sourceRanges OR sourceTags.
  /// Possible string values are:
  /// - "EGRESS"
  /// - "INGRESS"
  core.String direction;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#firewall for firewall
  /// rules.
  core.String kind;

  /// Name of the resource; provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
  /// be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// URL of the network resource for this firewall rule. If not specified when
  /// creating a firewall rule, the default network is used:
  /// global/networks/default
  /// If you choose to specify this property, you can specify the network as a
  /// full or partial URL. For example, the following are all valid URLs:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/myproject/global/networks/my-network
  /// - projects/myproject/global/networks/my-network
  /// - global/networks/default
  core.String network;

  /// Priority for this rule. This is an integer between 0 and 65535, both
  /// inclusive. When not specified, the value assumed is 1000. Relative
  /// priorities determine precedence of conflicting rules. Lower value of
  /// priority implies higher precedence (eg, a rule with priority 0 has higher
  /// precedence than a rule with priority 1). DENY rules take precedence over
  /// ALLOW rules having equal priority.
  core.int priority;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// If source ranges are specified, the firewall will apply only to traffic
  /// that has source IP address in these ranges. These ranges must be expressed
  /// in CIDR format. One or both of sourceRanges and sourceTags may be set. If
  /// both properties are set, the firewall will apply to traffic that has
  /// source IP address within sourceRanges OR the source IP that belongs to a
  /// tag listed in the sourceTags property. The connection does not need to
  /// match both properties for the firewall to apply. Only IPv4 is supported.
  core.List<core.String> sourceRanges;

  /// If source service accounts are specified, the firewall will apply only to
  /// traffic originating from an instance with a service account in this list.
  /// Source service accounts cannot be used to control traffic to an instance's
  /// external IP address because service accounts are associated with an
  /// instance, not an IP address. sourceRanges can be set at the same time as
  /// sourceServiceAccounts. If both are set, the firewall will apply to traffic
  /// that has source IP address within sourceRanges OR the source IP belongs to
  /// an instance with service account listed in sourceServiceAccount. The
  /// connection does not need to match both properties for the firewall to
  /// apply. sourceServiceAccounts cannot be used at the same time as sourceTags
  /// or targetTags.
  core.List<core.String> sourceServiceAccounts;

  /// If source tags are specified, the firewall rule applies only to traffic
  /// with source IPs that match the primary network interfaces of VM instances
  /// that have the tag and are in the same VPC network. Source tags cannot be
  /// used to control traffic to an instance's external IP address, it only
  /// applies to traffic between instances in the same virtual network. Because
  /// tags are associated with instances, not IP addresses. One or both of
  /// sourceRanges and sourceTags may be set. If both properties are set, the
  /// firewall will apply to traffic that has source IP address within
  /// sourceRanges OR the source IP that belongs to a tag listed in the
  /// sourceTags property. The connection does not need to match both properties
  /// for the firewall to apply.
  core.List<core.String> sourceTags;

  /// A list of service accounts indicating sets of instances located in the
  /// network that may make network connections as specified in allowed[].
  /// targetServiceAccounts cannot be used at the same time as targetTags or
  /// sourceTags. If neither targetServiceAccounts nor targetTags are specified,
  /// the firewall rule applies to all instances on the specified network.
  core.List<core.String> targetServiceAccounts;

  /// A list of tags that controls which instances the firewall rule applies to.
  /// If targetTags are specified, then the firewall rule applies only to
  /// instances in the VPC network that have one of those tags. If no targetTags
  /// are specified, the firewall rule applies to all instances on the specified
  /// network.
  core.List<core.String> targetTags;

  Firewall();

  Firewall.fromJson(core.Map _json) {
    if (_json.containsKey("allowed")) {
      allowed = _json["allowed"]
          .map((value) => new FirewallAllowed.fromJson(value))
          .toList();
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("denied")) {
      denied = _json["denied"]
          .map((value) => new FirewallDenied.fromJson(value))
          .toList();
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("destinationRanges")) {
      destinationRanges = _json["destinationRanges"];
    }
    if (_json.containsKey("direction")) {
      direction = _json["direction"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("network")) {
      network = _json["network"];
    }
    if (_json.containsKey("priority")) {
      priority = _json["priority"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("sourceRanges")) {
      sourceRanges = _json["sourceRanges"];
    }
    if (_json.containsKey("sourceServiceAccounts")) {
      sourceServiceAccounts = _json["sourceServiceAccounts"];
    }
    if (_json.containsKey("sourceTags")) {
      sourceTags = _json["sourceTags"];
    }
    if (_json.containsKey("targetServiceAccounts")) {
      targetServiceAccounts = _json["targetServiceAccounts"];
    }
    if (_json.containsKey("targetTags")) {
      targetTags = _json["targetTags"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (allowed != null) {
      _json["allowed"] = allowed.map((value) => (value).toJson()).toList();
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (denied != null) {
      _json["denied"] = denied.map((value) => (value).toJson()).toList();
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (destinationRanges != null) {
      _json["destinationRanges"] = destinationRanges;
    }
    if (direction != null) {
      _json["direction"] = direction;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (network != null) {
      _json["network"] = network;
    }
    if (priority != null) {
      _json["priority"] = priority;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (sourceRanges != null) {
      _json["sourceRanges"] = sourceRanges;
    }
    if (sourceServiceAccounts != null) {
      _json["sourceServiceAccounts"] = sourceServiceAccounts;
    }
    if (sourceTags != null) {
      _json["sourceTags"] = sourceTags;
    }
    if (targetServiceAccounts != null) {
      _json["targetServiceAccounts"] = targetServiceAccounts;
    }
    if (targetTags != null) {
      _json["targetTags"] = targetTags;
    }
    return _json;
  }
}

class FirewallListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  FirewallListWarningData();

  FirewallListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class FirewallListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<FirewallListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  FirewallListWarning();

  FirewallListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new FirewallListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of firewalls.
class FirewallList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Firewall resources.
  core.List<Firewall> items;

  /// [Output Only] Type of resource. Always compute#firewallList for lists of
  /// firewalls.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  FirewallListWarning warning;

  FirewallList();

  FirewallList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items =
          _json["items"].map((value) => new Firewall.fromJson(value)).toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new FirewallListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// A ForwardingRule resource. A ForwardingRule resource specifies which pool of
/// target virtual machines to forward a packet to if it matches the given
/// [IPAddress, IPProtocol, ports] tuple. (== resource_for beta.forwardingRules
/// ==) (== resource_for v1.forwardingRules ==) (== resource_for
/// beta.globalForwardingRules ==) (== resource_for v1.globalForwardingRules ==)
/// (== resource_for beta.regionForwardingRules ==) (== resource_for
/// v1.regionForwardingRules ==)
class ForwardingRule {
  /// The IP address that this forwarding rule is serving on behalf of.
  ///
  /// Addresses are restricted based on the forwarding rule's load balancing
  /// scheme (EXTERNAL or INTERNAL) and scope (global or regional).
  ///
  /// When the load balancing scheme is EXTERNAL, for global forwarding rules,
  /// the address must be a global IP, and for regional forwarding rules, the
  /// address must live in the same region as the forwarding rule. If this field
  /// is empty, an ephemeral IPv4 address from the same scope (global or
  /// regional) will be assigned. A regional forwarding rule supports IPv4 only.
  /// A global forwarding rule supports either IPv4 or IPv6.
  ///
  /// When the load balancing scheme is INTERNAL, this can only be an RFC 1918
  /// IP address belonging to the network/subnet configured for the forwarding
  /// rule. By default, if this field is empty, an ephemeral internal IP address
  /// will be automatically allocated from the IP range of the subnet or network
  /// configured for this forwarding rule.
  ///
  /// An address can be specified either by a literal IP address or a URL
  /// reference to an existing Address resource. The following examples are all
  /// valid:
  /// - 100.1.2.3
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/regions/region/addresses/address
  /// - projects/project/regions/region/addresses/address
  /// - regions/region/addresses/address
  /// - global/addresses/address
  /// - address
  core.String IPAddress;

  /// The IP protocol to which this rule applies. Valid options are TCP, UDP,
  /// ESP, AH, SCTP or ICMP.
  ///
  /// When the load balancing scheme is INTERNAL, only TCP and UDP are valid.
  /// Possible string values are:
  /// - "AH"
  /// - "ESP"
  /// - "ICMP"
  /// - "SCTP"
  /// - "TCP"
  /// - "UDP"
  core.String IPProtocol;

  /// This field is not used for external load balancing.
  ///
  /// For internal load balancing, this field identifies the BackendService
  /// resource to receive the matched traffic.
  core.String backendService;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// The IP Version that will be used by this forwarding rule. Valid options
  /// are IPV4 or IPV6. This can only be specified for a global forwarding rule.
  /// Possible string values are:
  /// - "IPV4"
  /// - "IPV6"
  /// - "UNSPECIFIED_VERSION"
  core.String ipVersion;

  /// [Output Only] Type of the resource. Always compute#forwardingRule for
  /// Forwarding Rule resources.
  core.String kind;

  /// This signifies what the ForwardingRule will be used for and can only take
  /// the following values: INTERNAL, EXTERNAL The value of INTERNAL means that
  /// this will be used for Internal Network Load Balancing (TCP, UDP). The
  /// value of EXTERNAL means that this will be used for External Load Balancing
  /// (HTTP(S) LB, External TCP/UDP LB, SSL Proxy)
  /// Possible string values are:
  /// - "EXTERNAL"
  /// - "INTERNAL"
  /// - "INVALID"
  core.String loadBalancingScheme;

  /// Name of the resource; provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
  /// be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// This field is not used for external load balancing.
  ///
  /// For internal load balancing, this field identifies the network that the
  /// load balanced IP should belong to for this Forwarding Rule. If this field
  /// is not specified, the default network will be used.
  core.String network;

  /// This field is used along with the target field for TargetHttpProxy,
  /// TargetHttpsProxy, TargetSslProxy, TargetTcpProxy, TargetVpnGateway,
  /// TargetPool, TargetInstance.
  ///
  /// Applicable only when IPProtocol is TCP, UDP, or SCTP, only packets
  /// addressed to ports in the specified range will be forwarded to target.
  /// Forwarding rules with the same [IPAddress, IPProtocol] pair must have
  /// disjoint port ranges.
  ///
  /// Some types of forwarding target have constraints on the acceptable ports:
  /// - TargetHttpProxy: 80, 8080
  /// - TargetHttpsProxy: 443
  /// - TargetTcpProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995,
  /// 1688, 1883, 5222
  /// - TargetSslProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995,
  /// 1688, 1883, 5222
  /// - TargetVpnGateway: 500, 4500
  core.String portRange;

  /// This field is used along with the backend_service field for internal load
  /// balancing.
  ///
  /// When the load balancing scheme is INTERNAL, a single port or a comma
  /// separated list of ports can be configured. Only packets addressed to these
  /// ports will be forwarded to the backends configured with this forwarding
  /// rule.
  ///
  /// You may specify a maximum of up to 5 ports.
  core.List<core.String> ports;

  /// [Output Only] URL of the region where the regional forwarding rule
  /// resides. This field is not applicable to global forwarding rules. You must
  /// specify this field as part of the HTTP request URL. It is not settable as
  /// a field in the request body.
  core.String region;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// This field is not used for external load balancing.
  ///
  /// For internal load balancing, this field identifies the subnetwork that the
  /// load balanced IP should belong to for this Forwarding Rule.
  ///
  /// If the network specified is in auto subnet mode, this field is optional.
  /// However, if the network is in custom subnet mode, a subnetwork must be
  /// specified.
  core.String subnetwork;

  /// The URL of the target resource to receive the matched traffic. For
  /// regional forwarding rules, this target must live in the same region as the
  /// forwarding rule. For global forwarding rules, this target must be a global
  /// load balancing resource. The forwarded traffic must be of a type
  /// appropriate to the target object.
  core.String target;

  ForwardingRule();

  ForwardingRule.fromJson(core.Map _json) {
    if (_json.containsKey("IPAddress")) {
      IPAddress = _json["IPAddress"];
    }
    if (_json.containsKey("IPProtocol")) {
      IPProtocol = _json["IPProtocol"];
    }
    if (_json.containsKey("backendService")) {
      backendService = _json["backendService"];
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("ipVersion")) {
      ipVersion = _json["ipVersion"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("loadBalancingScheme")) {
      loadBalancingScheme = _json["loadBalancingScheme"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("network")) {
      network = _json["network"];
    }
    if (_json.containsKey("portRange")) {
      portRange = _json["portRange"];
    }
    if (_json.containsKey("ports")) {
      ports = _json["ports"];
    }
    if (_json.containsKey("region")) {
      region = _json["region"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("subnetwork")) {
      subnetwork = _json["subnetwork"];
    }
    if (_json.containsKey("target")) {
      target = _json["target"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (IPAddress != null) {
      _json["IPAddress"] = IPAddress;
    }
    if (IPProtocol != null) {
      _json["IPProtocol"] = IPProtocol;
    }
    if (backendService != null) {
      _json["backendService"] = backendService;
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (ipVersion != null) {
      _json["ipVersion"] = ipVersion;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (loadBalancingScheme != null) {
      _json["loadBalancingScheme"] = loadBalancingScheme;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (network != null) {
      _json["network"] = network;
    }
    if (portRange != null) {
      _json["portRange"] = portRange;
    }
    if (ports != null) {
      _json["ports"] = ports;
    }
    if (region != null) {
      _json["region"] = region;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (subnetwork != null) {
      _json["subnetwork"] = subnetwork;
    }
    if (target != null) {
      _json["target"] = target;
    }
    return _json;
  }
}

class ForwardingRuleAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  ForwardingRuleAggregatedListWarningData();

  ForwardingRuleAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class ForwardingRuleAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<ForwardingRuleAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  ForwardingRuleAggregatedListWarning();

  ForwardingRuleAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) =>
              new ForwardingRuleAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class ForwardingRuleAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of ForwardingRulesScopedList resources.
  core.Map<core.String, ForwardingRulesScopedList> items;

  /// [Output Only] Type of resource. Always
  /// compute#forwardingRuleAggregatedList for lists of forwarding rules.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  ForwardingRuleAggregatedListWarning warning;

  ForwardingRuleAggregatedList();

  ForwardingRuleAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons.mapMap<core.Map<core.String, core.Object>,
              ForwardingRulesScopedList>(
          _json["items"],
          (core.Map<core.String, core.Object> item) =>
              new ForwardingRulesScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning =
          new ForwardingRuleAggregatedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = commons.mapMap<ForwardingRulesScopedList,
              core.Map<core.String, core.Object>>(
          items, (ForwardingRulesScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class ForwardingRuleListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  ForwardingRuleListWarningData();

  ForwardingRuleListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class ForwardingRuleListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<ForwardingRuleListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  ForwardingRuleListWarning();

  ForwardingRuleListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new ForwardingRuleListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of ForwardingRule resources.
class ForwardingRuleList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of ForwardingRule resources.
  core.List<ForwardingRule> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  ForwardingRuleListWarning warning;

  ForwardingRuleList();

  ForwardingRuleList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = _json["items"]
          .map((value) => new ForwardingRule.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new ForwardingRuleListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class ForwardingRulesScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  ForwardingRulesScopedListWarningData();

  ForwardingRulesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// Informational warning which replaces the list of forwarding rules when the
/// list is empty.
class ForwardingRulesScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<ForwardingRulesScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  ForwardingRulesScopedListWarning();

  ForwardingRulesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) =>
              new ForwardingRulesScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class ForwardingRulesScopedList {
  /// List of forwarding rules contained in this scope.
  core.List<ForwardingRule> forwardingRules;

  /// Informational warning which replaces the list of forwarding rules when the
  /// list is empty.
  ForwardingRulesScopedListWarning warning;

  ForwardingRulesScopedList();

  ForwardingRulesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("forwardingRules")) {
      forwardingRules = _json["forwardingRules"]
          .map((value) => new ForwardingRule.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning = new ForwardingRulesScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (forwardingRules != null) {
      _json["forwardingRules"] =
          forwardingRules.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class GlobalSetLabelsRequest {
  /// The fingerprint of the previous set of labels for this resource, used to
  /// detect conflicts. The fingerprint is initially generated by Compute Engine
  /// and changes after every request to modify or update labels. You must
  /// always provide an up-to-date fingerprint hash when updating or changing
  /// labels. Make a get() request to the resource to get the latest
  /// fingerprint.
  core.String labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes {
    return convert.BASE64.decode(labelFingerprint);
  }

  void set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.BASE64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  /// A list of labels to apply for this resource. Each label key & value must
  /// comply with RFC1035. Specifically, the name must be 1-63 characters long
  /// and match the regular expression [a-z]([-a-z0-9]*[a-z0-9])? which means
  /// the first character must be a lowercase letter, and all following
  /// characters must be a dash, lowercase letter, or digit, except the last
  /// character, which cannot be a dash. For example, "webserver-frontend":
  /// "images". A label value can also be empty (e.g. "my-label": "").
  core.Map<core.String, core.String> labels;

  GlobalSetLabelsRequest();

  GlobalSetLabelsRequest.fromJson(core.Map _json) {
    if (_json.containsKey("labelFingerprint")) {
      labelFingerprint = _json["labelFingerprint"];
    }
    if (_json.containsKey("labels")) {
      labels = _json["labels"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (labelFingerprint != null) {
      _json["labelFingerprint"] = labelFingerprint;
    }
    if (labels != null) {
      _json["labels"] = labels;
    }
    return _json;
  }
}

/// Guest OS features.
class GuestOsFeature {
  /// The ID of a supported feature. Read  Enabling guest operating system
  /// features to see a list of available options.
  /// Possible string values are:
  /// - "FEATURE_TYPE_UNSPECIFIED"
  /// - "MULTI_IP_SUBNET"
  /// - "VIRTIO_SCSI_MULTIQUEUE"
  /// - "WINDOWS"
  core.String type;

  GuestOsFeature();

  GuestOsFeature.fromJson(core.Map _json) {
    if (_json.containsKey("type")) {
      type = _json["type"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (type != null) {
      _json["type"] = type;
    }
    return _json;
  }
}

class HTTPHealthCheck {
  /// The value of the host header in the HTTP health check request. If left
  /// empty (default value), the IP on behalf of which this health check is
  /// performed will be used.
  core.String host;

  /// The TCP port number for the health check request. The default value is 80.
  /// Valid values are 1 through 65535.
  core.int port;

  /// Port name as defined in InstanceGroup#NamedPort#name. If both port and
  /// port_name are defined, port takes precedence.
  core.String portName;

  /// Specifies the type of proxy header to append before sending data to the
  /// backend, either NONE or PROXY_V1. The default is NONE.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String proxyHeader;

  /// The request path of the HTTP health check request. The default value is /.
  core.String requestPath;

  HTTPHealthCheck();

  HTTPHealthCheck.fromJson(core.Map _json) {
    if (_json.containsKey("host")) {
      host = _json["host"];
    }
    if (_json.containsKey("port")) {
      port = _json["port"];
    }
    if (_json.containsKey("portName")) {
      portName = _json["portName"];
    }
    if (_json.containsKey("proxyHeader")) {
      proxyHeader = _json["proxyHeader"];
    }
    if (_json.containsKey("requestPath")) {
      requestPath = _json["requestPath"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (host != null) {
      _json["host"] = host;
    }
    if (port != null) {
      _json["port"] = port;
    }
    if (portName != null) {
      _json["portName"] = portName;
    }
    if (proxyHeader != null) {
      _json["proxyHeader"] = proxyHeader;
    }
    if (requestPath != null) {
      _json["requestPath"] = requestPath;
    }
    return _json;
  }
}

class HTTPSHealthCheck {
  /// The value of the host header in the HTTPS health check request. If left
  /// empty (default value), the IP on behalf of which this health check is
  /// performed will be used.
  core.String host;

  /// The TCP port number for the health check request. The default value is
  /// 443. Valid values are 1 through 65535.
  core.int port;

  /// Port name as defined in InstanceGroup#NamedPort#name. If both port and
  /// port_name are defined, port takes precedence.
  core.String portName;

  /// Specifies the type of proxy header to append before sending data to the
  /// backend, either NONE or PROXY_V1. The default is NONE.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String proxyHeader;

  /// The request path of the HTTPS health check request. The default value is
  /// /.
  core.String requestPath;

  HTTPSHealthCheck();

  HTTPSHealthCheck.fromJson(core.Map _json) {
    if (_json.containsKey("host")) {
      host = _json["host"];
    }
    if (_json.containsKey("port")) {
      port = _json["port"];
    }
    if (_json.containsKey("portName")) {
      portName = _json["portName"];
    }
    if (_json.containsKey("proxyHeader")) {
      proxyHeader = _json["proxyHeader"];
    }
    if (_json.containsKey("requestPath")) {
      requestPath = _json["requestPath"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (host != null) {
      _json["host"] = host;
    }
    if (port != null) {
      _json["port"] = port;
    }
    if (portName != null) {
      _json["portName"] = portName;
    }
    if (proxyHeader != null) {
      _json["proxyHeader"] = proxyHeader;
    }
    if (requestPath != null) {
      _json["requestPath"] = requestPath;
    }
    return _json;
  }
}

/// An HealthCheck resource. This resource defines a template for how individual
/// virtual machines should be checked for health, via one of the supported
/// protocols.
class HealthCheck {
  /// How often (in seconds) to send a health check. The default value is 5
  /// seconds.
  core.int checkIntervalSec;

  /// [Output Only] Creation timestamp in 3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// A so-far unhealthy instance will be marked healthy after this many
  /// consecutive successes. The default value is 2.
  core.int healthyThreshold;
  HTTPHealthCheck httpHealthCheck;
  HTTPSHealthCheck httpsHealthCheck;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// Type of the resource.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
  /// be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;
  SSLHealthCheck sslHealthCheck;
  TCPHealthCheck tcpHealthCheck;

  /// How long (in seconds) to wait before claiming failure. The default value
  /// is 5 seconds. It is invalid for timeoutSec to have greater value than
  /// checkIntervalSec.
  core.int timeoutSec;

  /// Specifies the type of the healthCheck, either TCP, SSL, HTTP or HTTPS. If
  /// not specified, the default is TCP. Exactly one of the protocol-specific
  /// health check field must be specified, which must match type field.
  /// Possible string values are:
  /// - "HTTP"
  /// - "HTTPS"
  /// - "INVALID"
  /// - "SSL"
  /// - "TCP"
  core.String type;

  /// A so-far healthy instance will be marked unhealthy after this many
  /// consecutive failures. The default value is 2.
  core.int unhealthyThreshold;

  HealthCheck();

  HealthCheck.fromJson(core.Map _json) {
    if (_json.containsKey("checkIntervalSec")) {
      checkIntervalSec = _json["checkIntervalSec"];
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("healthyThreshold")) {
      healthyThreshold = _json["healthyThreshold"];
    }
    if (_json.containsKey("httpHealthCheck")) {
      httpHealthCheck = new HTTPHealthCheck.fromJson(_json["httpHealthCheck"]);
    }
    if (_json.containsKey("httpsHealthCheck")) {
      httpsHealthCheck =
          new HTTPSHealthCheck.fromJson(_json["httpsHealthCheck"]);
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("sslHealthCheck")) {
      sslHealthCheck = new SSLHealthCheck.fromJson(_json["sslHealthCheck"]);
    }
    if (_json.containsKey("tcpHealthCheck")) {
      tcpHealthCheck = new TCPHealthCheck.fromJson(_json["tcpHealthCheck"]);
    }
    if (_json.containsKey("timeoutSec")) {
      timeoutSec = _json["timeoutSec"];
    }
    if (_json.containsKey("type")) {
      type = _json["type"];
    }
    if (_json.containsKey("unhealthyThreshold")) {
      unhealthyThreshold = _json["unhealthyThreshold"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (checkIntervalSec != null) {
      _json["checkIntervalSec"] = checkIntervalSec;
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (healthyThreshold != null) {
      _json["healthyThreshold"] = healthyThreshold;
    }
    if (httpHealthCheck != null) {
      _json["httpHealthCheck"] = (httpHealthCheck).toJson();
    }
    if (httpsHealthCheck != null) {
      _json["httpsHealthCheck"] = (httpsHealthCheck).toJson();
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (sslHealthCheck != null) {
      _json["sslHealthCheck"] = (sslHealthCheck).toJson();
    }
    if (tcpHealthCheck != null) {
      _json["tcpHealthCheck"] = (tcpHealthCheck).toJson();
    }
    if (timeoutSec != null) {
      _json["timeoutSec"] = timeoutSec;
    }
    if (type != null) {
      _json["type"] = type;
    }
    if (unhealthyThreshold != null) {
      _json["unhealthyThreshold"] = unhealthyThreshold;
    }
    return _json;
  }
}

class HealthCheckListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  HealthCheckListWarningData();

  HealthCheckListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class HealthCheckListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<HealthCheckListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  HealthCheckListWarning();

  HealthCheckListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new HealthCheckListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of HealthCheck resources.
class HealthCheckList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of HealthCheck resources.
  core.List<HealthCheck> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  HealthCheckListWarning warning;

  HealthCheckList();

  HealthCheckList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = _json["items"]
          .map((value) => new HealthCheck.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new HealthCheckListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// A full or valid partial URL to a health check. For example, the following
/// are valid URLs:
/// -
/// https://www.googleapis.com/compute/beta/projects/project-id/global/httpHealthChecks/health-check
/// - projects/project-id/global/httpHealthChecks/health-check
/// - global/httpHealthChecks/health-check
class HealthCheckReference {
  core.String healthCheck;

  HealthCheckReference();

  HealthCheckReference.fromJson(core.Map _json) {
    if (_json.containsKey("healthCheck")) {
      healthCheck = _json["healthCheck"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (healthCheck != null) {
      _json["healthCheck"] = healthCheck;
    }
    return _json;
  }
}

class HealthStatus {
  /// Health state of the instance.
  /// Possible string values are:
  /// - "HEALTHY"
  /// - "UNHEALTHY"
  core.String healthState;

  /// URL of the instance resource.
  core.String instance;

  /// The IP address represented by this resource.
  core.String ipAddress;

  /// The port on the instance.
  core.int port;

  HealthStatus();

  HealthStatus.fromJson(core.Map _json) {
    if (_json.containsKey("healthState")) {
      healthState = _json["healthState"];
    }
    if (_json.containsKey("instance")) {
      instance = _json["instance"];
    }
    if (_json.containsKey("ipAddress")) {
      ipAddress = _json["ipAddress"];
    }
    if (_json.containsKey("port")) {
      port = _json["port"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (healthState != null) {
      _json["healthState"] = healthState;
    }
    if (instance != null) {
      _json["instance"] = instance;
    }
    if (ipAddress != null) {
      _json["ipAddress"] = ipAddress;
    }
    if (port != null) {
      _json["port"] = port;
    }
    return _json;
  }
}

/// UrlMaps A host-matching rule for a URL. If matched, will use the named
/// PathMatcher to select the BackendService.
class HostRule {
  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// The list of host patterns to match. They must be valid hostnames, except *
  /// will match any string of ([a-z0-9-.]*). In that case, * must be the first
  /// character and must be followed in the pattern by either - or ..
  core.List<core.String> hosts;

  /// The name of the PathMatcher to use to match the path portion of the URL if
  /// the hostRule matches the URL's host portion.
  core.String pathMatcher;

  HostRule();

  HostRule.fromJson(core.Map _json) {
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("hosts")) {
      hosts = _json["hosts"];
    }
    if (_json.containsKey("pathMatcher")) {
      pathMatcher = _json["pathMatcher"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (description != null) {
      _json["description"] = description;
    }
    if (hosts != null) {
      _json["hosts"] = hosts;
    }
    if (pathMatcher != null) {
      _json["pathMatcher"] = pathMatcher;
    }
    return _json;
  }
}

/// An HttpHealthCheck resource. This resource defines a template for how
/// individual instances should be checked for health, via HTTP.
class HttpHealthCheck {
  /// How often (in seconds) to send a health check. The default value is 5
  /// seconds.
  core.int checkIntervalSec;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// A so-far unhealthy instance will be marked healthy after this many
  /// consecutive successes. The default value is 2.
  core.int healthyThreshold;

  /// The value of the host header in the HTTP health check request. If left
  /// empty (default value), the public IP on behalf of which this health check
  /// is performed will be used.
  core.String host;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#httpHealthCheck for
  /// HTTP health checks.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
  /// be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// The TCP port number for the HTTP health check request. The default value
  /// is 80.
  core.int port;

  /// The request path of the HTTP health check request. The default value is /.
  core.String requestPath;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// How long (in seconds) to wait before claiming failure. The default value
  /// is 5 seconds. It is invalid for timeoutSec to have greater value than
  /// checkIntervalSec.
  core.int timeoutSec;

  /// A so-far healthy instance will be marked unhealthy after this many
  /// consecutive failures. The default value is 2.
  core.int unhealthyThreshold;

  HttpHealthCheck();

  HttpHealthCheck.fromJson(core.Map _json) {
    if (_json.containsKey("checkIntervalSec")) {
      checkIntervalSec = _json["checkIntervalSec"];
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("healthyThreshold")) {
      healthyThreshold = _json["healthyThreshold"];
    }
    if (_json.containsKey("host")) {
      host = _json["host"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("port")) {
      port = _json["port"];
    }
    if (_json.containsKey("requestPath")) {
      requestPath = _json["requestPath"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("timeoutSec")) {
      timeoutSec = _json["timeoutSec"];
    }
    if (_json.containsKey("unhealthyThreshold")) {
      unhealthyThreshold = _json["unhealthyThreshold"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (checkIntervalSec != null) {
      _json["checkIntervalSec"] = checkIntervalSec;
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (healthyThreshold != null) {
      _json["healthyThreshold"] = healthyThreshold;
    }
    if (host != null) {
      _json["host"] = host;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (port != null) {
      _json["port"] = port;
    }
    if (requestPath != null) {
      _json["requestPath"] = requestPath;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (timeoutSec != null) {
      _json["timeoutSec"] = timeoutSec;
    }
    if (unhealthyThreshold != null) {
      _json["unhealthyThreshold"] = unhealthyThreshold;
    }
    return _json;
  }
}

class HttpHealthCheckListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  HttpHealthCheckListWarningData();

  HttpHealthCheckListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class HttpHealthCheckListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<HttpHealthCheckListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  HttpHealthCheckListWarning();

  HttpHealthCheckListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new HttpHealthCheckListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of HttpHealthCheck resources.
class HttpHealthCheckList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of HttpHealthCheck resources.
  core.List<HttpHealthCheck> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  HttpHealthCheckListWarning warning;

  HttpHealthCheckList();

  HttpHealthCheckList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = _json["items"]
          .map((value) => new HttpHealthCheck.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new HttpHealthCheckListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// An HttpsHealthCheck resource. This resource defines a template for how
/// individual instances should be checked for health, via HTTPS.
class HttpsHealthCheck {
  /// How often (in seconds) to send a health check. The default value is 5
  /// seconds.
  core.int checkIntervalSec;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// A so-far unhealthy instance will be marked healthy after this many
  /// consecutive successes. The default value is 2.
  core.int healthyThreshold;

  /// The value of the host header in the HTTPS health check request. If left
  /// empty (default value), the public IP on behalf of which this health check
  /// is performed will be used.
  core.String host;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// Type of the resource.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
  /// be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// The TCP port number for the HTTPS health check request. The default value
  /// is 443.
  core.int port;

  /// The request path of the HTTPS health check request. The default value is
  /// "/".
  core.String requestPath;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// How long (in seconds) to wait before claiming failure. The default value
  /// is 5 seconds. It is invalid for timeoutSec to have a greater value than
  /// checkIntervalSec.
  core.int timeoutSec;

  /// A so-far healthy instance will be marked unhealthy after this many
  /// consecutive failures. The default value is 2.
  core.int unhealthyThreshold;

  HttpsHealthCheck();

  HttpsHealthCheck.fromJson(core.Map _json) {
    if (_json.containsKey("checkIntervalSec")) {
      checkIntervalSec = _json["checkIntervalSec"];
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("healthyThreshold")) {
      healthyThreshold = _json["healthyThreshold"];
    }
    if (_json.containsKey("host")) {
      host = _json["host"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("port")) {
      port = _json["port"];
    }
    if (_json.containsKey("requestPath")) {
      requestPath = _json["requestPath"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("timeoutSec")) {
      timeoutSec = _json["timeoutSec"];
    }
    if (_json.containsKey("unhealthyThreshold")) {
      unhealthyThreshold = _json["unhealthyThreshold"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (checkIntervalSec != null) {
      _json["checkIntervalSec"] = checkIntervalSec;
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (healthyThreshold != null) {
      _json["healthyThreshold"] = healthyThreshold;
    }
    if (host != null) {
      _json["host"] = host;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (port != null) {
      _json["port"] = port;
    }
    if (requestPath != null) {
      _json["requestPath"] = requestPath;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (timeoutSec != null) {
      _json["timeoutSec"] = timeoutSec;
    }
    if (unhealthyThreshold != null) {
      _json["unhealthyThreshold"] = unhealthyThreshold;
    }
    return _json;
  }
}

class HttpsHealthCheckListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  HttpsHealthCheckListWarningData();

  HttpsHealthCheckListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class HttpsHealthCheckListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<HttpsHealthCheckListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  HttpsHealthCheckListWarning();

  HttpsHealthCheckListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new HttpsHealthCheckListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of HttpsHealthCheck resources.
class HttpsHealthCheckList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of HttpsHealthCheck resources.
  core.List<HttpsHealthCheck> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  HttpsHealthCheckListWarning warning;

  HttpsHealthCheckList();

  HttpsHealthCheckList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = _json["items"]
          .map((value) => new HttpsHealthCheck.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new HttpsHealthCheckListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// The parameters of the raw disk image.
class ImageRawDisk {
  /// The format used to encode and transmit the block device, which should be
  /// TAR. This is just a container and transmission format and not a runtime
  /// format. Provided by the client when the disk image is created.
  /// Possible string values are:
  /// - "TAR"
  core.String containerType;

  /// An optional SHA1 checksum of the disk image before unpackaging; provided
  /// by the client when the disk image is created.
  core.String sha1Checksum;

  /// The full Google Cloud Storage URL where the disk image is stored. You must
  /// provide either this property or the sourceDisk property but not both.
  core.String source;

  ImageRawDisk();

  ImageRawDisk.fromJson(core.Map _json) {
    if (_json.containsKey("containerType")) {
      containerType = _json["containerType"];
    }
    if (_json.containsKey("sha1Checksum")) {
      sha1Checksum = _json["sha1Checksum"];
    }
    if (_json.containsKey("source")) {
      source = _json["source"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (containerType != null) {
      _json["containerType"] = containerType;
    }
    if (sha1Checksum != null) {
      _json["sha1Checksum"] = sha1Checksum;
    }
    if (source != null) {
      _json["source"] = source;
    }
    return _json;
  }
}

/// An Image resource. (== resource_for beta.images ==) (== resource_for
/// v1.images ==)
class Image {
  /// Size of the image tar.gz archive stored in Google Cloud Storage (in
  /// bytes).
  core.String archiveSizeBytes;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// The deprecation status associated with this image.
  DeprecationStatus deprecated;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// Size of the image when restored onto a persistent disk (in GB).
  core.String diskSizeGb;

  /// The name of the image family to which this image belongs. You can create
  /// disks by specifying an image family instead of a specific image name. The
  /// image family always returns its latest image that is not deprecated. The
  /// name of the image family must comply with RFC1035.
  core.String family;

  /// A list of features to enable on the guest operating system. Applicable
  /// only for bootable images. Read  Enabling guest operating system features
  /// to see a list of available options.
  core.List<GuestOsFeature> guestOsFeatures;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// Encrypts the image using a customer-supplied encryption key.
  ///
  /// After you encrypt an image with a customer-supplied key, you must provide
  /// the same key if you use the image later (e.g. to create a disk from the
  /// image).
  ///
  /// Customer-supplied encryption keys do not protect access to metadata of the
  /// disk.
  ///
  /// If you do not provide an encryption key when creating the image, then the
  /// disk will be encrypted using an automatically generated key and you do not
  /// need to provide a key to use the image later.
  CustomerEncryptionKey imageEncryptionKey;

  /// [Output Only] Type of the resource. Always compute#image for images.
  core.String kind;

  /// A fingerprint for the labels being applied to this image, which is
  /// essentially a hash of the labels used for optimistic locking. The
  /// fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update labels. You must always provide an
  /// up-to-date fingerprint hash in order to update or change labels.
  ///
  /// To see the latest fingerprint, make a get() request to retrieve an image.
  core.String labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes {
    return convert.BASE64.decode(labelFingerprint);
  }

  void set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.BASE64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  /// Labels to apply to this image. These can be later modified by the
  /// setLabels method.
  core.Map<core.String, core.String> labels;

  /// Any applicable license URI.
  core.List<core.String> licenses;

  /// Name of the resource; provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
  /// be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// The parameters of the raw disk image.
  ImageRawDisk rawDisk;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// URL of the source disk used to create this image. This can be a full or
  /// valid partial URL. You must provide either this property or the
  /// rawDisk.source property but not both to create an image. For example, the
  /// following are valid values:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone/disks/disk
  /// - projects/project/zones/zone/disks/disk
  /// - zones/zone/disks/disk
  core.String sourceDisk;

  /// The customer-supplied encryption key of the source disk. Required if the
  /// source disk is protected by a customer-supplied encryption key.
  CustomerEncryptionKey sourceDiskEncryptionKey;

  /// The ID value of the disk used to create this image. This value may be used
  /// to determine whether the image was taken from the current or a previous
  /// instance of a given disk name.
  core.String sourceDiskId;

  /// URL of the source image used to create this image. This can be a full or
  /// valid partial URL. You must provide exactly one of:
  /// - this property, or
  /// - the rawDisk.source property, or
  /// - the sourceDisk property   in order to create an image.
  core.String sourceImage;

  /// The customer-supplied encryption key of the source image. Required if the
  /// source image is protected by a customer-supplied encryption key.
  CustomerEncryptionKey sourceImageEncryptionKey;

  /// [Output Only] The ID value of the image used to create this image. This
  /// value may be used to determine whether the image was taken from the
  /// current or a previous instance of a given image name.
  core.String sourceImageId;

  /// The type of the image used to create this disk. The default and only value
  /// is RAW
  /// Possible string values are:
  /// - "RAW"
  core.String sourceType;

  /// [Output Only] The status of the image. An image can be used to create
  /// other resources, such as instances, only after the image has been
  /// successfully created and the status is set to READY. Possible values are
  /// FAILED, PENDING, or READY.
  /// Possible string values are:
  /// - "FAILED"
  /// - "PENDING"
  /// - "READY"
  core.String status;

  Image();

  Image.fromJson(core.Map _json) {
    if (_json.containsKey("archiveSizeBytes")) {
      archiveSizeBytes = _json["archiveSizeBytes"];
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("deprecated")) {
      deprecated = new DeprecationStatus.fromJson(_json["deprecated"]);
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("diskSizeGb")) {
      diskSizeGb = _json["diskSizeGb"];
    }
    if (_json.containsKey("family")) {
      family = _json["family"];
    }
    if (_json.containsKey("guestOsFeatures")) {
      guestOsFeatures = _json["guestOsFeatures"]
          .map((value) => new GuestOsFeature.fromJson(value))
          .toList();
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("imageEncryptionKey")) {
      imageEncryptionKey =
          new CustomerEncryptionKey.fromJson(_json["imageEncryptionKey"]);
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("labelFingerprint")) {
      labelFingerprint = _json["labelFingerprint"];
    }
    if (_json.containsKey("labels")) {
      labels = _json["labels"];
    }
    if (_json.containsKey("licenses")) {
      licenses = _json["licenses"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("rawDisk")) {
      rawDisk = new ImageRawDisk.fromJson(_json["rawDisk"]);
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("sourceDisk")) {
      sourceDisk = _json["sourceDisk"];
    }
    if (_json.containsKey("sourceDiskEncryptionKey")) {
      sourceDiskEncryptionKey =
          new CustomerEncryptionKey.fromJson(_json["sourceDiskEncryptionKey"]);
    }
    if (_json.containsKey("sourceDiskId")) {
      sourceDiskId = _json["sourceDiskId"];
    }
    if (_json.containsKey("sourceImage")) {
      sourceImage = _json["sourceImage"];
    }
    if (_json.containsKey("sourceImageEncryptionKey")) {
      sourceImageEncryptionKey =
          new CustomerEncryptionKey.fromJson(_json["sourceImageEncryptionKey"]);
    }
    if (_json.containsKey("sourceImageId")) {
      sourceImageId = _json["sourceImageId"];
    }
    if (_json.containsKey("sourceType")) {
      sourceType = _json["sourceType"];
    }
    if (_json.containsKey("status")) {
      status = _json["status"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (archiveSizeBytes != null) {
      _json["archiveSizeBytes"] = archiveSizeBytes;
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (deprecated != null) {
      _json["deprecated"] = (deprecated).toJson();
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (diskSizeGb != null) {
      _json["diskSizeGb"] = diskSizeGb;
    }
    if (family != null) {
      _json["family"] = family;
    }
    if (guestOsFeatures != null) {
      _json["guestOsFeatures"] =
          guestOsFeatures.map((value) => (value).toJson()).toList();
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (imageEncryptionKey != null) {
      _json["imageEncryptionKey"] = (imageEncryptionKey).toJson();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (labelFingerprint != null) {
      _json["labelFingerprint"] = labelFingerprint;
    }
    if (labels != null) {
      _json["labels"] = labels;
    }
    if (licenses != null) {
      _json["licenses"] = licenses;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (rawDisk != null) {
      _json["rawDisk"] = (rawDisk).toJson();
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (sourceDisk != null) {
      _json["sourceDisk"] = sourceDisk;
    }
    if (sourceDiskEncryptionKey != null) {
      _json["sourceDiskEncryptionKey"] = (sourceDiskEncryptionKey).toJson();
    }
    if (sourceDiskId != null) {
      _json["sourceDiskId"] = sourceDiskId;
    }
    if (sourceImage != null) {
      _json["sourceImage"] = sourceImage;
    }
    if (sourceImageEncryptionKey != null) {
      _json["sourceImageEncryptionKey"] = (sourceImageEncryptionKey).toJson();
    }
    if (sourceImageId != null) {
      _json["sourceImageId"] = sourceImageId;
    }
    if (sourceType != null) {
      _json["sourceType"] = sourceType;
    }
    if (status != null) {
      _json["status"] = status;
    }
    return _json;
  }
}

class ImageListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  ImageListWarningData();

  ImageListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class ImageListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<ImageListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  ImageListWarning();

  ImageListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new ImageListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of images.
class ImageList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Image resources.
  core.List<Image> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  ImageListWarning warning;

  ImageList();

  ImageList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = _json["items"].map((value) => new Image.fromJson(value)).toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new ImageListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// An Instance resource. (== resource_for beta.instances ==) (== resource_for
/// v1.instances ==)
class Instance {
  /// Allows this instance to send and receive packets with non-matching
  /// destination or source IPs. This is required if you plan to use this
  /// instance to forward routes. For more information, see Enabling IP
  /// Forwarding.
  core.bool canIpForward;

  /// [Output Only] The CPU platform used by this instance.
  core.String cpuPlatform;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// Whether the resource should be protected against deletion.
  core.bool deletionProtection;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// Array of disks associated with this instance. Persistent disks must be
  /// created before you can assign them.
  core.List<AttachedDisk> disks;

  /// List of the type and count of accelerator cards attached to the instance.
  core.List<AcceleratorConfig> guestAccelerators;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#instance for instances.
  core.String kind;

  /// A fingerprint for this request, which is essentially a hash of the
  /// metadata's contents and used for optimistic locking. The fingerprint is
  /// initially generated by Compute Engine and changes after every request to
  /// modify or update metadata. You must always provide an up-to-date
  /// fingerprint hash in order to update or change metadata.
  ///
  /// To see the latest fingerprint, make get() request to the instance.
  core.String labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes {
    return convert.BASE64.decode(labelFingerprint);
  }

  void set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.BASE64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  /// Labels to apply to this instance. These can be later modified by the
  /// setLabels method.
  core.Map<core.String, core.String> labels;

  /// Full or partial URL of the machine type resource to use for this instance,
  /// in the format: zones/zone/machineTypes/machine-type. This is provided by
  /// the client when the instance is created. For example, the following is a
  /// valid partial url to a predefined machine type:
  /// zones/us-central1-f/machineTypes/n1-standard-1
  ///
  ///
  /// To create a custom machine type, provide a URL to a machine type in the
  /// following format, where CPUS is 1 or an even number up to 32 (2, 4, 6, ...
  /// 24, etc), and MEMORY is the total memory for this instance. Memory must be
  /// a multiple of 256 MB and must be supplied in MB (e.g. 5 GB of memory is
  /// 5120 MB):
  /// zones/zone/machineTypes/custom-CPUS-MEMORY
  ///
  ///
  /// For example: zones/us-central1-f/machineTypes/custom-4-5120
  ///
  /// For a full list of restrictions, read the Specifications for custom
  /// machine types.
  core.String machineType;

  /// The metadata key/value pairs assigned to this instance. This includes
  /// custom metadata and predefined keys.
  Metadata metadata;

  /// Specifies a minimum CPU platform for the VM instance. Applicable values
  /// are the friendly names of CPU platforms, such as minCpuPlatform: "Intel
  /// Haswell" or minCpuPlatform: "Intel Sandy Bridge".
  core.String minCpuPlatform;

  /// The name of the resource, provided by the client when initially creating
  /// the resource. The resource name must be 1-63 characters long, and comply
  /// with RFC1035. Specifically, the name must be 1-63 characters long and
  /// match the regular expression [a-z]([-a-z0-9]*[a-z0-9])? which means the
  /// first character must be a lowercase letter, and all following characters
  /// must be a dash, lowercase letter, or digit, except the last character,
  /// which cannot be a dash.
  core.String name;

  /// An array of network configurations for this instance. These specify how
  /// interfaces are configured to interact with other network services, such as
  /// connecting to the internet. Multiple interfaces are supported per
  /// instance.
  core.List<NetworkInterface> networkInterfaces;

  /// Sets the scheduling options for this instance.
  Scheduling scheduling;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// A list of service accounts, with their specified scopes, authorized for
  /// this instance. Only one service account per VM instance is supported.
  ///
  /// Service accounts generate access tokens that can be accessed through the
  /// metadata server and used to authenticate applications on the instance. See
  /// Service Accounts for more information.
  core.List<ServiceAccount> serviceAccounts;

  /// [Output Only] Whether a VM has been restricted for start because Compute
  /// Engine has detected suspicious activity.
  core.bool startRestricted;

  /// [Output Only] The status of the instance. One of the following values:
  /// PROVISIONING, STAGING, RUNNING, STOPPING, STOPPED, SUSPENDING, SUSPENDED,
  /// and TERMINATED.
  /// Possible string values are:
  /// - "PROVISIONING"
  /// - "RUNNING"
  /// - "STAGING"
  /// - "STOPPED"
  /// - "STOPPING"
  /// - "SUSPENDED"
  /// - "SUSPENDING"
  /// - "TERMINATED"
  core.String status;

  /// [Output Only] An optional, human-readable explanation of the status.
  core.String statusMessage;

  /// A list of tags to apply to this instance. Tags are used to identify valid
  /// sources or targets for network firewalls and are specified by the client
  /// during instance creation. The tags can be later modified by the setTags
  /// method. Each tag within the list must comply with RFC1035.
  Tags tags;

  /// [Output Only] URL of the zone where the instance resides. You must specify
  /// this field as part of the HTTP request URL. It is not settable as a field
  /// in the request body.
  core.String zone;

  Instance();

  Instance.fromJson(core.Map _json) {
    if (_json.containsKey("canIpForward")) {
      canIpForward = _json["canIpForward"];
    }
    if (_json.containsKey("cpuPlatform")) {
      cpuPlatform = _json["cpuPlatform"];
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("deletionProtection")) {
      deletionProtection = _json["deletionProtection"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("disks")) {
      disks = _json["disks"]
          .map((value) => new AttachedDisk.fromJson(value))
          .toList();
    }
    if (_json.containsKey("guestAccelerators")) {
      guestAccelerators = _json["guestAccelerators"]
          .map((value) => new AcceleratorConfig.fromJson(value))
          .toList();
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("labelFingerprint")) {
      labelFingerprint = _json["labelFingerprint"];
    }
    if (_json.containsKey("labels")) {
      labels = _json["labels"];
    }
    if (_json.containsKey("machineType")) {
      machineType = _json["machineType"];
    }
    if (_json.containsKey("metadata")) {
      metadata = new Metadata.fromJson(_json["metadata"]);
    }
    if (_json.containsKey("minCpuPlatform")) {
      minCpuPlatform = _json["minCpuPlatform"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("networkInterfaces")) {
      networkInterfaces = _json["networkInterfaces"]
          .map((value) => new NetworkInterface.fromJson(value))
          .toList();
    }
    if (_json.containsKey("scheduling")) {
      scheduling = new Scheduling.fromJson(_json["scheduling"]);
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("serviceAccounts")) {
      serviceAccounts = _json["serviceAccounts"]
          .map((value) => new ServiceAccount.fromJson(value))
          .toList();
    }
    if (_json.containsKey("startRestricted")) {
      startRestricted = _json["startRestricted"];
    }
    if (_json.containsKey("status")) {
      status = _json["status"];
    }
    if (_json.containsKey("statusMessage")) {
      statusMessage = _json["statusMessage"];
    }
    if (_json.containsKey("tags")) {
      tags = new Tags.fromJson(_json["tags"]);
    }
    if (_json.containsKey("zone")) {
      zone = _json["zone"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (canIpForward != null) {
      _json["canIpForward"] = canIpForward;
    }
    if (cpuPlatform != null) {
      _json["cpuPlatform"] = cpuPlatform;
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (deletionProtection != null) {
      _json["deletionProtection"] = deletionProtection;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (disks != null) {
      _json["disks"] = disks.map((value) => (value).toJson()).toList();
    }
    if (guestAccelerators != null) {
      _json["guestAccelerators"] =
          guestAccelerators.map((value) => (value).toJson()).toList();
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (labelFingerprint != null) {
      _json["labelFingerprint"] = labelFingerprint;
    }
    if (labels != null) {
      _json["labels"] = labels;
    }
    if (machineType != null) {
      _json["machineType"] = machineType;
    }
    if (metadata != null) {
      _json["metadata"] = (metadata).toJson();
    }
    if (minCpuPlatform != null) {
      _json["minCpuPlatform"] = minCpuPlatform;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (networkInterfaces != null) {
      _json["networkInterfaces"] =
          networkInterfaces.map((value) => (value).toJson()).toList();
    }
    if (scheduling != null) {
      _json["scheduling"] = (scheduling).toJson();
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (serviceAccounts != null) {
      _json["serviceAccounts"] =
          serviceAccounts.map((value) => (value).toJson()).toList();
    }
    if (startRestricted != null) {
      _json["startRestricted"] = startRestricted;
    }
    if (status != null) {
      _json["status"] = status;
    }
    if (statusMessage != null) {
      _json["statusMessage"] = statusMessage;
    }
    if (tags != null) {
      _json["tags"] = (tags).toJson();
    }
    if (zone != null) {
      _json["zone"] = zone;
    }
    return _json;
  }
}

class InstanceAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InstanceAggregatedListWarningData();

  InstanceAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class InstanceAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InstanceAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InstanceAggregatedListWarning();

  InstanceAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new InstanceAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class InstanceAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of InstancesScopedList resources.
  core.Map<core.String, InstancesScopedList> items;

  /// [Output Only] Type of resource. Always compute#instanceAggregatedList for
  /// aggregated lists of Instance resources.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  InstanceAggregatedListWarning warning;

  InstanceAggregatedList();

  InstanceAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons
          .mapMap<core.Map<core.String, core.Object>, InstancesScopedList>(
              _json["items"],
              (core.Map<core.String, core.Object> item) =>
                  new InstancesScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new InstanceAggregatedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = commons
          .mapMap<InstancesScopedList, core.Map<core.String, core.Object>>(
              items, (InstancesScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// InstanceGroups (== resource_for beta.instanceGroups ==) (== resource_for
/// v1.instanceGroups ==) (== resource_for beta.regionInstanceGroups ==) (==
/// resource_for v1.regionInstanceGroups ==)
class InstanceGroup {
  /// [Output Only] The creation timestamp for this instance group in RFC3339
  /// text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] The fingerprint of the named ports. The system uses this
  /// fingerprint to detect conflicts when multiple users change the named ports
  /// concurrently.
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes {
    return convert.BASE64.decode(fingerprint);
  }

  void set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.BASE64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  /// [Output Only] A unique identifier for this instance group, generated by
  /// the server.
  core.String id;

  /// [Output Only] The resource type, which is always compute#instanceGroup for
  /// instance groups.
  core.String kind;

  /// The name of the instance group. The name must be 1-63 characters long, and
  /// comply with RFC1035.
  core.String name;

  /// Assigns a name to a port number. For example: {name: "http", port: 80}
  ///
  /// This allows the system to reference ports by the assigned name instead of
  /// a port number. Named ports can also contain multiple ports. For example:
  /// [{name: "http", port: 80},{name: "http", port: 8080}]
  ///
  /// Named ports apply to all instances in this instance group.
  core.List<NamedPort> namedPorts;

  /// The URL of the network to which all instances in the instance group
  /// belong.
  core.String network;

  /// The URL of the region where the instance group is located (for regional
  /// resources).
  core.String region;

  /// [Output Only] The URL for this instance group. The server generates this
  /// URL.
  core.String selfLink;

  /// [Output Only] The total number of instances in the instance group.
  core.int size;

  /// The URL of the subnetwork to which all instances in the instance group
  /// belong.
  core.String subnetwork;

  /// [Output Only] The URL of the zone where the instance group is located (for
  /// zonal resources).
  core.String zone;

  InstanceGroup();

  InstanceGroup.fromJson(core.Map _json) {
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("fingerprint")) {
      fingerprint = _json["fingerprint"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("namedPorts")) {
      namedPorts = _json["namedPorts"]
          .map((value) => new NamedPort.fromJson(value))
          .toList();
    }
    if (_json.containsKey("network")) {
      network = _json["network"];
    }
    if (_json.containsKey("region")) {
      region = _json["region"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("size")) {
      size = _json["size"];
    }
    if (_json.containsKey("subnetwork")) {
      subnetwork = _json["subnetwork"];
    }
    if (_json.containsKey("zone")) {
      zone = _json["zone"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (fingerprint != null) {
      _json["fingerprint"] = fingerprint;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (namedPorts != null) {
      _json["namedPorts"] =
          namedPorts.map((value) => (value).toJson()).toList();
    }
    if (network != null) {
      _json["network"] = network;
    }
    if (region != null) {
      _json["region"] = region;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (size != null) {
      _json["size"] = size;
    }
    if (subnetwork != null) {
      _json["subnetwork"] = subnetwork;
    }
    if (zone != null) {
      _json["zone"] = zone;
    }
    return _json;
  }
}

class InstanceGroupAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InstanceGroupAggregatedListWarningData();

  InstanceGroupAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class InstanceGroupAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InstanceGroupAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InstanceGroupAggregatedListWarning();

  InstanceGroupAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) =>
              new InstanceGroupAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class InstanceGroupAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of InstanceGroupsScopedList resources.
  core.Map<core.String, InstanceGroupsScopedList> items;

  /// [Output Only] The resource type, which is always
  /// compute#instanceGroupAggregatedList for aggregated lists of instance
  /// groups.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  InstanceGroupAggregatedListWarning warning;

  InstanceGroupAggregatedList();

  InstanceGroupAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons
          .mapMap<core.Map<core.String, core.Object>, InstanceGroupsScopedList>(
              _json["items"],
              (core.Map<core.String, core.Object> item) =>
                  new InstanceGroupsScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning =
          new InstanceGroupAggregatedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = commons
          .mapMap<InstanceGroupsScopedList, core.Map<core.String, core.Object>>(
              items, (InstanceGroupsScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class InstanceGroupListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InstanceGroupListWarningData();

  InstanceGroupListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class InstanceGroupListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InstanceGroupListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InstanceGroupListWarning();

  InstanceGroupListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new InstanceGroupListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// A list of InstanceGroup resources.
class InstanceGroupList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of InstanceGroup resources.
  core.List<InstanceGroup> items;

  /// [Output Only] The resource type, which is always compute#instanceGroupList
  /// for instance group lists.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  InstanceGroupListWarning warning;

  InstanceGroupList();

  InstanceGroupList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = _json["items"]
          .map((value) => new InstanceGroup.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new InstanceGroupListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// An Instance Group Manager resource. (== resource_for
/// beta.instanceGroupManagers ==) (== resource_for v1.instanceGroupManagers ==)
/// (== resource_for beta.regionInstanceGroupManagers ==) (== resource_for
/// v1.regionInstanceGroupManagers ==)
class InstanceGroupManager {
  /// The base instance name to use for instances in this group. The value must
  /// be 1-58 characters long. Instances are named by appending a hyphen and a
  /// random four-character string to the base instance name. The base instance
  /// name must comply with RFC1035.
  core.String baseInstanceName;

  /// [Output Only] The creation timestamp for this managed instance group in
  /// RFC3339 text format.
  core.String creationTimestamp;

  /// [Output Only] The list of instance actions and the number of instances in
  /// this managed instance group that are scheduled for each of those actions.
  InstanceGroupManagerActionsSummary currentActions;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] The fingerprint of the resource data. You can use this
  /// optional field for optimistic locking when you update the resource.
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes {
    return convert.BASE64.decode(fingerprint);
  }

  void set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.BASE64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  /// [Output Only] A unique identifier for this resource type. The server
  /// generates this identifier.
  core.String id;

  /// [Output Only] The URL of the Instance Group resource.
  core.String instanceGroup;

  /// The URL of the instance template that is specified for this managed
  /// instance group. The group uses this template to create all new instances
  /// in the managed instance group.
  core.String instanceTemplate;

  /// [Output Only] The resource type, which is always
  /// compute#instanceGroupManager for managed instance groups.
  core.String kind;

  /// The name of the managed instance group. The name must be 1-63 characters
  /// long, and comply with RFC1035.
  core.String name;

  /// Named ports configured for the Instance Groups complementary to this
  /// Instance Group Manager.
  core.List<NamedPort> namedPorts;

  /// [Output Only] The URL of the region where the managed instance group
  /// resides (for regional resources).
  core.String region;

  /// [Output Only] The URL for this managed instance group. The server defines
  /// this URL.
  core.String selfLink;

  /// The URLs for all TargetPool resources to which instances in the
  /// instanceGroup field are added. The target pools automatically apply to all
  /// of the instances in the managed instance group.
  core.List<core.String> targetPools;

  /// The target number of running instances for this managed instance group.
  /// Deleting or abandoning instances reduces this number. Resizing the group
  /// changes this number.
  core.int targetSize;

  /// [Output Only] The URL of the zone where the managed instance group is
  /// located (for zonal resources).
  core.String zone;

  InstanceGroupManager();

  InstanceGroupManager.fromJson(core.Map _json) {
    if (_json.containsKey("baseInstanceName")) {
      baseInstanceName = _json["baseInstanceName"];
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("currentActions")) {
      currentActions = new InstanceGroupManagerActionsSummary.fromJson(
          _json["currentActions"]);
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("fingerprint")) {
      fingerprint = _json["fingerprint"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("instanceGroup")) {
      instanceGroup = _json["instanceGroup"];
    }
    if (_json.containsKey("instanceTemplate")) {
      instanceTemplate = _json["instanceTemplate"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("namedPorts")) {
      namedPorts = _json["namedPorts"]
          .map((value) => new NamedPort.fromJson(value))
          .toList();
    }
    if (_json.containsKey("region")) {
      region = _json["region"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("targetPools")) {
      targetPools = _json["targetPools"];
    }
    if (_json.containsKey("targetSize")) {
      targetSize = _json["targetSize"];
    }
    if (_json.containsKey("zone")) {
      zone = _json["zone"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (baseInstanceName != null) {
      _json["baseInstanceName"] = baseInstanceName;
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (currentActions != null) {
      _json["currentActions"] = (currentActions).toJson();
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (fingerprint != null) {
      _json["fingerprint"] = fingerprint;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (instanceGroup != null) {
      _json["instanceGroup"] = instanceGroup;
    }
    if (instanceTemplate != null) {
      _json["instanceTemplate"] = instanceTemplate;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (namedPorts != null) {
      _json["namedPorts"] =
          namedPorts.map((value) => (value).toJson()).toList();
    }
    if (region != null) {
      _json["region"] = region;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (targetPools != null) {
      _json["targetPools"] = targetPools;
    }
    if (targetSize != null) {
      _json["targetSize"] = targetSize;
    }
    if (zone != null) {
      _json["zone"] = zone;
    }
    return _json;
  }
}

class InstanceGroupManagerActionsSummary {
  /// [Output Only] The total number of instances in the managed instance group
  /// that are scheduled to be abandoned. Abandoning an instance removes it from
  /// the managed instance group without deleting it.
  core.int abandoning;

  /// [Output Only] The number of instances in the managed instance group that
  /// are scheduled to be created or are currently being created. If the group
  /// fails to create any of these instances, it tries again until it creates
  /// the instance successfully.
  ///
  /// If you have disabled creation retries, this field will not be populated;
  /// instead, the creatingWithoutRetries field will be populated.
  core.int creating;

  /// [Output Only] The number of instances that the managed instance group will
  /// attempt to create. The group attempts to create each instance only once.
  /// If the group fails to create any of these instances, it decreases the
  /// group's targetSize value accordingly.
  core.int creatingWithoutRetries;

  /// [Output Only] The number of instances in the managed instance group that
  /// are scheduled to be deleted or are currently being deleted.
  core.int deleting;

  /// [Output Only] The number of instances in the managed instance group that
  /// are running and have no scheduled actions.
  core.int none;

  /// [Output Only] The number of instances in the managed instance group that
  /// are scheduled to be recreated or are currently being being recreated.
  /// Recreating an instance deletes the existing root persistent disk and
  /// creates a new disk from the image that is defined in the instance
  /// template.
  core.int recreating;

  /// [Output Only] The number of instances in the managed instance group that
  /// are being reconfigured with properties that do not require a restart or a
  /// recreate action. For example, setting or removing target pools for the
  /// instance.
  core.int refreshing;

  /// [Output Only] The number of instances in the managed instance group that
  /// are scheduled to be restarted or are currently being restarted.
  core.int restarting;

  InstanceGroupManagerActionsSummary();

  InstanceGroupManagerActionsSummary.fromJson(core.Map _json) {
    if (_json.containsKey("abandoning")) {
      abandoning = _json["abandoning"];
    }
    if (_json.containsKey("creating")) {
      creating = _json["creating"];
    }
    if (_json.containsKey("creatingWithoutRetries")) {
      creatingWithoutRetries = _json["creatingWithoutRetries"];
    }
    if (_json.containsKey("deleting")) {
      deleting = _json["deleting"];
    }
    if (_json.containsKey("none")) {
      none = _json["none"];
    }
    if (_json.containsKey("recreating")) {
      recreating = _json["recreating"];
    }
    if (_json.containsKey("refreshing")) {
      refreshing = _json["refreshing"];
    }
    if (_json.containsKey("restarting")) {
      restarting = _json["restarting"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (abandoning != null) {
      _json["abandoning"] = abandoning;
    }
    if (creating != null) {
      _json["creating"] = creating;
    }
    if (creatingWithoutRetries != null) {
      _json["creatingWithoutRetries"] = creatingWithoutRetries;
    }
    if (deleting != null) {
      _json["deleting"] = deleting;
    }
    if (none != null) {
      _json["none"] = none;
    }
    if (recreating != null) {
      _json["recreating"] = recreating;
    }
    if (refreshing != null) {
      _json["refreshing"] = refreshing;
    }
    if (restarting != null) {
      _json["restarting"] = restarting;
    }
    return _json;
  }
}

class InstanceGroupManagerAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InstanceGroupManagerAggregatedListWarningData();

  InstanceGroupManagerAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class InstanceGroupManagerAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InstanceGroupManagerAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InstanceGroupManagerAggregatedListWarning();

  InstanceGroupManagerAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) =>
              new InstanceGroupManagerAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class InstanceGroupManagerAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of InstanceGroupManagersScopedList resources.
  core.Map<core.String, InstanceGroupManagersScopedList> items;

  /// [Output Only] The resource type, which is always
  /// compute#instanceGroupManagerAggregatedList for an aggregated list of
  /// managed instance groups.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  InstanceGroupManagerAggregatedListWarning warning;

  InstanceGroupManagerAggregatedList();

  InstanceGroupManagerAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons.mapMap<core.Map<core.String, core.Object>,
              InstanceGroupManagersScopedList>(
          _json["items"],
          (core.Map<core.String, core.Object> item) =>
              new InstanceGroupManagersScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new InstanceGroupManagerAggregatedListWarning.fromJson(
          _json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = commons.mapMap<InstanceGroupManagersScopedList,
              core.Map<core.String, core.Object>>(
          items, (InstanceGroupManagersScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class InstanceGroupManagerListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InstanceGroupManagerListWarningData();

  InstanceGroupManagerListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class InstanceGroupManagerListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InstanceGroupManagerListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InstanceGroupManagerListWarning();

  InstanceGroupManagerListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) =>
              new InstanceGroupManagerListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// [Output Only] A list of managed instance groups.
class InstanceGroupManagerList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of InstanceGroupManager resources.
  core.List<InstanceGroupManager> items;

  /// [Output Only] The resource type, which is always
  /// compute#instanceGroupManagerList for a list of managed instance groups.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  InstanceGroupManagerListWarning warning;

  InstanceGroupManagerList();

  InstanceGroupManagerList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = _json["items"]
          .map((value) => new InstanceGroupManager.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new InstanceGroupManagerListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class InstanceGroupManagersAbandonInstancesRequest {
  /// The URLs of one or more instances to abandon. This can be a full URL or a
  /// partial URL, such as zones/[ZONE]/instances/[INSTANCE_NAME].
  core.List<core.String> instances;

  InstanceGroupManagersAbandonInstancesRequest();

  InstanceGroupManagersAbandonInstancesRequest.fromJson(core.Map _json) {
    if (_json.containsKey("instances")) {
      instances = _json["instances"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (instances != null) {
      _json["instances"] = instances;
    }
    return _json;
  }
}

class InstanceGroupManagersDeleteInstancesRequest {
  /// The URLs of one or more instances to delete. This can be a full URL or a
  /// partial URL, such as zones/[ZONE]/instances/[INSTANCE_NAME].
  core.List<core.String> instances;

  InstanceGroupManagersDeleteInstancesRequest();

  InstanceGroupManagersDeleteInstancesRequest.fromJson(core.Map _json) {
    if (_json.containsKey("instances")) {
      instances = _json["instances"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (instances != null) {
      _json["instances"] = instances;
    }
    return _json;
  }
}

class InstanceGroupManagersListManagedInstancesResponse {
  /// [Output Only] The list of instances in the managed instance group.
  core.List<ManagedInstance> managedInstances;

  InstanceGroupManagersListManagedInstancesResponse();

  InstanceGroupManagersListManagedInstancesResponse.fromJson(core.Map _json) {
    if (_json.containsKey("managedInstances")) {
      managedInstances = _json["managedInstances"]
          .map((value) => new ManagedInstance.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (managedInstances != null) {
      _json["managedInstances"] =
          managedInstances.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

class InstanceGroupManagersRecreateInstancesRequest {
  /// The URLs of one or more instances to recreate. This can be a full URL or a
  /// partial URL, such as zones/[ZONE]/instances/[INSTANCE_NAME].
  core.List<core.String> instances;

  InstanceGroupManagersRecreateInstancesRequest();

  InstanceGroupManagersRecreateInstancesRequest.fromJson(core.Map _json) {
    if (_json.containsKey("instances")) {
      instances = _json["instances"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (instances != null) {
      _json["instances"] = instances;
    }
    return _json;
  }
}

class InstanceGroupManagersScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InstanceGroupManagersScopedListWarningData();

  InstanceGroupManagersScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] The warning that replaces the list of managed instance groups
/// when the list is empty.
class InstanceGroupManagersScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InstanceGroupManagersScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InstanceGroupManagersScopedListWarning();

  InstanceGroupManagersScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) =>
              new InstanceGroupManagersScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class InstanceGroupManagersScopedList {
  /// [Output Only] The list of managed instance groups that are contained in
  /// the specified project and zone.
  core.List<InstanceGroupManager> instanceGroupManagers;

  /// [Output Only] The warning that replaces the list of managed instance
  /// groups when the list is empty.
  InstanceGroupManagersScopedListWarning warning;

  InstanceGroupManagersScopedList();

  InstanceGroupManagersScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("instanceGroupManagers")) {
      instanceGroupManagers = _json["instanceGroupManagers"]
          .map((value) => new InstanceGroupManager.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning =
          new InstanceGroupManagersScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (instanceGroupManagers != null) {
      _json["instanceGroupManagers"] =
          instanceGroupManagers.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class InstanceGroupManagersSetInstanceTemplateRequest {
  /// The URL of the instance template that is specified for this managed
  /// instance group. The group uses this template to create all new instances
  /// in the managed instance group.
  core.String instanceTemplate;

  InstanceGroupManagersSetInstanceTemplateRequest();

  InstanceGroupManagersSetInstanceTemplateRequest.fromJson(core.Map _json) {
    if (_json.containsKey("instanceTemplate")) {
      instanceTemplate = _json["instanceTemplate"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (instanceTemplate != null) {
      _json["instanceTemplate"] = instanceTemplate;
    }
    return _json;
  }
}

class InstanceGroupManagersSetTargetPoolsRequest {
  /// The fingerprint of the target pools information. Use this optional
  /// property to prevent conflicts when multiple users change the target pools
  /// settings concurrently. Obtain the fingerprint with the
  /// instanceGroupManagers.get method. Then, include the fingerprint in your
  /// request to ensure that you do not overwrite changes that were applied from
  /// another concurrent request.
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes {
    return convert.BASE64.decode(fingerprint);
  }

  void set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.BASE64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  /// The list of target pool URLs that instances in this managed instance group
  /// belong to. The managed instance group applies these target pools to all of
  /// the instances in the group. Existing instances and new instances in the
  /// group all receive these target pool settings.
  core.List<core.String> targetPools;

  InstanceGroupManagersSetTargetPoolsRequest();

  InstanceGroupManagersSetTargetPoolsRequest.fromJson(core.Map _json) {
    if (_json.containsKey("fingerprint")) {
      fingerprint = _json["fingerprint"];
    }
    if (_json.containsKey("targetPools")) {
      targetPools = _json["targetPools"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (fingerprint != null) {
      _json["fingerprint"] = fingerprint;
    }
    if (targetPools != null) {
      _json["targetPools"] = targetPools;
    }
    return _json;
  }
}

class InstanceGroupsAddInstancesRequest {
  /// The list of instances to add to the instance group.
  core.List<InstanceReference> instances;

  InstanceGroupsAddInstancesRequest();

  InstanceGroupsAddInstancesRequest.fromJson(core.Map _json) {
    if (_json.containsKey("instances")) {
      instances = _json["instances"]
          .map((value) => new InstanceReference.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (instances != null) {
      _json["instances"] = instances.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

class InstanceGroupsListInstancesWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InstanceGroupsListInstancesWarningData();

  InstanceGroupsListInstancesWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class InstanceGroupsListInstancesWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InstanceGroupsListInstancesWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InstanceGroupsListInstancesWarning();

  InstanceGroupsListInstancesWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) =>
              new InstanceGroupsListInstancesWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class InstanceGroupsListInstances {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of InstanceWithNamedPorts resources.
  core.List<InstanceWithNamedPorts> items;

  /// [Output Only] The resource type, which is always
  /// compute#instanceGroupsListInstances for the list of instances in the
  /// specified instance group.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  InstanceGroupsListInstancesWarning warning;

  InstanceGroupsListInstances();

  InstanceGroupsListInstances.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = _json["items"]
          .map((value) => new InstanceWithNamedPorts.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning =
          new InstanceGroupsListInstancesWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class InstanceGroupsListInstancesRequest {
  /// A filter for the state of the instances in the instance group. Valid
  /// options are ALL or RUNNING. If you do not specify this parameter the list
  /// includes all instances regardless of their state.
  /// Possible string values are:
  /// - "ALL"
  /// - "RUNNING"
  core.String instanceState;

  InstanceGroupsListInstancesRequest();

  InstanceGroupsListInstancesRequest.fromJson(core.Map _json) {
    if (_json.containsKey("instanceState")) {
      instanceState = _json["instanceState"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (instanceState != null) {
      _json["instanceState"] = instanceState;
    }
    return _json;
  }
}

class InstanceGroupsRemoveInstancesRequest {
  /// The list of instances to remove from the instance group.
  core.List<InstanceReference> instances;

  InstanceGroupsRemoveInstancesRequest();

  InstanceGroupsRemoveInstancesRequest.fromJson(core.Map _json) {
    if (_json.containsKey("instances")) {
      instances = _json["instances"]
          .map((value) => new InstanceReference.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (instances != null) {
      _json["instances"] = instances.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

class InstanceGroupsScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InstanceGroupsScopedListWarningData();

  InstanceGroupsScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] An informational warning that replaces the list of instance
/// groups when the list is empty.
class InstanceGroupsScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InstanceGroupsScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InstanceGroupsScopedListWarning();

  InstanceGroupsScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) =>
              new InstanceGroupsScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class InstanceGroupsScopedList {
  /// [Output Only] The list of instance groups that are contained in this
  /// scope.
  core.List<InstanceGroup> instanceGroups;

  /// [Output Only] An informational warning that replaces the list of instance
  /// groups when the list is empty.
  InstanceGroupsScopedListWarning warning;

  InstanceGroupsScopedList();

  InstanceGroupsScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("instanceGroups")) {
      instanceGroups = _json["instanceGroups"]
          .map((value) => new InstanceGroup.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning = new InstanceGroupsScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (instanceGroups != null) {
      _json["instanceGroups"] =
          instanceGroups.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class InstanceGroupsSetNamedPortsRequest {
  /// The fingerprint of the named ports information for this instance group.
  /// Use this optional property to prevent conflicts when multiple users change
  /// the named ports settings concurrently. Obtain the fingerprint with the
  /// instanceGroups.get method. Then, include the fingerprint in your request
  /// to ensure that you do not overwrite changes that were applied from another
  /// concurrent request.
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes {
    return convert.BASE64.decode(fingerprint);
  }

  void set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.BASE64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  /// The list of named ports to set for this instance group.
  core.List<NamedPort> namedPorts;

  InstanceGroupsSetNamedPortsRequest();

  InstanceGroupsSetNamedPortsRequest.fromJson(core.Map _json) {
    if (_json.containsKey("fingerprint")) {
      fingerprint = _json["fingerprint"];
    }
    if (_json.containsKey("namedPorts")) {
      namedPorts = _json["namedPorts"]
          .map((value) => new NamedPort.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (fingerprint != null) {
      _json["fingerprint"] = fingerprint;
    }
    if (namedPorts != null) {
      _json["namedPorts"] =
          namedPorts.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

class InstanceListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InstanceListWarningData();

  InstanceListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class InstanceListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InstanceListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InstanceListWarning();

  InstanceListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new InstanceListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of instances.
class InstanceList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Instance resources.
  core.List<Instance> items;

  /// [Output Only] Type of resource. Always compute#instanceList for lists of
  /// Instance resources.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  InstanceListWarning warning;

  InstanceList();

  InstanceList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items =
          _json["items"].map((value) => new Instance.fromJson(value)).toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new InstanceListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class InstanceListReferrersWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InstanceListReferrersWarningData();

  InstanceListReferrersWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class InstanceListReferrersWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InstanceListReferrersWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InstanceListReferrersWarning();

  InstanceListReferrersWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new InstanceListReferrersWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of instance referrers.
class InstanceListReferrers {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Reference resources.
  core.List<Reference> items;

  /// [Output Only] Type of resource. Always compute#instanceListReferrers for
  /// lists of Instance referrers.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  InstanceListReferrersWarning warning;

  InstanceListReferrers();

  InstanceListReferrers.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items =
          _json["items"].map((value) => new Reference.fromJson(value)).toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new InstanceListReferrersWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class InstanceMoveRequest {
  /// The URL of the destination zone to move the instance. This can be a full
  /// or partial URL. For example, the following are all valid URLs to a zone:
  /// - https://www.googleapis.com/compute/v1/projects/project/zones/zone
  /// - projects/project/zones/zone
  /// - zones/zone
  core.String destinationZone;

  /// The URL of the target instance to move. This can be a full or partial URL.
  /// For example, the following are all valid URLs to an instance:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone/instances/instance
  /// - projects/project/zones/zone/instances/instance
  /// - zones/zone/instances/instance
  core.String targetInstance;

  InstanceMoveRequest();

  InstanceMoveRequest.fromJson(core.Map _json) {
    if (_json.containsKey("destinationZone")) {
      destinationZone = _json["destinationZone"];
    }
    if (_json.containsKey("targetInstance")) {
      targetInstance = _json["targetInstance"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (destinationZone != null) {
      _json["destinationZone"] = destinationZone;
    }
    if (targetInstance != null) {
      _json["targetInstance"] = targetInstance;
    }
    return _json;
  }
}

class InstanceProperties {
  /// Enables instances created based on this template to send packets with
  /// source IP addresses other than their own and receive packets with
  /// destination IP addresses other than their own. If these instances will be
  /// used as an IP gateway or it will be set as the next-hop in a Route
  /// resource, specify true. If unsure, leave this set to false. See the Enable
  /// IP forwarding documentation for more information.
  core.bool canIpForward;

  /// An optional text description for the instances that are created from this
  /// instance template.
  core.String description;

  /// An array of disks that are associated with the instances that are created
  /// from this template.
  core.List<AttachedDisk> disks;

  /// A list of guest accelerator cards' type and count to use for instances
  /// created from the instance template.
  core.List<AcceleratorConfig> guestAccelerators;

  /// Labels to apply to instances that are created from this template.
  core.Map<core.String, core.String> labels;

  /// The machine type to use for instances that are created from this template.
  core.String machineType;

  /// The metadata key/value pairs to assign to instances that are created from
  /// this template. These pairs can consist of custom metadata or predefined
  /// keys. See Project and instance metadata for more information.
  Metadata metadata;

  /// Minimum cpu/platform to be used by this instance. The instance may be
  /// scheduled on the specified or newer cpu/platform. Applicable values are
  /// the friendly names of CPU platforms, such as minCpuPlatform: "Intel
  /// Haswell" or minCpuPlatform: "Intel Sandy Bridge". For more information,
  /// read Specifying a Minimum CPU Platform.
  core.String minCpuPlatform;

  /// An array of network access configurations for this interface.
  core.List<NetworkInterface> networkInterfaces;

  /// Specifies the scheduling options for the instances that are created from
  /// this template.
  Scheduling scheduling;

  /// A list of service accounts with specified scopes. Access tokens for these
  /// service accounts are available to the instances that are created from this
  /// template. Use metadata queries to obtain the access tokens for these
  /// instances.
  core.List<ServiceAccount> serviceAccounts;

  /// A list of tags to apply to the instances that are created from this
  /// template. The tags identify valid sources or targets for network
  /// firewalls. The setTags method can modify this list of tags. Each tag
  /// within the list must comply with RFC1035.
  Tags tags;

  InstanceProperties();

  InstanceProperties.fromJson(core.Map _json) {
    if (_json.containsKey("canIpForward")) {
      canIpForward = _json["canIpForward"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("disks")) {
      disks = _json["disks"]
          .map((value) => new AttachedDisk.fromJson(value))
          .toList();
    }
    if (_json.containsKey("guestAccelerators")) {
      guestAccelerators = _json["guestAccelerators"]
          .map((value) => new AcceleratorConfig.fromJson(value))
          .toList();
    }
    if (_json.containsKey("labels")) {
      labels = _json["labels"];
    }
    if (_json.containsKey("machineType")) {
      machineType = _json["machineType"];
    }
    if (_json.containsKey("metadata")) {
      metadata = new Metadata.fromJson(_json["metadata"]);
    }
    if (_json.containsKey("minCpuPlatform")) {
      minCpuPlatform = _json["minCpuPlatform"];
    }
    if (_json.containsKey("networkInterfaces")) {
      networkInterfaces = _json["networkInterfaces"]
          .map((value) => new NetworkInterface.fromJson(value))
          .toList();
    }
    if (_json.containsKey("scheduling")) {
      scheduling = new Scheduling.fromJson(_json["scheduling"]);
    }
    if (_json.containsKey("serviceAccounts")) {
      serviceAccounts = _json["serviceAccounts"]
          .map((value) => new ServiceAccount.fromJson(value))
          .toList();
    }
    if (_json.containsKey("tags")) {
      tags = new Tags.fromJson(_json["tags"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (canIpForward != null) {
      _json["canIpForward"] = canIpForward;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (disks != null) {
      _json["disks"] = disks.map((value) => (value).toJson()).toList();
    }
    if (guestAccelerators != null) {
      _json["guestAccelerators"] =
          guestAccelerators.map((value) => (value).toJson()).toList();
    }
    if (labels != null) {
      _json["labels"] = labels;
    }
    if (machineType != null) {
      _json["machineType"] = machineType;
    }
    if (metadata != null) {
      _json["metadata"] = (metadata).toJson();
    }
    if (minCpuPlatform != null) {
      _json["minCpuPlatform"] = minCpuPlatform;
    }
    if (networkInterfaces != null) {
      _json["networkInterfaces"] =
          networkInterfaces.map((value) => (value).toJson()).toList();
    }
    if (scheduling != null) {
      _json["scheduling"] = (scheduling).toJson();
    }
    if (serviceAccounts != null) {
      _json["serviceAccounts"] =
          serviceAccounts.map((value) => (value).toJson()).toList();
    }
    if (tags != null) {
      _json["tags"] = (tags).toJson();
    }
    return _json;
  }
}

class InstanceReference {
  /// The URL for a specific instance.
  core.String instance;

  InstanceReference();

  InstanceReference.fromJson(core.Map _json) {
    if (_json.containsKey("instance")) {
      instance = _json["instance"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (instance != null) {
      _json["instance"] = instance;
    }
    return _json;
  }
}

/// An Instance Template resource. (== resource_for beta.instanceTemplates ==)
/// (== resource_for v1.instanceTemplates ==)
class InstanceTemplate {
  /// [Output Only] The creation timestamp for this instance template in RFC3339
  /// text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] A unique identifier for this instance template. The server
  /// defines this identifier.
  core.String id;

  /// [Output Only] The resource type, which is always compute#instanceTemplate
  /// for instance templates.
  core.String kind;

  /// Name of the resource; provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
  /// be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// The instance properties for this instance template.
  InstanceProperties properties;

  /// [Output Only] The URL for this instance template. The server defines this
  /// URL.
  core.String selfLink;

  InstanceTemplate();

  InstanceTemplate.fromJson(core.Map _json) {
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("properties")) {
      properties = new InstanceProperties.fromJson(_json["properties"]);
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (properties != null) {
      _json["properties"] = (properties).toJson();
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    return _json;
  }
}

class InstanceTemplateListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InstanceTemplateListWarningData();

  InstanceTemplateListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class InstanceTemplateListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InstanceTemplateListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InstanceTemplateListWarning();

  InstanceTemplateListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new InstanceTemplateListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// A list of instance templates.
class InstanceTemplateList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of InstanceTemplate resources.
  core.List<InstanceTemplate> items;

  /// [Output Only] The resource type, which is always
  /// compute#instanceTemplatesListResponse for instance template lists.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  InstanceTemplateListWarning warning;

  InstanceTemplateList();

  InstanceTemplateList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = _json["items"]
          .map((value) => new InstanceTemplate.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new InstanceTemplateListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class InstanceWithNamedPorts {
  /// [Output Only] The URL of the instance.
  core.String instance;

  /// [Output Only] The named ports that belong to this instance group.
  core.List<NamedPort> namedPorts;

  /// [Output Only] The status of the instance.
  /// Possible string values are:
  /// - "PROVISIONING"
  /// - "RUNNING"
  /// - "STAGING"
  /// - "STOPPED"
  /// - "STOPPING"
  /// - "SUSPENDED"
  /// - "SUSPENDING"
  /// - "TERMINATED"
  core.String status;

  InstanceWithNamedPorts();

  InstanceWithNamedPorts.fromJson(core.Map _json) {
    if (_json.containsKey("instance")) {
      instance = _json["instance"];
    }
    if (_json.containsKey("namedPorts")) {
      namedPorts = _json["namedPorts"]
          .map((value) => new NamedPort.fromJson(value))
          .toList();
    }
    if (_json.containsKey("status")) {
      status = _json["status"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (instance != null) {
      _json["instance"] = instance;
    }
    if (namedPorts != null) {
      _json["namedPorts"] =
          namedPorts.map((value) => (value).toJson()).toList();
    }
    if (status != null) {
      _json["status"] = status;
    }
    return _json;
  }
}

class InstancesScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InstancesScopedListWarningData();

  InstancesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning which replaces the list of instances
/// when the list is empty.
class InstancesScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InstancesScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InstancesScopedListWarning();

  InstancesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new InstancesScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class InstancesScopedList {
  /// [Output Only] List of instances contained in this scope.
  core.List<Instance> instances;

  /// [Output Only] Informational warning which replaces the list of instances
  /// when the list is empty.
  InstancesScopedListWarning warning;

  InstancesScopedList();

  InstancesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("instances")) {
      instances = _json["instances"]
          .map((value) => new Instance.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning = new InstancesScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (instances != null) {
      _json["instances"] = instances.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class InstancesSetLabelsRequest {
  /// Fingerprint of the previous set of labels for this resource, used to
  /// prevent conflicts. Provide the latest fingerprint value when making a
  /// request to add or change labels.
  core.String labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes {
    return convert.BASE64.decode(labelFingerprint);
  }

  void set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.BASE64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  core.Map<core.String, core.String> labels;

  InstancesSetLabelsRequest();

  InstancesSetLabelsRequest.fromJson(core.Map _json) {
    if (_json.containsKey("labelFingerprint")) {
      labelFingerprint = _json["labelFingerprint"];
    }
    if (_json.containsKey("labels")) {
      labels = _json["labels"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (labelFingerprint != null) {
      _json["labelFingerprint"] = labelFingerprint;
    }
    if (labels != null) {
      _json["labels"] = labels;
    }
    return _json;
  }
}

class InstancesSetMachineResourcesRequest {
  /// List of the type and count of accelerator cards attached to the instance.
  core.List<AcceleratorConfig> guestAccelerators;

  InstancesSetMachineResourcesRequest();

  InstancesSetMachineResourcesRequest.fromJson(core.Map _json) {
    if (_json.containsKey("guestAccelerators")) {
      guestAccelerators = _json["guestAccelerators"]
          .map((value) => new AcceleratorConfig.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (guestAccelerators != null) {
      _json["guestAccelerators"] =
          guestAccelerators.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

class InstancesSetMachineTypeRequest {
  /// Full or partial URL of the machine type resource. See Machine Types for a
  /// full list of machine types. For example:
  /// zones/us-central1-f/machineTypes/n1-standard-1
  core.String machineType;

  InstancesSetMachineTypeRequest();

  InstancesSetMachineTypeRequest.fromJson(core.Map _json) {
    if (_json.containsKey("machineType")) {
      machineType = _json["machineType"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (machineType != null) {
      _json["machineType"] = machineType;
    }
    return _json;
  }
}

class InstancesSetMinCpuPlatformRequest {
  /// Minimum cpu/platform this instance should be started at.
  core.String minCpuPlatform;

  InstancesSetMinCpuPlatformRequest();

  InstancesSetMinCpuPlatformRequest.fromJson(core.Map _json) {
    if (_json.containsKey("minCpuPlatform")) {
      minCpuPlatform = _json["minCpuPlatform"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (minCpuPlatform != null) {
      _json["minCpuPlatform"] = minCpuPlatform;
    }
    return _json;
  }
}

class InstancesSetServiceAccountRequest {
  /// Email address of the service account.
  core.String email;

  /// The list of scopes to be made available for this service account.
  core.List<core.String> scopes;

  InstancesSetServiceAccountRequest();

  InstancesSetServiceAccountRequest.fromJson(core.Map _json) {
    if (_json.containsKey("email")) {
      email = _json["email"];
    }
    if (_json.containsKey("scopes")) {
      scopes = _json["scopes"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (email != null) {
      _json["email"] = email;
    }
    if (scopes != null) {
      _json["scopes"] = scopes;
    }
    return _json;
  }
}

class InstancesStartWithEncryptionKeyRequest {
  /// Array of disks associated with this instance that are protected with a
  /// customer-supplied encryption key.
  ///
  /// In order to start the instance, the disk url and its corresponding key
  /// must be provided.
  ///
  /// If the disk is not protected with a customer-supplied encryption key it
  /// should not be specified.
  core.List<CustomerEncryptionKeyProtectedDisk> disks;

  InstancesStartWithEncryptionKeyRequest();

  InstancesStartWithEncryptionKeyRequest.fromJson(core.Map _json) {
    if (_json.containsKey("disks")) {
      disks = _json["disks"]
          .map(
              (value) => new CustomerEncryptionKeyProtectedDisk.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (disks != null) {
      _json["disks"] = disks.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

/// Represents an Interconnects resource. The Interconnects resource is a
/// dedicated connection between Google's network and your on-premises network.
/// For more information, see the  Dedicated overview page. (== resource_for
/// v1.interconnects ==) (== resource_for beta.interconnects ==)
class Interconnect {
  /// Administrative status of the interconnect. When this is set to true, the
  /// Interconnect is functional and can carry traffic. When set to false, no
  /// packets can be carried over the interconnect and no BGP routes are
  /// exchanged over it. By default, the status is set to true.
  core.bool adminEnabled;

  /// [Output Only] List of CircuitInfo objects, that describe the individual
  /// circuits in this LAG.
  core.List<InterconnectCircuitInfo> circuitInfos;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// Customer name, to put in the Letter of Authorization as the party
  /// authorized to request a crossconnect.
  core.String customerName;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] List of outages expected for this Interconnect.
  core.List<InterconnectOutageNotification> expectedOutages;

  /// [Output Only] IP address configured on the Google side of the Interconnect
  /// link. This can be used only for ping tests.
  core.String googleIpAddress;

  /// [Output Only] Google reference ID; to be used when raising support tickets
  /// with Google or otherwise to debug backend connectivity issues.
  core.String googleReferenceId;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] A list of the URLs of all InterconnectAttachments configured
  /// to use this Interconnect.
  core.List<core.String> interconnectAttachments;

  /// Type of interconnect. Note that "IT_PRIVATE" has been deprecated in favor
  /// of "DEDICATED"
  /// Possible string values are:
  /// - "DEDICATED"
  /// - "IT_PRIVATE"
  core.String interconnectType;

  /// [Output Only] Type of the resource. Always compute#interconnect for
  /// interconnects.
  core.String kind;

  /// Type of link requested. This field indicates speed of each of the links in
  /// the bundle, not the entire bundle. Only 10G per link is allowed for a
  /// dedicated interconnect. Options: Ethernet_10G_LR
  /// Possible string values are:
  /// - "LINK_TYPE_ETHERNET_10G_LR"
  core.String linkType;

  /// URL of the InterconnectLocation object that represents where this
  /// connection is to be provisioned.
  core.String location;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
  /// be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// Email address to contact the customer NOC for operations and maintenance
  /// notifications regarding this Interconnect. If specified, this will be used
  /// for notifications in addition to all other forms described, such as
  /// Stackdriver logs alerting and Cloud Notifications.
  core.String nocContactEmail;

  /// [Output Only] The current status of whether or not this Interconnect is
  /// functional.
  /// Possible string values are:
  /// - "OS_ACTIVE"
  /// - "OS_UNPROVISIONED"
  core.String operationalStatus;

  /// [Output Only] IP address configured on the customer side of the
  /// Interconnect link. The customer should configure this IP address during
  /// turnup when prompted by Google NOC. This can be used only for ping tests.
  core.String peerIpAddress;

  /// [Output Only] Number of links actually provisioned in this interconnect.
  core.int provisionedLinkCount;

  /// Target number of physical links in the link bundle, as requested by the
  /// customer.
  core.int requestedLinkCount;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  Interconnect();

  Interconnect.fromJson(core.Map _json) {
    if (_json.containsKey("adminEnabled")) {
      adminEnabled = _json["adminEnabled"];
    }
    if (_json.containsKey("circuitInfos")) {
      circuitInfos = _json["circuitInfos"]
          .map((value) => new InterconnectCircuitInfo.fromJson(value))
          .toList();
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("customerName")) {
      customerName = _json["customerName"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("expectedOutages")) {
      expectedOutages = _json["expectedOutages"]
          .map((value) => new InterconnectOutageNotification.fromJson(value))
          .toList();
    }
    if (_json.containsKey("googleIpAddress")) {
      googleIpAddress = _json["googleIpAddress"];
    }
    if (_json.containsKey("googleReferenceId")) {
      googleReferenceId = _json["googleReferenceId"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("interconnectAttachments")) {
      interconnectAttachments = _json["interconnectAttachments"];
    }
    if (_json.containsKey("interconnectType")) {
      interconnectType = _json["interconnectType"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("linkType")) {
      linkType = _json["linkType"];
    }
    if (_json.containsKey("location")) {
      location = _json["location"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("nocContactEmail")) {
      nocContactEmail = _json["nocContactEmail"];
    }
    if (_json.containsKey("operationalStatus")) {
      operationalStatus = _json["operationalStatus"];
    }
    if (_json.containsKey("peerIpAddress")) {
      peerIpAddress = _json["peerIpAddress"];
    }
    if (_json.containsKey("provisionedLinkCount")) {
      provisionedLinkCount = _json["provisionedLinkCount"];
    }
    if (_json.containsKey("requestedLinkCount")) {
      requestedLinkCount = _json["requestedLinkCount"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (adminEnabled != null) {
      _json["adminEnabled"] = adminEnabled;
    }
    if (circuitInfos != null) {
      _json["circuitInfos"] =
          circuitInfos.map((value) => (value).toJson()).toList();
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (customerName != null) {
      _json["customerName"] = customerName;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (expectedOutages != null) {
      _json["expectedOutages"] =
          expectedOutages.map((value) => (value).toJson()).toList();
    }
    if (googleIpAddress != null) {
      _json["googleIpAddress"] = googleIpAddress;
    }
    if (googleReferenceId != null) {
      _json["googleReferenceId"] = googleReferenceId;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (interconnectAttachments != null) {
      _json["interconnectAttachments"] = interconnectAttachments;
    }
    if (interconnectType != null) {
      _json["interconnectType"] = interconnectType;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (linkType != null) {
      _json["linkType"] = linkType;
    }
    if (location != null) {
      _json["location"] = location;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (nocContactEmail != null) {
      _json["nocContactEmail"] = nocContactEmail;
    }
    if (operationalStatus != null) {
      _json["operationalStatus"] = operationalStatus;
    }
    if (peerIpAddress != null) {
      _json["peerIpAddress"] = peerIpAddress;
    }
    if (provisionedLinkCount != null) {
      _json["provisionedLinkCount"] = provisionedLinkCount;
    }
    if (requestedLinkCount != null) {
      _json["requestedLinkCount"] = requestedLinkCount;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    return _json;
  }
}

/// Represents an InterconnectAttachment (VLAN attachment) resource. For more
/// information, see  Creating VLAN Attachments. (== resource_for
/// beta.interconnectAttachments ==) (== resource_for v1.interconnectAttachments
/// ==)
class InterconnectAttachment {
  /// [Output Only] IPv4 address + prefix length to be configured on Cloud
  /// Router Interface for this interconnect attachment.
  core.String cloudRouterIpAddress;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// [Output Only] IPv4 address + prefix length to be configured on the
  /// customer router subinterface for this interconnect attachment.
  core.String customerRouterIpAddress;

  /// An optional description of this resource.
  core.String description;

  /// [Output Only] Google reference ID, to be used when raising support tickets
  /// with Google or otherwise to debug backend connectivity issues.
  core.String googleReferenceId;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// URL of the underlying Interconnect object that this attachment's traffic
  /// will traverse through.
  core.String interconnect;

  /// [Output Only] Type of the resource. Always compute#interconnectAttachment
  /// for interconnect attachments.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
  /// be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// [Output Only] The current status of whether or not this interconnect
  /// attachment is functional.
  /// Possible string values are:
  /// - "OS_ACTIVE"
  /// - "OS_UNPROVISIONED"
  core.String operationalStatus;

  /// [Output Only] Information specific to an InterconnectAttachment. This
  /// property is populated if the interconnect that this is attached to is of
  /// type DEDICATED.
  InterconnectAttachmentPrivateInfo privateInterconnectInfo;

  /// [Output Only] URL of the region where the regional interconnect attachment
  /// resides. You must specify this field as part of the HTTP request URL. It
  /// is not settable as a field in the request body.
  core.String region;

  /// URL of the cloud router to be used for dynamic routing. This router must
  /// be in the same region as this InterconnectAttachment. The
  /// InterconnectAttachment will automatically connect the Interconnect to the
  /// network & region within which the Cloud Router is configured.
  core.String router;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  InterconnectAttachment();

  InterconnectAttachment.fromJson(core.Map _json) {
    if (_json.containsKey("cloudRouterIpAddress")) {
      cloudRouterIpAddress = _json["cloudRouterIpAddress"];
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("customerRouterIpAddress")) {
      customerRouterIpAddress = _json["customerRouterIpAddress"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("googleReferenceId")) {
      googleReferenceId = _json["googleReferenceId"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("interconnect")) {
      interconnect = _json["interconnect"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("operationalStatus")) {
      operationalStatus = _json["operationalStatus"];
    }
    if (_json.containsKey("privateInterconnectInfo")) {
      privateInterconnectInfo = new InterconnectAttachmentPrivateInfo.fromJson(
          _json["privateInterconnectInfo"]);
    }
    if (_json.containsKey("region")) {
      region = _json["region"];
    }
    if (_json.containsKey("router")) {
      router = _json["router"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (cloudRouterIpAddress != null) {
      _json["cloudRouterIpAddress"] = cloudRouterIpAddress;
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (customerRouterIpAddress != null) {
      _json["customerRouterIpAddress"] = customerRouterIpAddress;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (googleReferenceId != null) {
      _json["googleReferenceId"] = googleReferenceId;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (interconnect != null) {
      _json["interconnect"] = interconnect;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (operationalStatus != null) {
      _json["operationalStatus"] = operationalStatus;
    }
    if (privateInterconnectInfo != null) {
      _json["privateInterconnectInfo"] = (privateInterconnectInfo).toJson();
    }
    if (region != null) {
      _json["region"] = region;
    }
    if (router != null) {
      _json["router"] = router;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    return _json;
  }
}

class InterconnectAttachmentAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InterconnectAttachmentAggregatedListWarningData();

  InterconnectAttachmentAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class InterconnectAttachmentAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InterconnectAttachmentAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InterconnectAttachmentAggregatedListWarning();

  InterconnectAttachmentAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) =>
              new InterconnectAttachmentAggregatedListWarningData.fromJson(
                  value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class InterconnectAttachmentAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of InterconnectAttachmentsScopedList resources.
  core.Map<core.String, InterconnectAttachmentsScopedList> items;

  /// [Output Only] Type of resource. Always
  /// compute#interconnectAttachmentAggregatedList for aggregated lists of
  /// interconnect attachments.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  InterconnectAttachmentAggregatedListWarning warning;

  InterconnectAttachmentAggregatedList();

  InterconnectAttachmentAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons.mapMap<core.Map<core.String, core.Object>,
              InterconnectAttachmentsScopedList>(
          _json["items"],
          (core.Map<core.String, core.Object> item) =>
              new InterconnectAttachmentsScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new InterconnectAttachmentAggregatedListWarning.fromJson(
          _json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = commons.mapMap<InterconnectAttachmentsScopedList,
              core.Map<core.String, core.Object>>(
          items, (InterconnectAttachmentsScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class InterconnectAttachmentListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InterconnectAttachmentListWarningData();

  InterconnectAttachmentListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class InterconnectAttachmentListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InterconnectAttachmentListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InterconnectAttachmentListWarning();

  InterconnectAttachmentListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) =>
              new InterconnectAttachmentListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Response to the list request, and contains a list of interconnect
/// attachments.
class InterconnectAttachmentList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of InterconnectAttachment resources.
  core.List<InterconnectAttachment> items;

  /// [Output Only] Type of resource. Always compute#interconnectAttachmentList
  /// for lists of interconnect attachments.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  InterconnectAttachmentListWarning warning;

  InterconnectAttachmentList();

  InterconnectAttachmentList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = _json["items"]
          .map((value) => new InterconnectAttachment.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning =
          new InterconnectAttachmentListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// Information for an interconnect attachment when this belongs to an
/// interconnect of type DEDICATED.
class InterconnectAttachmentPrivateInfo {
  /// [Output Only] 802.1q encapsulation tag to be used for traffic between
  /// Google and the customer, going to and from this network and region.
  core.int tag8021q;

  InterconnectAttachmentPrivateInfo();

  InterconnectAttachmentPrivateInfo.fromJson(core.Map _json) {
    if (_json.containsKey("tag8021q")) {
      tag8021q = _json["tag8021q"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (tag8021q != null) {
      _json["tag8021q"] = tag8021q;
    }
    return _json;
  }
}

class InterconnectAttachmentsScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InterconnectAttachmentsScopedListWarningData();

  InterconnectAttachmentsScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// Informational warning which replaces the list of addresses when the list is
/// empty.
class InterconnectAttachmentsScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InterconnectAttachmentsScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InterconnectAttachmentsScopedListWarning();

  InterconnectAttachmentsScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) =>
              new InterconnectAttachmentsScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class InterconnectAttachmentsScopedList {
  /// List of interconnect attachments contained in this scope.
  core.List<InterconnectAttachment> interconnectAttachments;

  /// Informational warning which replaces the list of addresses when the list
  /// is empty.
  InterconnectAttachmentsScopedListWarning warning;

  InterconnectAttachmentsScopedList();

  InterconnectAttachmentsScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("interconnectAttachments")) {
      interconnectAttachments = _json["interconnectAttachments"]
          .map((value) => new InterconnectAttachment.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning = new InterconnectAttachmentsScopedListWarning.fromJson(
          _json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (interconnectAttachments != null) {
      _json["interconnectAttachments"] =
          interconnectAttachments.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// Describes a single physical circuit between the Customer and Google.
/// CircuitInfo objects are created by Google, so all fields are output only.
/// Next id: 4
class InterconnectCircuitInfo {
  /// Customer-side demarc ID for this circuit.
  core.String customerDemarcId;

  /// Google-assigned unique ID for this circuit. Assigned at circuit turn-up.
  core.String googleCircuitId;

  /// Google-side demarc ID for this circuit. Assigned at circuit turn-up and
  /// provided by Google to the customer in the LOA.
  core.String googleDemarcId;

  InterconnectCircuitInfo();

  InterconnectCircuitInfo.fromJson(core.Map _json) {
    if (_json.containsKey("customerDemarcId")) {
      customerDemarcId = _json["customerDemarcId"];
    }
    if (_json.containsKey("googleCircuitId")) {
      googleCircuitId = _json["googleCircuitId"];
    }
    if (_json.containsKey("googleDemarcId")) {
      googleDemarcId = _json["googleDemarcId"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (customerDemarcId != null) {
      _json["customerDemarcId"] = customerDemarcId;
    }
    if (googleCircuitId != null) {
      _json["googleCircuitId"] = googleCircuitId;
    }
    if (googleDemarcId != null) {
      _json["googleDemarcId"] = googleDemarcId;
    }
    return _json;
  }
}

class InterconnectListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InterconnectListWarningData();

  InterconnectListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class InterconnectListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InterconnectListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InterconnectListWarning();

  InterconnectListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new InterconnectListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Response to the list request, and contains a list of interconnects.
class InterconnectList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Interconnect resources.
  core.List<Interconnect> items;

  /// [Output Only] Type of resource. Always compute#interconnectList for lists
  /// of interconnects.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  InterconnectListWarning warning;

  InterconnectList();

  InterconnectList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = _json["items"]
          .map((value) => new Interconnect.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new InterconnectListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// Represents an InterconnectLocations resource. The InterconnectLocations
/// resource describes the locations where you can connect to Google's networks.
/// For more information, see  Colocation Facilities.
class InterconnectLocation {
  /// [Output Only] The postal address of the Point of Presence, each line in
  /// the address is separated by a newline character.
  core.String address;

  /// [Output Only] Availability zone for this location. Within a metropolitan
  /// area (metro), maintenance will not be simultaneously scheduled in more
  /// than one availability zone. Example: "zone1" or "zone2".
  core.String availabilityZone;

  /// [Output Only] Metropolitan area designator that indicates which city an
  /// interconnect is located. For example: "Chicago, IL", "Amsterdam,
  /// Netherlands".
  core.String city;

  /// [Output Only] Continent for this location.
  /// Possible string values are:
  /// - "AFRICA"
  /// - "ASIA_PAC"
  /// - "C_AFRICA"
  /// - "C_ASIA_PAC"
  /// - "C_EUROPE"
  /// - "C_NORTH_AMERICA"
  /// - "C_SOUTH_AMERICA"
  /// - "EUROPE"
  /// - "NORTH_AMERICA"
  /// - "SOUTH_AMERICA"
  core.String continent;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// [Output Only] An optional description of the resource.
  core.String description;

  /// [Output Only] The name of the provider for this facility (e.g., EQUINIX).
  core.String facilityProvider;

  /// [Output Only] A provider-assigned Identifier for this facility (e.g.,
  /// Ashburn-DC1).
  core.String facilityProviderFacilityId;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#interconnectLocation
  /// for interconnect locations.
  core.String kind;

  /// [Output Only] Name of the resource.
  core.String name;

  /// [Output Only] The peeringdb identifier for this facility (corresponding
  /// with a netfac type in peeringdb).
  core.String peeringdbFacilityId;

  /// [Output Only] A list of InterconnectLocation.RegionInfo objects, that
  /// describe parameters pertaining to the relation between this
  /// InterconnectLocation and various Google Cloud regions.
  core.List<InterconnectLocationRegionInfo> regionInfos;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  InterconnectLocation();

  InterconnectLocation.fromJson(core.Map _json) {
    if (_json.containsKey("address")) {
      address = _json["address"];
    }
    if (_json.containsKey("availabilityZone")) {
      availabilityZone = _json["availabilityZone"];
    }
    if (_json.containsKey("city")) {
      city = _json["city"];
    }
    if (_json.containsKey("continent")) {
      continent = _json["continent"];
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("facilityProvider")) {
      facilityProvider = _json["facilityProvider"];
    }
    if (_json.containsKey("facilityProviderFacilityId")) {
      facilityProviderFacilityId = _json["facilityProviderFacilityId"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("peeringdbFacilityId")) {
      peeringdbFacilityId = _json["peeringdbFacilityId"];
    }
    if (_json.containsKey("regionInfos")) {
      regionInfos = _json["regionInfos"]
          .map((value) => new InterconnectLocationRegionInfo.fromJson(value))
          .toList();
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (address != null) {
      _json["address"] = address;
    }
    if (availabilityZone != null) {
      _json["availabilityZone"] = availabilityZone;
    }
    if (city != null) {
      _json["city"] = city;
    }
    if (continent != null) {
      _json["continent"] = continent;
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (facilityProvider != null) {
      _json["facilityProvider"] = facilityProvider;
    }
    if (facilityProviderFacilityId != null) {
      _json["facilityProviderFacilityId"] = facilityProviderFacilityId;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (peeringdbFacilityId != null) {
      _json["peeringdbFacilityId"] = peeringdbFacilityId;
    }
    if (regionInfos != null) {
      _json["regionInfos"] =
          regionInfos.map((value) => (value).toJson()).toList();
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    return _json;
  }
}

class InterconnectLocationListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InterconnectLocationListWarningData();

  InterconnectLocationListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class InterconnectLocationListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InterconnectLocationListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InterconnectLocationListWarning();

  InterconnectLocationListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) =>
              new InterconnectLocationListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Response to the list request, and contains a list of interconnect locations.
class InterconnectLocationList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of InterconnectLocation resources.
  core.List<InterconnectLocation> items;

  /// [Output Only] Type of resource. Always compute#interconnectLocationList
  /// for lists of interconnect locations.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  InterconnectLocationListWarning warning;

  InterconnectLocationList();

  InterconnectLocationList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = _json["items"]
          .map((value) => new InterconnectLocation.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new InterconnectLocationListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// Information about any potential InterconnectAttachments between an
/// Interconnect at a specific InterconnectLocation, and a specific Cloud
/// Region.
class InterconnectLocationRegionInfo {
  /// Expected round-trip time in milliseconds, from this InterconnectLocation
  /// to a VM in this region.
  core.String expectedRttMs;

  /// Identifies the network presence of this location.
  /// Possible string values are:
  /// - "GLOBAL"
  /// - "LOCAL_REGION"
  /// - "LP_GLOBAL"
  /// - "LP_LOCAL_REGION"
  core.String locationPresence;

  /// URL for the region of this location.
  core.String region;

  InterconnectLocationRegionInfo();

  InterconnectLocationRegionInfo.fromJson(core.Map _json) {
    if (_json.containsKey("expectedRttMs")) {
      expectedRttMs = _json["expectedRttMs"];
    }
    if (_json.containsKey("locationPresence")) {
      locationPresence = _json["locationPresence"];
    }
    if (_json.containsKey("region")) {
      region = _json["region"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (expectedRttMs != null) {
      _json["expectedRttMs"] = expectedRttMs;
    }
    if (locationPresence != null) {
      _json["locationPresence"] = locationPresence;
    }
    if (region != null) {
      _json["region"] = region;
    }
    return _json;
  }
}

/// Description of a planned outage on this Interconnect. Next id: 9
class InterconnectOutageNotification {
  /// Iff issue_type is IT_PARTIAL_OUTAGE, a list of the Google-side circuit IDs
  /// that will be affected.
  core.List<core.String> affectedCircuits;

  /// A description about the purpose of the outage.
  core.String description;

  /// Scheduled end time for the outage (milliseconds since Unix epoch).
  core.String endTime;

  /// Form this outage is expected to take. Note that the "IT_" versions of this
  /// enum have been deprecated in favor of the unprefixed values.
  /// Possible string values are:
  /// - "IT_OUTAGE"
  /// - "IT_PARTIAL_OUTAGE"
  /// - "OUTAGE"
  /// - "PARTIAL_OUTAGE"
  core.String issueType;

  /// Unique identifier for this outage notification.
  core.String name;

  /// The party that generated this notification. Note that "NSRC_GOOGLE" has
  /// been deprecated in favor of "GOOGLE"
  /// Possible string values are:
  /// - "GOOGLE"
  /// - "NSRC_GOOGLE"
  core.String source;

  /// Scheduled start time for the outage (milliseconds since Unix epoch).
  core.String startTime;

  /// State of this notification. Note that the "NS_" versions of this enum have
  /// been deprecated in favor of the unprefixed values.
  /// Possible string values are:
  /// - "ACTIVE"
  /// - "CANCELLED"
  /// - "NS_ACTIVE"
  /// - "NS_CANCELED"
  core.String state;

  InterconnectOutageNotification();

  InterconnectOutageNotification.fromJson(core.Map _json) {
    if (_json.containsKey("affectedCircuits")) {
      affectedCircuits = _json["affectedCircuits"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("endTime")) {
      endTime = _json["endTime"];
    }
    if (_json.containsKey("issueType")) {
      issueType = _json["issueType"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("source")) {
      source = _json["source"];
    }
    if (_json.containsKey("startTime")) {
      startTime = _json["startTime"];
    }
    if (_json.containsKey("state")) {
      state = _json["state"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (affectedCircuits != null) {
      _json["affectedCircuits"] = affectedCircuits;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (endTime != null) {
      _json["endTime"] = endTime;
    }
    if (issueType != null) {
      _json["issueType"] = issueType;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (source != null) {
      _json["source"] = source;
    }
    if (startTime != null) {
      _json["startTime"] = startTime;
    }
    if (state != null) {
      _json["state"] = state;
    }
    return _json;
  }
}

/// A license resource.
class License {
  /// [Output Only] Deprecated. This field no longer reflects whether a license
  /// charges a usage fee.
  core.bool chargesUseFee;

  /// [Output Only] Type of resource. Always compute#license for licenses.
  core.String kind;

  /// [Output Only] Name of the resource. The name is 1-63 characters long and
  /// complies with RFC1035.
  core.String name;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  License();

  License.fromJson(core.Map _json) {
    if (_json.containsKey("chargesUseFee")) {
      chargesUseFee = _json["chargesUseFee"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (chargesUseFee != null) {
      _json["chargesUseFee"] = chargesUseFee;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    return _json;
  }
}

class MachineTypeScratchDisks {
  /// Size of the scratch disk, defined in GB.
  core.int diskGb;

  MachineTypeScratchDisks();

  MachineTypeScratchDisks.fromJson(core.Map _json) {
    if (_json.containsKey("diskGb")) {
      diskGb = _json["diskGb"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (diskGb != null) {
      _json["diskGb"] = diskGb;
    }
    return _json;
  }
}

/// A Machine Type resource. (== resource_for v1.machineTypes ==) (==
/// resource_for beta.machineTypes ==)
class MachineType {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// [Output Only] The deprecation status associated with this machine type.
  DeprecationStatus deprecated;

  /// [Output Only] An optional textual description of the resource.
  core.String description;

  /// [Output Only] The number of virtual CPUs that are available to the
  /// instance.
  core.int guestCpus;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Deprecated] This property is deprecated and will never be populated with
  /// any relevant values.
  core.int imageSpaceGb;

  /// [Output Only] Whether this machine type has a shared CPU. See Shared-core
  /// machine types for more information.
  core.bool isSharedCpu;

  /// [Output Only] The type of the resource. Always compute#machineType for
  /// machine types.
  core.String kind;

  /// [Output Only] Maximum persistent disks allowed.
  core.int maximumPersistentDisks;

  /// [Output Only] Maximum total persistent disks size (GB) allowed.
  core.String maximumPersistentDisksSizeGb;

  /// [Output Only] The amount of physical memory available to the instance,
  /// defined in MB.
  core.int memoryMb;

  /// [Output Only] Name of the resource.
  core.String name;

  /// [Output Only] List of extended scratch disks assigned to the instance.
  core.List<MachineTypeScratchDisks> scratchDisks;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] The name of the zone where the machine type resides, such as
  /// us-central1-a.
  core.String zone;

  MachineType();

  MachineType.fromJson(core.Map _json) {
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("deprecated")) {
      deprecated = new DeprecationStatus.fromJson(_json["deprecated"]);
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("guestCpus")) {
      guestCpus = _json["guestCpus"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("imageSpaceGb")) {
      imageSpaceGb = _json["imageSpaceGb"];
    }
    if (_json.containsKey("isSharedCpu")) {
      isSharedCpu = _json["isSharedCpu"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("maximumPersistentDisks")) {
      maximumPersistentDisks = _json["maximumPersistentDisks"];
    }
    if (_json.containsKey("maximumPersistentDisksSizeGb")) {
      maximumPersistentDisksSizeGb = _json["maximumPersistentDisksSizeGb"];
    }
    if (_json.containsKey("memoryMb")) {
      memoryMb = _json["memoryMb"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("scratchDisks")) {
      scratchDisks = _json["scratchDisks"]
          .map((value) => new MachineTypeScratchDisks.fromJson(value))
          .toList();
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("zone")) {
      zone = _json["zone"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (deprecated != null) {
      _json["deprecated"] = (deprecated).toJson();
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (guestCpus != null) {
      _json["guestCpus"] = guestCpus;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (imageSpaceGb != null) {
      _json["imageSpaceGb"] = imageSpaceGb;
    }
    if (isSharedCpu != null) {
      _json["isSharedCpu"] = isSharedCpu;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (maximumPersistentDisks != null) {
      _json["maximumPersistentDisks"] = maximumPersistentDisks;
    }
    if (maximumPersistentDisksSizeGb != null) {
      _json["maximumPersistentDisksSizeGb"] = maximumPersistentDisksSizeGb;
    }
    if (memoryMb != null) {
      _json["memoryMb"] = memoryMb;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (scratchDisks != null) {
      _json["scratchDisks"] =
          scratchDisks.map((value) => (value).toJson()).toList();
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (zone != null) {
      _json["zone"] = zone;
    }
    return _json;
  }
}

class MachineTypeAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  MachineTypeAggregatedListWarningData();

  MachineTypeAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class MachineTypeAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<MachineTypeAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  MachineTypeAggregatedListWarning();

  MachineTypeAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) =>
              new MachineTypeAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class MachineTypeAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of MachineTypesScopedList resources.
  core.Map<core.String, MachineTypesScopedList> items;

  /// [Output Only] Type of resource. Always compute#machineTypeAggregatedList
  /// for aggregated lists of machine types.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  MachineTypeAggregatedListWarning warning;

  MachineTypeAggregatedList();

  MachineTypeAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons
          .mapMap<core.Map<core.String, core.Object>, MachineTypesScopedList>(
              _json["items"],
              (core.Map<core.String, core.Object> item) =>
                  new MachineTypesScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new MachineTypeAggregatedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = commons
          .mapMap<MachineTypesScopedList, core.Map<core.String, core.Object>>(
              items, (MachineTypesScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class MachineTypeListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  MachineTypeListWarningData();

  MachineTypeListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class MachineTypeListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<MachineTypeListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  MachineTypeListWarning();

  MachineTypeListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new MachineTypeListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of machine types.
class MachineTypeList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of MachineType resources.
  core.List<MachineType> items;

  /// [Output Only] Type of resource. Always compute#machineTypeList for lists
  /// of machine types.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  MachineTypeListWarning warning;

  MachineTypeList();

  MachineTypeList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = _json["items"]
          .map((value) => new MachineType.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new MachineTypeListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class MachineTypesScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  MachineTypesScopedListWarningData();

  MachineTypesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] An informational warning that appears when the machine types
/// list is empty.
class MachineTypesScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<MachineTypesScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  MachineTypesScopedListWarning();

  MachineTypesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new MachineTypesScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class MachineTypesScopedList {
  /// [Output Only] List of machine types contained in this scope.
  core.List<MachineType> machineTypes;

  /// [Output Only] An informational warning that appears when the machine types
  /// list is empty.
  MachineTypesScopedListWarning warning;

  MachineTypesScopedList();

  MachineTypesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("machineTypes")) {
      machineTypes = _json["machineTypes"]
          .map((value) => new MachineType.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning = new MachineTypesScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (machineTypes != null) {
      _json["machineTypes"] =
          machineTypes.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class ManagedInstance {
  /// [Output Only] The current action that the managed instance group has
  /// scheduled for the instance. Possible values:
  /// - NONE The instance is running, and the managed instance group does not
  /// have any scheduled actions for this instance.
  /// - CREATING The managed instance group is creating this instance. If the
  /// group fails to create this instance, it will try again until it is
  /// successful.
  /// - CREATING_WITHOUT_RETRIES The managed instance group is attempting to
  /// create this instance only once. If the group fails to create this
  /// instance, it does not try again and the group's targetSize value is
  /// decreased instead.
  /// - RECREATING The managed instance group is recreating this instance.
  /// - DELETING The managed instance group is permanently deleting this
  /// instance.
  /// - ABANDONING The managed instance group is abandoning this instance. The
  /// instance will be removed from the instance group and from any target pools
  /// that are associated with this group.
  /// - RESTARTING The managed instance group is restarting the instance.
  /// - REFRESHING The managed instance group is applying configuration changes
  /// to the instance without stopping it. For example, the group can update the
  /// target pool list for an instance without stopping that instance.
  /// - VERIFYING The managed instance group has created the instance and it is
  /// in the process of being verified.
  /// Possible string values are:
  /// - "ABANDONING"
  /// - "CREATING"
  /// - "CREATING_WITHOUT_RETRIES"
  /// - "DELETING"
  /// - "NONE"
  /// - "RECREATING"
  /// - "REFRESHING"
  /// - "RESTARTING"
  core.String currentAction;

  /// [Output only] The unique identifier for this resource. This field is empty
  /// when instance does not exist.
  core.String id;

  /// [Output Only] The URL of the instance. The URL can exist even if the
  /// instance has not yet been created.
  core.String instance;

  /// [Output Only] The status of the instance. This field is empty when the
  /// instance does not exist.
  /// Possible string values are:
  /// - "PROVISIONING"
  /// - "RUNNING"
  /// - "STAGING"
  /// - "STOPPED"
  /// - "STOPPING"
  /// - "SUSPENDED"
  /// - "SUSPENDING"
  /// - "TERMINATED"
  core.String instanceStatus;

  /// [Output Only] Information about the last attempt to create or delete the
  /// instance.
  ManagedInstanceLastAttempt lastAttempt;

  ManagedInstance();

  ManagedInstance.fromJson(core.Map _json) {
    if (_json.containsKey("currentAction")) {
      currentAction = _json["currentAction"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("instance")) {
      instance = _json["instance"];
    }
    if (_json.containsKey("instanceStatus")) {
      instanceStatus = _json["instanceStatus"];
    }
    if (_json.containsKey("lastAttempt")) {
      lastAttempt =
          new ManagedInstanceLastAttempt.fromJson(_json["lastAttempt"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (currentAction != null) {
      _json["currentAction"] = currentAction;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (instance != null) {
      _json["instance"] = instance;
    }
    if (instanceStatus != null) {
      _json["instanceStatus"] = instanceStatus;
    }
    if (lastAttempt != null) {
      _json["lastAttempt"] = (lastAttempt).toJson();
    }
    return _json;
  }
}

class ManagedInstanceLastAttemptErrorsErrors {
  /// [Output Only] The error type identifier for this error.
  core.String code;

  /// [Output Only] Indicates the field in the request that caused the error.
  /// This property is optional.
  core.String location;

  /// [Output Only] An optional, human-readable error message.
  core.String message;

  ManagedInstanceLastAttemptErrorsErrors();

  ManagedInstanceLastAttemptErrorsErrors.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("location")) {
      location = _json["location"];
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (location != null) {
      _json["location"] = location;
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// [Output Only] Encountered errors during the last attempt to create or delete
/// the instance.
class ManagedInstanceLastAttemptErrors {
  /// [Output Only] The array of errors encountered while processing this
  /// operation.
  core.List<ManagedInstanceLastAttemptErrorsErrors> errors;

  ManagedInstanceLastAttemptErrors();

  ManagedInstanceLastAttemptErrors.fromJson(core.Map _json) {
    if (_json.containsKey("errors")) {
      errors = _json["errors"]
          .map((value) =>
              new ManagedInstanceLastAttemptErrorsErrors.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (errors != null) {
      _json["errors"] = errors.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

class ManagedInstanceLastAttempt {
  /// [Output Only] Encountered errors during the last attempt to create or
  /// delete the instance.
  ManagedInstanceLastAttemptErrors errors;

  ManagedInstanceLastAttempt();

  ManagedInstanceLastAttempt.fromJson(core.Map _json) {
    if (_json.containsKey("errors")) {
      errors = new ManagedInstanceLastAttemptErrors.fromJson(_json["errors"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (errors != null) {
      _json["errors"] = (errors).toJson();
    }
    return _json;
  }
}

class MetadataItems {
  /// Key for the metadata entry. Keys must conform to the following regexp:
  /// [a-zA-Z0-9-_]+, and be less than 128 bytes in length. This is reflected as
  /// part of a URL in the metadata server. Additionally, to avoid ambiguity,
  /// keys must not conflict with any other metadata keys for the project.
  core.String key;

  /// Value for the metadata entry. These are free-form strings, and only have
  /// meaning as interpreted by the image running in the instance. The only
  /// restriction placed on values is that their size must be less than or equal
  /// to 262144 bytes (256 KiB).
  core.String value;

  MetadataItems();

  MetadataItems.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// A metadata key/value entry.
class Metadata {
  /// Specifies a fingerprint for this request, which is essentially a hash of
  /// the metadata's contents and used for optimistic locking. The fingerprint
  /// is initially generated by Compute Engine and changes after every request
  /// to modify or update metadata. You must always provide an up-to-date
  /// fingerprint hash in order to update or change metadata.
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes {
    return convert.BASE64.decode(fingerprint);
  }

  void set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.BASE64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  /// Array of key/value pairs. The total size of all keys and values must be
  /// less than 512 KB.
  core.List<MetadataItems> items;

  /// [Output Only] Type of the resource. Always compute#metadata for metadata.
  core.String kind;

  Metadata();

  Metadata.fromJson(core.Map _json) {
    if (_json.containsKey("fingerprint")) {
      fingerprint = _json["fingerprint"];
    }
    if (_json.containsKey("items")) {
      items = _json["items"]
          .map((value) => new MetadataItems.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (fingerprint != null) {
      _json["fingerprint"] = fingerprint;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    return _json;
  }
}

/// The named port. For example: .
class NamedPort {
  /// The name for this named port. The name must be 1-63 characters long, and
  /// comply with RFC1035.
  core.String name;

  /// The port number, which can be a value between 1 and 65535.
  core.int port;

  NamedPort();

  NamedPort.fromJson(core.Map _json) {
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("port")) {
      port = _json["port"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (name != null) {
      _json["name"] = name;
    }
    if (port != null) {
      _json["port"] = port;
    }
    return _json;
  }
}

/// Represents a Network resource. Read Networks and Firewalls for more
/// information. (== resource_for v1.networks ==) (== resource_for beta.networks
/// ==)
class Network {
  /// The range of internal addresses that are legal on this network. This range
  /// is a CIDR specification, for example: 192.168.0.0/16. Provided by the
  /// client when the network is created.
  core.String IPv4Range;

  /// When set to true, the network is created in "auto subnet mode". When set
  /// to false, the network is in "custom subnet mode".
  ///
  /// In "auto subnet mode", a newly created network is assigned the default
  /// CIDR of 10.128.0.0/9 and it automatically creates one subnetwork per
  /// region.
  core.bool autoCreateSubnetworks;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// A gateway address for default routing to other networks. This value is
  /// read only and is selected by the Google Compute Engine, typically as the
  /// first usable address in the IPv4Range.
  core.String gatewayIPv4;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#network for networks.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
  /// be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// [Output Only] List of network peerings for the resource.
  core.List<NetworkPeering> peerings;

  /// The network-level routing configuration for this network. Used by Cloud
  /// Router to determine what type of network-wide routing behavior to enforce.
  NetworkRoutingConfig routingConfig;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] Server-defined fully-qualified URLs for all subnetworks in
  /// this network.
  core.List<core.String> subnetworks;

  Network();

  Network.fromJson(core.Map _json) {
    if (_json.containsKey("IPv4Range")) {
      IPv4Range = _json["IPv4Range"];
    }
    if (_json.containsKey("autoCreateSubnetworks")) {
      autoCreateSubnetworks = _json["autoCreateSubnetworks"];
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("gatewayIPv4")) {
      gatewayIPv4 = _json["gatewayIPv4"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("peerings")) {
      peerings = _json["peerings"]
          .map((value) => new NetworkPeering.fromJson(value))
          .toList();
    }
    if (_json.containsKey("routingConfig")) {
      routingConfig = new NetworkRoutingConfig.fromJson(_json["routingConfig"]);
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("subnetworks")) {
      subnetworks = _json["subnetworks"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (IPv4Range != null) {
      _json["IPv4Range"] = IPv4Range;
    }
    if (autoCreateSubnetworks != null) {
      _json["autoCreateSubnetworks"] = autoCreateSubnetworks;
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (gatewayIPv4 != null) {
      _json["gatewayIPv4"] = gatewayIPv4;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (peerings != null) {
      _json["peerings"] = peerings.map((value) => (value).toJson()).toList();
    }
    if (routingConfig != null) {
      _json["routingConfig"] = (routingConfig).toJson();
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (subnetworks != null) {
      _json["subnetworks"] = subnetworks;
    }
    return _json;
  }
}

/// A network interface resource attached to an instance.
class NetworkInterface {
  /// An array of configurations for this interface. Currently, only one access
  /// config, ONE_TO_ONE_NAT, is supported. If there are no accessConfigs
  /// specified, then this instance will have no external internet access.
  core.List<AccessConfig> accessConfigs;

  /// An array of alias IP ranges for this network interface. Can only be
  /// specified for network interfaces on subnet-mode networks.
  core.List<AliasIpRange> aliasIpRanges;

  /// [Output Only] Type of the resource. Always compute#networkInterface for
  /// network interfaces.
  core.String kind;

  /// [Output Only] The name of the network interface, generated by the server.
  /// For network devices, these are eth0, eth1, etc.
  core.String name;

  /// URL of the network resource for this instance. When creating an instance,
  /// if neither the network nor the subnetwork is specified, the default
  /// network global/networks/default is used; if the network is not specified
  /// but the subnetwork is specified, the network is inferred.
  ///
  /// This field is optional when creating a firewall rule. If not specified
  /// when creating a firewall rule, the default network global/networks/default
  /// is used.
  ///
  /// If you specify this property, you can specify the network as a full or
  /// partial URL. For example, the following are all valid URLs:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/global/networks/network
  /// - projects/project/global/networks/network
  /// - global/networks/default
  core.String network;

  /// An IPv4 internal network address to assign to the instance for this
  /// network interface. If not specified by the user, an unused internal IP is
  /// assigned by the system.
  core.String networkIP;

  /// The URL of the Subnetwork resource for this instance. If the network
  /// resource is in legacy mode, do not provide this property. If the network
  /// is in auto subnet mode, providing the subnetwork is optional. If the
  /// network is in custom subnet mode, then this field should be specified. If
  /// you specify this property, you can specify the subnetwork as a full or
  /// partial URL. For example, the following are all valid URLs:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/regions/region/subnetworks/subnetwork
  /// - regions/region/subnetworks/subnetwork
  core.String subnetwork;

  NetworkInterface();

  NetworkInterface.fromJson(core.Map _json) {
    if (_json.containsKey("accessConfigs")) {
      accessConfigs = _json["accessConfigs"]
          .map((value) => new AccessConfig.fromJson(value))
          .toList();
    }
    if (_json.containsKey("aliasIpRanges")) {
      aliasIpRanges = _json["aliasIpRanges"]
          .map((value) => new AliasIpRange.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("network")) {
      network = _json["network"];
    }
    if (_json.containsKey("networkIP")) {
      networkIP = _json["networkIP"];
    }
    if (_json.containsKey("subnetwork")) {
      subnetwork = _json["subnetwork"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (accessConfigs != null) {
      _json["accessConfigs"] =
          accessConfigs.map((value) => (value).toJson()).toList();
    }
    if (aliasIpRanges != null) {
      _json["aliasIpRanges"] =
          aliasIpRanges.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (network != null) {
      _json["network"] = network;
    }
    if (networkIP != null) {
      _json["networkIP"] = networkIP;
    }
    if (subnetwork != null) {
      _json["subnetwork"] = subnetwork;
    }
    return _json;
  }
}

class NetworkListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  NetworkListWarningData();

  NetworkListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class NetworkListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<NetworkListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  NetworkListWarning();

  NetworkListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new NetworkListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of networks.
class NetworkList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Network resources.
  core.List<Network> items;

  /// [Output Only] Type of resource. Always compute#networkList for lists of
  /// networks.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  NetworkListWarning warning;

  NetworkList();

  NetworkList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items =
          _json["items"].map((value) => new Network.fromJson(value)).toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new NetworkListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// A network peering attached to a network resource. The message includes the
/// peering name, peer network, peering state, and a flag indicating whether
/// Google Compute Engine should automatically create routes for the peering.
class NetworkPeering {
  /// Whether full mesh connectivity is created and managed automatically. When
  /// it is set to true, Google Compute Engine will automatically create and
  /// manage the routes between two networks when the state is ACTIVE.
  /// Otherwise, user needs to create routes manually to route packets to peer
  /// network.
  core.bool autoCreateRoutes;

  /// Name of this peering. Provided by the client when the peering is created.
  /// The name must comply with RFC1035. Specifically, the name must be 1-63
  /// characters long and match regular expression [a-z]([-a-z0-9]*[a-z0-9])?
  /// which means the first character must be a lowercase letter, and all the
  /// following characters must be a dash, lowercase letter, or digit, except
  /// the last character, which cannot be a dash.
  core.String name;

  /// The URL of the peer network. It can be either full URL or partial URL. The
  /// peer network may belong to a different project. If the partial URL does
  /// not contain project, it is assumed that the peer network is in the same
  /// project as the current network.
  core.String network;

  /// [Output Only] State for the peering.
  /// Possible string values are:
  /// - "ACTIVE"
  /// - "INACTIVE"
  core.String state;

  /// [Output Only] Details about the current state of the peering.
  core.String stateDetails;

  NetworkPeering();

  NetworkPeering.fromJson(core.Map _json) {
    if (_json.containsKey("autoCreateRoutes")) {
      autoCreateRoutes = _json["autoCreateRoutes"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("network")) {
      network = _json["network"];
    }
    if (_json.containsKey("state")) {
      state = _json["state"];
    }
    if (_json.containsKey("stateDetails")) {
      stateDetails = _json["stateDetails"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (autoCreateRoutes != null) {
      _json["autoCreateRoutes"] = autoCreateRoutes;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (network != null) {
      _json["network"] = network;
    }
    if (state != null) {
      _json["state"] = state;
    }
    if (stateDetails != null) {
      _json["stateDetails"] = stateDetails;
    }
    return _json;
  }
}

/// A routing configuration attached to a network resource. The message includes
/// the list of routers associated with the network, and a flag indicating the
/// type of routing behavior to enforce network-wide.
class NetworkRoutingConfig {
  /// The network-wide routing mode to use. If set to REGIONAL, this network's
  /// cloud routers will only advertise routes with subnetworks of this network
  /// in the same region as the router. If set to GLOBAL, this network's cloud
  /// routers will advertise routes with all subnetworks of this network, across
  /// regions.
  /// Possible string values are:
  /// - "GLOBAL"
  /// - "REGIONAL"
  core.String routingMode;

  NetworkRoutingConfig();

  NetworkRoutingConfig.fromJson(core.Map _json) {
    if (_json.containsKey("routingMode")) {
      routingMode = _json["routingMode"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (routingMode != null) {
      _json["routingMode"] = routingMode;
    }
    return _json;
  }
}

class NetworksAddPeeringRequest {
  /// Whether Google Compute Engine manages the routes automatically.
  core.bool autoCreateRoutes;

  /// Name of the peering, which should conform to RFC1035.
  core.String name;

  /// URL of the peer network. It can be either full URL or partial URL. The
  /// peer network may belong to a different project. If the partial URL does
  /// not contain project, it is assumed that the peer network is in the same
  /// project as the current network.
  core.String peerNetwork;

  NetworksAddPeeringRequest();

  NetworksAddPeeringRequest.fromJson(core.Map _json) {
    if (_json.containsKey("autoCreateRoutes")) {
      autoCreateRoutes = _json["autoCreateRoutes"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("peerNetwork")) {
      peerNetwork = _json["peerNetwork"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (autoCreateRoutes != null) {
      _json["autoCreateRoutes"] = autoCreateRoutes;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (peerNetwork != null) {
      _json["peerNetwork"] = peerNetwork;
    }
    return _json;
  }
}

class NetworksRemovePeeringRequest {
  /// Name of the peering, which should conform to RFC1035.
  core.String name;

  NetworksRemovePeeringRequest();

  NetworksRemovePeeringRequest.fromJson(core.Map _json) {
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (name != null) {
      _json["name"] = name;
    }
    return _json;
  }
}

class OperationErrorErrors {
  /// [Output Only] The error type identifier for this error.
  core.String code;

  /// [Output Only] Indicates the field in the request that caused the error.
  /// This property is optional.
  core.String location;

  /// [Output Only] An optional, human-readable error message.
  core.String message;

  OperationErrorErrors();

  OperationErrorErrors.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("location")) {
      location = _json["location"];
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (location != null) {
      _json["location"] = location;
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// [Output Only] If errors are generated during processing of the operation,
/// this field will be populated.
class OperationError {
  /// [Output Only] The array of errors encountered while processing this
  /// operation.
  core.List<OperationErrorErrors> errors;

  OperationError();

  OperationError.fromJson(core.Map _json) {
    if (_json.containsKey("errors")) {
      errors = _json["errors"]
          .map((value) => new OperationErrorErrors.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (errors != null) {
      _json["errors"] = errors.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

class OperationWarningsData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  OperationWarningsData();

  OperationWarningsData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

class OperationWarnings {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<OperationWarningsData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  OperationWarnings();

  OperationWarnings.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new OperationWarningsData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// An Operation resource, used to manage asynchronous API requests. (==
/// resource_for v1.globalOperations ==) (== resource_for beta.globalOperations
/// ==) (== resource_for v1.regionOperations ==) (== resource_for
/// beta.regionOperations ==) (== resource_for v1.zoneOperations ==) (==
/// resource_for beta.zoneOperations ==)
class Operation {
  /// [Output Only] Reserved for future use.
  core.String clientOperationId;

  /// [Deprecated] This field is deprecated.
  core.String creationTimestamp;

  /// [Output Only] A textual description of the operation, which is set when
  /// the operation is created.
  core.String description;

  /// [Output Only] The time that this operation was completed. This value is in
  /// RFC3339 text format.
  core.String endTime;

  /// [Output Only] If errors are generated during processing of the operation,
  /// this field will be populated.
  OperationError error;

  /// [Output Only] If the operation fails, this field contains the HTTP error
  /// message that was returned, such as NOT FOUND.
  core.String httpErrorMessage;

  /// [Output Only] If the operation fails, this field contains the HTTP error
  /// status code that was returned. For example, a 404 means the resource was
  /// not found.
  core.int httpErrorStatusCode;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] The time that this operation was requested. This value is in
  /// RFC3339 text format.
  core.String insertTime;

  /// [Output Only] Type of the resource. Always compute#operation for Operation
  /// resources.
  core.String kind;

  /// [Output Only] Name of the resource.
  core.String name;

  /// [Output Only] The type of operation, such as insert, update, or delete,
  /// and so on.
  core.String operationType;

  /// [Output Only] An optional progress indicator that ranges from 0 to 100.
  /// There is no requirement that this be linear or support any granularity of
  /// operations. This should not be used to guess when the operation will be
  /// complete. This number should monotonically increase as the operation
  /// progresses.
  core.int progress;

  /// [Output Only] The URL of the region where the operation resides. Only
  /// available when performing regional operations. You must specify this field
  /// as part of the HTTP request URL. It is not settable as a field in the
  /// request body.
  core.String region;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] The time that this operation was started by the server. This
  /// value is in RFC3339 text format.
  core.String startTime;

  /// [Output Only] The status of the operation, which can be one of the
  /// following: PENDING, RUNNING, or DONE.
  /// Possible string values are:
  /// - "DONE"
  /// - "PENDING"
  /// - "RUNNING"
  core.String status;

  /// [Output Only] An optional textual description of the current status of the
  /// operation.
  core.String statusMessage;

  /// [Output Only] The unique target ID, which identifies a specific
  /// incarnation of the target resource.
  core.String targetId;

  /// [Output Only] The URL of the resource that the operation modifies. For
  /// operations related to creating a snapshot, this points to the persistent
  /// disk that the snapshot was created from.
  core.String targetLink;

  /// [Output Only] User who requested the operation, for example:
  /// user@example.com.
  core.String user;

  /// [Output Only] If warning messages are generated during processing of the
  /// operation, this field will be populated.
  core.List<OperationWarnings> warnings;

  /// [Output Only] The URL of the zone where the operation resides. Only
  /// available when performing per-zone operations. You must specify this field
  /// as part of the HTTP request URL. It is not settable as a field in the
  /// request body.
  core.String zone;

  Operation();

  Operation.fromJson(core.Map _json) {
    if (_json.containsKey("clientOperationId")) {
      clientOperationId = _json["clientOperationId"];
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("endTime")) {
      endTime = _json["endTime"];
    }
    if (_json.containsKey("error")) {
      error = new OperationError.fromJson(_json["error"]);
    }
    if (_json.containsKey("httpErrorMessage")) {
      httpErrorMessage = _json["httpErrorMessage"];
    }
    if (_json.containsKey("httpErrorStatusCode")) {
      httpErrorStatusCode = _json["httpErrorStatusCode"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("insertTime")) {
      insertTime = _json["insertTime"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("operationType")) {
      operationType = _json["operationType"];
    }
    if (_json.containsKey("progress")) {
      progress = _json["progress"];
    }
    if (_json.containsKey("region")) {
      region = _json["region"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("startTime")) {
      startTime = _json["startTime"];
    }
    if (_json.containsKey("status")) {
      status = _json["status"];
    }
    if (_json.containsKey("statusMessage")) {
      statusMessage = _json["statusMessage"];
    }
    if (_json.containsKey("targetId")) {
      targetId = _json["targetId"];
    }
    if (_json.containsKey("targetLink")) {
      targetLink = _json["targetLink"];
    }
    if (_json.containsKey("user")) {
      user = _json["user"];
    }
    if (_json.containsKey("warnings")) {
      warnings = _json["warnings"]
          .map((value) => new OperationWarnings.fromJson(value))
          .toList();
    }
    if (_json.containsKey("zone")) {
      zone = _json["zone"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (clientOperationId != null) {
      _json["clientOperationId"] = clientOperationId;
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (endTime != null) {
      _json["endTime"] = endTime;
    }
    if (error != null) {
      _json["error"] = (error).toJson();
    }
    if (httpErrorMessage != null) {
      _json["httpErrorMessage"] = httpErrorMessage;
    }
    if (httpErrorStatusCode != null) {
      _json["httpErrorStatusCode"] = httpErrorStatusCode;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (insertTime != null) {
      _json["insertTime"] = insertTime;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (operationType != null) {
      _json["operationType"] = operationType;
    }
    if (progress != null) {
      _json["progress"] = progress;
    }
    if (region != null) {
      _json["region"] = region;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (startTime != null) {
      _json["startTime"] = startTime;
    }
    if (status != null) {
      _json["status"] = status;
    }
    if (statusMessage != null) {
      _json["statusMessage"] = statusMessage;
    }
    if (targetId != null) {
      _json["targetId"] = targetId;
    }
    if (targetLink != null) {
      _json["targetLink"] = targetLink;
    }
    if (user != null) {
      _json["user"] = user;
    }
    if (warnings != null) {
      _json["warnings"] = warnings.map((value) => (value).toJson()).toList();
    }
    if (zone != null) {
      _json["zone"] = zone;
    }
    return _json;
  }
}

class OperationAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  OperationAggregatedListWarningData();

  OperationAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class OperationAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<OperationAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  OperationAggregatedListWarning();

  OperationAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map(
              (value) => new OperationAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class OperationAggregatedList {
  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] A map of scoped operation lists.
  core.Map<core.String, OperationsScopedList> items;

  /// [Output Only] Type of resource. Always compute#operationAggregatedList for
  /// aggregated lists of operations.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  OperationAggregatedListWarning warning;

  OperationAggregatedList();

  OperationAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons
          .mapMap<core.Map<core.String, core.Object>, OperationsScopedList>(
              _json["items"],
              (core.Map<core.String, core.Object> item) =>
                  new OperationsScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new OperationAggregatedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = commons
          .mapMap<OperationsScopedList, core.Map<core.String, core.Object>>(
              items, (OperationsScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class OperationListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  OperationListWarningData();

  OperationListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class OperationListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<OperationListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  OperationListWarning();

  OperationListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new OperationListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of Operation resources.
class OperationList {
  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] A list of Operation resources.
  core.List<Operation> items;

  /// [Output Only] Type of resource. Always compute#operations for Operations
  /// resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  OperationListWarning warning;

  OperationList();

  OperationList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items =
          _json["items"].map((value) => new Operation.fromJson(value)).toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new OperationListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class OperationsScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  OperationsScopedListWarningData();

  OperationsScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning which replaces the list of operations
/// when the list is empty.
class OperationsScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<OperationsScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  OperationsScopedListWarning();

  OperationsScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new OperationsScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class OperationsScopedList {
  /// [Output Only] List of operations contained in this scope.
  core.List<Operation> operations;

  /// [Output Only] Informational warning which replaces the list of operations
  /// when the list is empty.
  OperationsScopedListWarning warning;

  OperationsScopedList();

  OperationsScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("operations")) {
      operations = _json["operations"]
          .map((value) => new Operation.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning = new OperationsScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (operations != null) {
      _json["operations"] =
          operations.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// A matcher for the path portion of the URL. The BackendService from the
/// longest-matched rule will serve the URL. If no rule was matched, the default
/// service will be used.
class PathMatcher {
  /// The full or partial URL to the BackendService resource. This will be used
  /// if none of the pathRules defined by this PathMatcher is matched by the
  /// URL's path portion. For example, the following are all valid URLs to a
  /// BackendService resource:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/global/backendServices/backendService
  /// - compute/v1/projects/project/global/backendServices/backendService
  /// - global/backendServices/backendService
  core.String defaultService;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// The name to which this PathMatcher is referred by the HostRule.
  core.String name;

  /// The list of path rules.
  core.List<PathRule> pathRules;

  PathMatcher();

  PathMatcher.fromJson(core.Map _json) {
    if (_json.containsKey("defaultService")) {
      defaultService = _json["defaultService"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("pathRules")) {
      pathRules = _json["pathRules"]
          .map((value) => new PathRule.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (defaultService != null) {
      _json["defaultService"] = defaultService;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (pathRules != null) {
      _json["pathRules"] = pathRules.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

/// A path-matching rule for a URL. If matched, will use the specified
/// BackendService to handle the traffic arriving at this URL.
class PathRule {
  /// The list of path patterns to match. Each must start with / and the only
  /// place a * is allowed is at the end following a /. The string fed to the
  /// path matcher does not include any text after the first ? or #, and those
  /// chars are not allowed here.
  core.List<core.String> paths;

  /// The URL of the BackendService resource if this rule is matched.
  core.String service;

  PathRule();

  PathRule.fromJson(core.Map _json) {
    if (_json.containsKey("paths")) {
      paths = _json["paths"];
    }
    if (_json.containsKey("service")) {
      service = _json["service"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (paths != null) {
      _json["paths"] = paths;
    }
    if (service != null) {
      _json["service"] = service;
    }
    return _json;
  }
}

/// A Project resource. For an overview of projects, see  Cloud Platform
/// Resource Hierarchy. (== resource_for v1.projects ==) (== resource_for
/// beta.projects ==)
class Project {
  /// Metadata key/value pairs available to all instances contained in this
  /// project. See Custom metadata for more information.
  Metadata commonInstanceMetadata;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// [Output Only] Default service account used by VMs running in this project.
  core.String defaultServiceAccount;

  /// An optional textual description of the resource.
  core.String description;

  /// Restricted features enabled for use on this project.
  core.List<core.String> enabledFeatures;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server. This is not the project ID, and is just a unique ID
  /// used by Compute Engine to identify resources.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#project for projects.
  core.String kind;

  /// The project ID. For example: my-example-project. Use the project ID to
  /// make requests to Compute Engine.
  core.String name;

  /// [Output Only] Quotas assigned to this project.
  core.List<Quota> quotas;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// The naming prefix for daily usage reports and the Google Cloud Storage
  /// bucket where they are stored.
  UsageExportLocation usageExportLocation;

  /// [Output Only] The role this project has in a shared VPC configuration.
  /// Currently only HOST projects are differentiated.
  /// Possible string values are:
  /// - "HOST"
  /// - "UNSPECIFIED_XPN_PROJECT_STATUS"
  core.String xpnProjectStatus;

  Project();

  Project.fromJson(core.Map _json) {
    if (_json.containsKey("commonInstanceMetadata")) {
      commonInstanceMetadata =
          new Metadata.fromJson(_json["commonInstanceMetadata"]);
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("defaultServiceAccount")) {
      defaultServiceAccount = _json["defaultServiceAccount"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("enabledFeatures")) {
      enabledFeatures = _json["enabledFeatures"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("quotas")) {
      quotas =
          _json["quotas"].map((value) => new Quota.fromJson(value)).toList();
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("usageExportLocation")) {
      usageExportLocation =
          new UsageExportLocation.fromJson(_json["usageExportLocation"]);
    }
    if (_json.containsKey("xpnProjectStatus")) {
      xpnProjectStatus = _json["xpnProjectStatus"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (commonInstanceMetadata != null) {
      _json["commonInstanceMetadata"] = (commonInstanceMetadata).toJson();
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (defaultServiceAccount != null) {
      _json["defaultServiceAccount"] = defaultServiceAccount;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (enabledFeatures != null) {
      _json["enabledFeatures"] = enabledFeatures;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (quotas != null) {
      _json["quotas"] = quotas.map((value) => (value).toJson()).toList();
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (usageExportLocation != null) {
      _json["usageExportLocation"] = (usageExportLocation).toJson();
    }
    if (xpnProjectStatus != null) {
      _json["xpnProjectStatus"] = xpnProjectStatus;
    }
    return _json;
  }
}

class ProjectsDisableXpnResourceRequest {
  /// Service resource (a.k.a service project) ID.
  XpnResourceId xpnResource;

  ProjectsDisableXpnResourceRequest();

  ProjectsDisableXpnResourceRequest.fromJson(core.Map _json) {
    if (_json.containsKey("xpnResource")) {
      xpnResource = new XpnResourceId.fromJson(_json["xpnResource"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (xpnResource != null) {
      _json["xpnResource"] = (xpnResource).toJson();
    }
    return _json;
  }
}

class ProjectsEnableXpnResourceRequest {
  /// Service resource (a.k.a service project) ID.
  XpnResourceId xpnResource;

  ProjectsEnableXpnResourceRequest();

  ProjectsEnableXpnResourceRequest.fromJson(core.Map _json) {
    if (_json.containsKey("xpnResource")) {
      xpnResource = new XpnResourceId.fromJson(_json["xpnResource"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (xpnResource != null) {
      _json["xpnResource"] = (xpnResource).toJson();
    }
    return _json;
  }
}

class ProjectsGetXpnResources {
  /// [Output Only] Type of resource. Always compute#projectsGetXpnResources for
  /// lists of service resources (a.k.a service projects)
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// Service resources (a.k.a service projects) attached to this project as
  /// their shared VPC host.
  core.List<XpnResourceId> resources;

  ProjectsGetXpnResources();

  ProjectsGetXpnResources.fromJson(core.Map _json) {
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("resources")) {
      resources = _json["resources"]
          .map((value) => new XpnResourceId.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (resources != null) {
      _json["resources"] = resources.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

class ProjectsListXpnHostsRequest {
  /// Optional organization ID managed by Cloud Resource Manager, for which to
  /// list shared VPC host projects. If not specified, the organization will be
  /// inferred from the project.
  core.String organization;

  ProjectsListXpnHostsRequest();

  ProjectsListXpnHostsRequest.fromJson(core.Map _json) {
    if (_json.containsKey("organization")) {
      organization = _json["organization"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (organization != null) {
      _json["organization"] = organization;
    }
    return _json;
  }
}

/// A quotas entry.
class Quota {
  /// [Output Only] Quota limit for this metric.
  core.double limit;

  /// [Output Only] Name of the quota metric.
  /// Possible string values are:
  /// - "AUTOSCALERS"
  /// - "BACKEND_BUCKETS"
  /// - "BACKEND_SERVICES"
  /// - "COMMITMENTS"
  /// - "CPUS"
  /// - "CPUS_ALL_REGIONS"
  /// - "DISKS_TOTAL_GB"
  /// - "FIREWALLS"
  /// - "FORWARDING_RULES"
  /// - "HEALTH_CHECKS"
  /// - "IMAGES"
  /// - "INSTANCES"
  /// - "INSTANCE_GROUPS"
  /// - "INSTANCE_GROUP_MANAGERS"
  /// - "INSTANCE_TEMPLATES"
  /// - "INTERCONNECTS"
  /// - "INTERNAL_ADDRESSES"
  /// - "IN_USE_ADDRESSES"
  /// - "LOCAL_SSD_TOTAL_GB"
  /// - "NETWORKS"
  /// - "NVIDIA_K80_GPUS"
  /// - "NVIDIA_P100_GPUS"
  /// - "PREEMPTIBLE_CPUS"
  /// - "PREEMPTIBLE_LOCAL_SSD_GB"
  /// - "PREEMPTIBLE_NVIDIA_K80_GPUS"
  /// - "PREEMPTIBLE_NVIDIA_P100_GPUS"
  /// - "REGIONAL_AUTOSCALERS"
  /// - "REGIONAL_INSTANCE_GROUP_MANAGERS"
  /// - "ROUTERS"
  /// - "ROUTES"
  /// - "SECURITY_POLICIES"
  /// - "SECURITY_POLICY_RULES"
  /// - "SNAPSHOTS"
  /// - "SSD_TOTAL_GB"
  /// - "SSL_CERTIFICATES"
  /// - "STATIC_ADDRESSES"
  /// - "SUBNETWORKS"
  /// - "TARGET_HTTPS_PROXIES"
  /// - "TARGET_HTTP_PROXIES"
  /// - "TARGET_INSTANCES"
  /// - "TARGET_POOLS"
  /// - "TARGET_SSL_PROXIES"
  /// - "TARGET_TCP_PROXIES"
  /// - "TARGET_VPN_GATEWAYS"
  /// - "URL_MAPS"
  /// - "VPN_TUNNELS"
  core.String metric;

  /// [Output Only] Current usage of this metric.
  core.double usage;

  Quota();

  Quota.fromJson(core.Map _json) {
    if (_json.containsKey("limit")) {
      limit = _json["limit"];
    }
    if (_json.containsKey("metric")) {
      metric = _json["metric"];
    }
    if (_json.containsKey("usage")) {
      usage = _json["usage"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (limit != null) {
      _json["limit"] = limit;
    }
    if (metric != null) {
      _json["metric"] = metric;
    }
    if (usage != null) {
      _json["usage"] = usage;
    }
    return _json;
  }
}

/// Represents a reference to a resource.
class Reference {
  /// [Output Only] Type of the resource. Always compute#reference for
  /// references.
  core.String kind;

  /// A description of the reference type with no implied semantics. Possible
  /// values include:
  /// - MEMBER_OF
  core.String referenceType;

  /// URL of the resource which refers to the target.
  core.String referrer;

  /// URL of the resource to which this reference points.
  core.String target;

  Reference();

  Reference.fromJson(core.Map _json) {
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("referenceType")) {
      referenceType = _json["referenceType"];
    }
    if (_json.containsKey("referrer")) {
      referrer = _json["referrer"];
    }
    if (_json.containsKey("target")) {
      target = _json["target"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (referenceType != null) {
      _json["referenceType"] = referenceType;
    }
    if (referrer != null) {
      _json["referrer"] = referrer;
    }
    if (target != null) {
      _json["target"] = target;
    }
    return _json;
  }
}

/// Region resource. (== resource_for beta.regions ==) (== resource_for
/// v1.regions ==)
class Region {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// [Output Only] The deprecation status associated with this region.
  DeprecationStatus deprecated;

  /// [Output Only] Textual description of the resource.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#region for regions.
  core.String kind;

  /// [Output Only] Name of the resource.
  core.String name;

  /// [Output Only] Quotas assigned to this region.
  core.List<Quota> quotas;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] Status of the region, either UP or DOWN.
  /// Possible string values are:
  /// - "DOWN"
  /// - "UP"
  core.String status;

  /// [Output Only] A list of zones available in this region, in the form of
  /// resource URLs.
  core.List<core.String> zones;

  Region();

  Region.fromJson(core.Map _json) {
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("deprecated")) {
      deprecated = new DeprecationStatus.fromJson(_json["deprecated"]);
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("quotas")) {
      quotas =
          _json["quotas"].map((value) => new Quota.fromJson(value)).toList();
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("status")) {
      status = _json["status"];
    }
    if (_json.containsKey("zones")) {
      zones = _json["zones"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (deprecated != null) {
      _json["deprecated"] = (deprecated).toJson();
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (quotas != null) {
      _json["quotas"] = quotas.map((value) => (value).toJson()).toList();
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (status != null) {
      _json["status"] = status;
    }
    if (zones != null) {
      _json["zones"] = zones;
    }
    return _json;
  }
}

class RegionAutoscalerListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  RegionAutoscalerListWarningData();

  RegionAutoscalerListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class RegionAutoscalerListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<RegionAutoscalerListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  RegionAutoscalerListWarning();

  RegionAutoscalerListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new RegionAutoscalerListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of autoscalers.
class RegionAutoscalerList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Autoscaler resources.
  core.List<Autoscaler> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  RegionAutoscalerListWarning warning;

  RegionAutoscalerList();

  RegionAutoscalerList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = _json["items"]
          .map((value) => new Autoscaler.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new RegionAutoscalerListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class RegionInstanceGroupListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  RegionInstanceGroupListWarningData();

  RegionInstanceGroupListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class RegionInstanceGroupListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<RegionInstanceGroupListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  RegionInstanceGroupListWarning();

  RegionInstanceGroupListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map(
              (value) => new RegionInstanceGroupListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of InstanceGroup resources.
class RegionInstanceGroupList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of InstanceGroup resources.
  core.List<InstanceGroup> items;

  /// The resource type.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  RegionInstanceGroupListWarning warning;

  RegionInstanceGroupList();

  RegionInstanceGroupList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = _json["items"]
          .map((value) => new InstanceGroup.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new RegionInstanceGroupListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class RegionInstanceGroupManagerListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  RegionInstanceGroupManagerListWarningData();

  RegionInstanceGroupManagerListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class RegionInstanceGroupManagerListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<RegionInstanceGroupManagerListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  RegionInstanceGroupManagerListWarning();

  RegionInstanceGroupManagerListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) =>
              new RegionInstanceGroupManagerListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of managed instance groups.
class RegionInstanceGroupManagerList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of InstanceGroupManager resources.
  core.List<InstanceGroupManager> items;

  /// [Output Only] The resource type, which is always
  /// compute#instanceGroupManagerList for a list of managed instance groups
  /// that exist in th regional scope.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  RegionInstanceGroupManagerListWarning warning;

  RegionInstanceGroupManagerList();

  RegionInstanceGroupManagerList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = _json["items"]
          .map((value) => new InstanceGroupManager.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning =
          new RegionInstanceGroupManagerListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class RegionInstanceGroupManagersAbandonInstancesRequest {
  /// The URLs of one or more instances to abandon. This can be a full URL or a
  /// partial URL, such as zones/[ZONE]/instances/[INSTANCE_NAME].
  core.List<core.String> instances;

  RegionInstanceGroupManagersAbandonInstancesRequest();

  RegionInstanceGroupManagersAbandonInstancesRequest.fromJson(core.Map _json) {
    if (_json.containsKey("instances")) {
      instances = _json["instances"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (instances != null) {
      _json["instances"] = instances;
    }
    return _json;
  }
}

class RegionInstanceGroupManagersDeleteInstancesRequest {
  /// The URLs of one or more instances to delete. This can be a full URL or a
  /// partial URL, such as zones/[ZONE]/instances/[INSTANCE_NAME].
  core.List<core.String> instances;

  RegionInstanceGroupManagersDeleteInstancesRequest();

  RegionInstanceGroupManagersDeleteInstancesRequest.fromJson(core.Map _json) {
    if (_json.containsKey("instances")) {
      instances = _json["instances"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (instances != null) {
      _json["instances"] = instances;
    }
    return _json;
  }
}

class RegionInstanceGroupManagersListInstancesResponse {
  /// List of managed instances.
  core.List<ManagedInstance> managedInstances;

  RegionInstanceGroupManagersListInstancesResponse();

  RegionInstanceGroupManagersListInstancesResponse.fromJson(core.Map _json) {
    if (_json.containsKey("managedInstances")) {
      managedInstances = _json["managedInstances"]
          .map((value) => new ManagedInstance.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (managedInstances != null) {
      _json["managedInstances"] =
          managedInstances.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

class RegionInstanceGroupManagersRecreateRequest {
  /// The URLs of one or more instances to recreate. This can be a full URL or a
  /// partial URL, such as zones/[ZONE]/instances/[INSTANCE_NAME].
  core.List<core.String> instances;

  RegionInstanceGroupManagersRecreateRequest();

  RegionInstanceGroupManagersRecreateRequest.fromJson(core.Map _json) {
    if (_json.containsKey("instances")) {
      instances = _json["instances"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (instances != null) {
      _json["instances"] = instances;
    }
    return _json;
  }
}

class RegionInstanceGroupManagersSetTargetPoolsRequest {
  /// Fingerprint of the target pools information, which is a hash of the
  /// contents. This field is used for optimistic locking when you update the
  /// target pool entries. This field is optional.
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes {
    return convert.BASE64.decode(fingerprint);
  }

  void set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.BASE64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  /// The URL of all TargetPool resources to which instances in the
  /// instanceGroup field are added. The target pools automatically apply to all
  /// of the instances in the managed instance group.
  core.List<core.String> targetPools;

  RegionInstanceGroupManagersSetTargetPoolsRequest();

  RegionInstanceGroupManagersSetTargetPoolsRequest.fromJson(core.Map _json) {
    if (_json.containsKey("fingerprint")) {
      fingerprint = _json["fingerprint"];
    }
    if (_json.containsKey("targetPools")) {
      targetPools = _json["targetPools"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (fingerprint != null) {
      _json["fingerprint"] = fingerprint;
    }
    if (targetPools != null) {
      _json["targetPools"] = targetPools;
    }
    return _json;
  }
}

class RegionInstanceGroupManagersSetTemplateRequest {
  /// URL of the InstanceTemplate resource from which all new instances will be
  /// created.
  core.String instanceTemplate;

  RegionInstanceGroupManagersSetTemplateRequest();

  RegionInstanceGroupManagersSetTemplateRequest.fromJson(core.Map _json) {
    if (_json.containsKey("instanceTemplate")) {
      instanceTemplate = _json["instanceTemplate"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (instanceTemplate != null) {
      _json["instanceTemplate"] = instanceTemplate;
    }
    return _json;
  }
}

class RegionInstanceGroupsListInstancesWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  RegionInstanceGroupsListInstancesWarningData();

  RegionInstanceGroupsListInstancesWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class RegionInstanceGroupsListInstancesWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<RegionInstanceGroupsListInstancesWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  RegionInstanceGroupsListInstancesWarning();

  RegionInstanceGroupsListInstancesWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) =>
              new RegionInstanceGroupsListInstancesWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class RegionInstanceGroupsListInstances {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of InstanceWithNamedPorts resources.
  core.List<InstanceWithNamedPorts> items;

  /// The resource type.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  RegionInstanceGroupsListInstancesWarning warning;

  RegionInstanceGroupsListInstances();

  RegionInstanceGroupsListInstances.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = _json["items"]
          .map((value) => new InstanceWithNamedPorts.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new RegionInstanceGroupsListInstancesWarning.fromJson(
          _json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class RegionInstanceGroupsListInstancesRequest {
  /// Instances in which state should be returned. Valid options are: 'ALL',
  /// 'RUNNING'. By default, it lists all instances.
  /// Possible string values are:
  /// - "ALL"
  /// - "RUNNING"
  core.String instanceState;

  /// Name of port user is interested in. It is optional. If it is set, only
  /// information about this ports will be returned. If it is not set, all the
  /// named ports will be returned. Always lists all instances.
  core.String portName;

  RegionInstanceGroupsListInstancesRequest();

  RegionInstanceGroupsListInstancesRequest.fromJson(core.Map _json) {
    if (_json.containsKey("instanceState")) {
      instanceState = _json["instanceState"];
    }
    if (_json.containsKey("portName")) {
      portName = _json["portName"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (instanceState != null) {
      _json["instanceState"] = instanceState;
    }
    if (portName != null) {
      _json["portName"] = portName;
    }
    return _json;
  }
}

class RegionInstanceGroupsSetNamedPortsRequest {
  /// The fingerprint of the named ports information for this instance group.
  /// Use this optional property to prevent conflicts when multiple users change
  /// the named ports settings concurrently. Obtain the fingerprint with the
  /// instanceGroups.get method. Then, include the fingerprint in your request
  /// to ensure that you do not overwrite changes that were applied from another
  /// concurrent request.
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes {
    return convert.BASE64.decode(fingerprint);
  }

  void set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.BASE64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  /// The list of named ports to set for this instance group.
  core.List<NamedPort> namedPorts;

  RegionInstanceGroupsSetNamedPortsRequest();

  RegionInstanceGroupsSetNamedPortsRequest.fromJson(core.Map _json) {
    if (_json.containsKey("fingerprint")) {
      fingerprint = _json["fingerprint"];
    }
    if (_json.containsKey("namedPorts")) {
      namedPorts = _json["namedPorts"]
          .map((value) => new NamedPort.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (fingerprint != null) {
      _json["fingerprint"] = fingerprint;
    }
    if (namedPorts != null) {
      _json["namedPorts"] =
          namedPorts.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

class RegionListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  RegionListWarningData();

  RegionListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class RegionListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<RegionListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  RegionListWarning();

  RegionListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new RegionListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of region resources.
class RegionList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Region resources.
  core.List<Region> items;

  /// [Output Only] Type of resource. Always compute#regionList for lists of
  /// regions.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  RegionListWarning warning;

  RegionList();

  RegionList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items =
          _json["items"].map((value) => new Region.fromJson(value)).toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new RegionListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// Commitment for a particular resource (a Commitment is composed of one or
/// more of these).
class ResourceCommitment {
  /// The amount of the resource purchased (in a type-dependent unit, such as
  /// bytes). For vCPUs, this can just be an integer. For memory, this must be
  /// provided in MB. Memory must be a multiple of 256 MB, with up to 6.5GB of
  /// memory per every vCPU.
  core.String amount;

  /// Type of resource for which this commitment applies. Possible values are
  /// VCPU and MEMORY
  /// Possible string values are:
  /// - "MEMORY"
  /// - "UNSPECIFIED"
  /// - "VCPU"
  core.String type;

  ResourceCommitment();

  ResourceCommitment.fromJson(core.Map _json) {
    if (_json.containsKey("amount")) {
      amount = _json["amount"];
    }
    if (_json.containsKey("type")) {
      type = _json["type"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (amount != null) {
      _json["amount"] = amount;
    }
    if (type != null) {
      _json["type"] = type;
    }
    return _json;
  }
}

class ResourceGroupReference {
  /// A URI referencing one of the instance groups listed in the backend
  /// service.
  core.String group;

  ResourceGroupReference();

  ResourceGroupReference.fromJson(core.Map _json) {
    if (_json.containsKey("group")) {
      group = _json["group"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (group != null) {
      _json["group"] = group;
    }
    return _json;
  }
}

class RouteWarningsData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  RouteWarningsData();

  RouteWarningsData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

class RouteWarnings {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<RouteWarningsData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  RouteWarnings();

  RouteWarnings.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new RouteWarningsData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Represents a Route resource. A route specifies how certain packets should be
/// handled by the network. Routes are associated with instances by tags and the
/// set of routes for a particular instance is called its routing table.
///
/// For each packet leaving an instance, the system searches that instance's
/// routing table for a single best matching route. Routes match packets by
/// destination IP address, preferring smaller or more specific ranges over
/// larger ones. If there is a tie, the system selects the route with the
/// smallest priority value. If there is still a tie, it uses the layer three
/// and four packet headers to select just one of the remaining matching routes.
/// The packet is then forwarded as specified by the nextHop field of the
/// winning route - either to another instance destination, an instance gateway,
/// or a Google Compute Engine-operated gateway.
///
/// Packets that do not match any route in the sending instance's routing table
/// are dropped. (== resource_for beta.routes ==) (== resource_for v1.routes ==)
class Route {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// The destination range of outgoing packets that this route applies to. Only
  /// IPv4 is supported.
  core.String destRange;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of this resource. Always compute#routes for Route
  /// resources.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
  /// be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// Fully-qualified URL of the network that this route applies to.
  core.String network;

  /// The URL to a gateway that should handle matching packets. You can only
  /// specify the internet gateway using a full or partial valid URL:
  /// projects/<project-id>/global/gateways/default-internet-gateway
  core.String nextHopGateway;

  /// The URL to an instance that should handle matching packets. You can
  /// specify this as a full or partial URL. For example:
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone/instances/
  core.String nextHopInstance;

  /// The network IP address of an instance that should handle matching packets.
  /// Only IPv4 is supported.
  core.String nextHopIp;

  /// The URL of the local network if it should handle matching packets.
  core.String nextHopNetwork;

  /// [Output Only] The network peering name that should handle matching
  /// packets, which should conform to RFC1035.
  core.String nextHopPeering;

  /// The URL to a VpnTunnel that should handle matching packets.
  core.String nextHopVpnTunnel;

  /// The priority of this route. Priority is used to break ties in cases where
  /// there is more than one matching route of equal prefix length. In the case
  /// of two routes with equal prefix length, the one with the lowest-numbered
  /// priority value wins. Default value is 1000. Valid range is 0 through
  /// 65535.
  core.int priority;

  /// [Output Only] Server-defined fully-qualified URL for this resource.
  core.String selfLink;

  /// A list of instance tags to which this route applies.
  core.List<core.String> tags;

  /// [Output Only] If potential misconfigurations are detected for this route,
  /// this field will be populated with warning messages.
  core.List<RouteWarnings> warnings;

  Route();

  Route.fromJson(core.Map _json) {
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("destRange")) {
      destRange = _json["destRange"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("network")) {
      network = _json["network"];
    }
    if (_json.containsKey("nextHopGateway")) {
      nextHopGateway = _json["nextHopGateway"];
    }
    if (_json.containsKey("nextHopInstance")) {
      nextHopInstance = _json["nextHopInstance"];
    }
    if (_json.containsKey("nextHopIp")) {
      nextHopIp = _json["nextHopIp"];
    }
    if (_json.containsKey("nextHopNetwork")) {
      nextHopNetwork = _json["nextHopNetwork"];
    }
    if (_json.containsKey("nextHopPeering")) {
      nextHopPeering = _json["nextHopPeering"];
    }
    if (_json.containsKey("nextHopVpnTunnel")) {
      nextHopVpnTunnel = _json["nextHopVpnTunnel"];
    }
    if (_json.containsKey("priority")) {
      priority = _json["priority"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("tags")) {
      tags = _json["tags"];
    }
    if (_json.containsKey("warnings")) {
      warnings = _json["warnings"]
          .map((value) => new RouteWarnings.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (destRange != null) {
      _json["destRange"] = destRange;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (network != null) {
      _json["network"] = network;
    }
    if (nextHopGateway != null) {
      _json["nextHopGateway"] = nextHopGateway;
    }
    if (nextHopInstance != null) {
      _json["nextHopInstance"] = nextHopInstance;
    }
    if (nextHopIp != null) {
      _json["nextHopIp"] = nextHopIp;
    }
    if (nextHopNetwork != null) {
      _json["nextHopNetwork"] = nextHopNetwork;
    }
    if (nextHopPeering != null) {
      _json["nextHopPeering"] = nextHopPeering;
    }
    if (nextHopVpnTunnel != null) {
      _json["nextHopVpnTunnel"] = nextHopVpnTunnel;
    }
    if (priority != null) {
      _json["priority"] = priority;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (tags != null) {
      _json["tags"] = tags;
    }
    if (warnings != null) {
      _json["warnings"] = warnings.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

class RouteListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  RouteListWarningData();

  RouteListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class RouteListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<RouteListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  RouteListWarning();

  RouteListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new RouteListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of Route resources.
class RouteList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Route resources.
  core.List<Route> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  RouteListWarning warning;

  RouteList();

  RouteList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = _json["items"].map((value) => new Route.fromJson(value)).toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new RouteListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// Router resource.
class Router {
  /// BGP information specific to this router.
  RouterBgp bgp;

  /// BGP information that needs to be configured into the routing stack to
  /// establish the BGP peering. It must specify peer ASN and either interface
  /// name, IP, or peer IP. Please refer to RFC4273.
  core.List<RouterBgpPeer> bgpPeers;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// Router interfaces. Each interface requires either one linked resource
  /// (e.g. linkedVpnTunnel), or IP address and IP address range (e.g. ipRange),
  /// or both.
  core.List<RouterInterface> interfaces;

  /// [Output Only] Type of resource. Always compute#router for routers.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
  /// be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// URI of the network to which this router belongs.
  core.String network;

  /// [Output Only] URI of the region where the router resides. You must specify
  /// this field as part of the HTTP request URL. It is not settable as a field
  /// in the request body.
  core.String region;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  Router();

  Router.fromJson(core.Map _json) {
    if (_json.containsKey("bgp")) {
      bgp = new RouterBgp.fromJson(_json["bgp"]);
    }
    if (_json.containsKey("bgpPeers")) {
      bgpPeers = _json["bgpPeers"]
          .map((value) => new RouterBgpPeer.fromJson(value))
          .toList();
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("interfaces")) {
      interfaces = _json["interfaces"]
          .map((value) => new RouterInterface.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("network")) {
      network = _json["network"];
    }
    if (_json.containsKey("region")) {
      region = _json["region"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (bgp != null) {
      _json["bgp"] = (bgp).toJson();
    }
    if (bgpPeers != null) {
      _json["bgpPeers"] = bgpPeers.map((value) => (value).toJson()).toList();
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (interfaces != null) {
      _json["interfaces"] =
          interfaces.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (network != null) {
      _json["network"] = network;
    }
    if (region != null) {
      _json["region"] = region;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    return _json;
  }
}

class RouterAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  RouterAggregatedListWarningData();

  RouterAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class RouterAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<RouterAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  RouterAggregatedListWarning();

  RouterAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new RouterAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of routers.
class RouterAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Router resources.
  core.Map<core.String, RoutersScopedList> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  RouterAggregatedListWarning warning;

  RouterAggregatedList();

  RouterAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items =
          commons.mapMap<core.Map<core.String, core.Object>, RoutersScopedList>(
              _json["items"],
              (core.Map<core.String, core.Object> item) =>
                  new RoutersScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new RouterAggregatedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] =
          commons.mapMap<RoutersScopedList, core.Map<core.String, core.Object>>(
              items, (RoutersScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class RouterBgp {
  /// Local BGP Autonomous System Number (ASN). Must be an RFC6996 private ASN,
  /// either 16-bit or 32-bit. The value will be fixed for this router resource.
  /// All VPN tunnels that link to this router will have the same local ASN.
  core.int asn;

  RouterBgp();

  RouterBgp.fromJson(core.Map _json) {
    if (_json.containsKey("asn")) {
      asn = _json["asn"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (asn != null) {
      _json["asn"] = asn;
    }
    return _json;
  }
}

class RouterBgpPeer {
  /// The priority of routes advertised to this BGP peer. In the case where
  /// there is more than one matching route of maximum length, the routes with
  /// lowest priority value win.
  core.int advertisedRoutePriority;

  /// Name of the interface the BGP peer is associated with.
  core.String interfaceName;

  /// IP address of the interface inside Google Cloud Platform. Only IPv4 is
  /// supported.
  core.String ipAddress;

  /// Name of this BGP peer. The name must be 1-63 characters long and comply
  /// with RFC1035.
  core.String name;

  /// Peer BGP Autonomous System Number (ASN). For VPN use case, this value can
  /// be different for every tunnel.
  core.int peerAsn;

  /// IP address of the BGP interface outside Google cloud. Only IPv4 is
  /// supported.
  core.String peerIpAddress;

  RouterBgpPeer();

  RouterBgpPeer.fromJson(core.Map _json) {
    if (_json.containsKey("advertisedRoutePriority")) {
      advertisedRoutePriority = _json["advertisedRoutePriority"];
    }
    if (_json.containsKey("interfaceName")) {
      interfaceName = _json["interfaceName"];
    }
    if (_json.containsKey("ipAddress")) {
      ipAddress = _json["ipAddress"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("peerAsn")) {
      peerAsn = _json["peerAsn"];
    }
    if (_json.containsKey("peerIpAddress")) {
      peerIpAddress = _json["peerIpAddress"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (advertisedRoutePriority != null) {
      _json["advertisedRoutePriority"] = advertisedRoutePriority;
    }
    if (interfaceName != null) {
      _json["interfaceName"] = interfaceName;
    }
    if (ipAddress != null) {
      _json["ipAddress"] = ipAddress;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (peerAsn != null) {
      _json["peerAsn"] = peerAsn;
    }
    if (peerIpAddress != null) {
      _json["peerIpAddress"] = peerIpAddress;
    }
    return _json;
  }
}

class RouterInterface {
  /// IP address and range of the interface. The IP range must be in the RFC3927
  /// link-local IP space. The value must be a CIDR-formatted string, for
  /// example: 169.254.0.1/30. NOTE: Do not truncate the address as it
  /// represents the IP address of the interface.
  core.String ipRange;

  /// URI of the linked interconnect attachment. It must be in the same region
  /// as the router. Each interface can have at most one linked resource and it
  /// could either be a VPN Tunnel or an interconnect attachment.
  core.String linkedInterconnectAttachment;

  /// URI of the linked VPN tunnel. It must be in the same region as the router.
  /// Each interface can have at most one linked resource and it could either be
  /// a VPN Tunnel or an interconnect attachment.
  core.String linkedVpnTunnel;

  /// Name of this interface entry. The name must be 1-63 characters long and
  /// comply with RFC1035.
  core.String name;

  RouterInterface();

  RouterInterface.fromJson(core.Map _json) {
    if (_json.containsKey("ipRange")) {
      ipRange = _json["ipRange"];
    }
    if (_json.containsKey("linkedInterconnectAttachment")) {
      linkedInterconnectAttachment = _json["linkedInterconnectAttachment"];
    }
    if (_json.containsKey("linkedVpnTunnel")) {
      linkedVpnTunnel = _json["linkedVpnTunnel"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (ipRange != null) {
      _json["ipRange"] = ipRange;
    }
    if (linkedInterconnectAttachment != null) {
      _json["linkedInterconnectAttachment"] = linkedInterconnectAttachment;
    }
    if (linkedVpnTunnel != null) {
      _json["linkedVpnTunnel"] = linkedVpnTunnel;
    }
    if (name != null) {
      _json["name"] = name;
    }
    return _json;
  }
}

class RouterListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  RouterListWarningData();

  RouterListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class RouterListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<RouterListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  RouterListWarning();

  RouterListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new RouterListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of Router resources.
class RouterList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Router resources.
  core.List<Router> items;

  /// [Output Only] Type of resource. Always compute#router for routers.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  RouterListWarning warning;

  RouterList();

  RouterList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items =
          _json["items"].map((value) => new Router.fromJson(value)).toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new RouterListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class RouterStatus {
  /// Best routes for this router's network.
  core.List<Route> bestRoutes;

  /// Best routes learned by this router.
  core.List<Route> bestRoutesForRouter;
  core.List<RouterStatusBgpPeerStatus> bgpPeerStatus;

  /// URI of the network to which this router belongs.
  core.String network;

  RouterStatus();

  RouterStatus.fromJson(core.Map _json) {
    if (_json.containsKey("bestRoutes")) {
      bestRoutes = _json["bestRoutes"]
          .map((value) => new Route.fromJson(value))
          .toList();
    }
    if (_json.containsKey("bestRoutesForRouter")) {
      bestRoutesForRouter = _json["bestRoutesForRouter"]
          .map((value) => new Route.fromJson(value))
          .toList();
    }
    if (_json.containsKey("bgpPeerStatus")) {
      bgpPeerStatus = _json["bgpPeerStatus"]
          .map((value) => new RouterStatusBgpPeerStatus.fromJson(value))
          .toList();
    }
    if (_json.containsKey("network")) {
      network = _json["network"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (bestRoutes != null) {
      _json["bestRoutes"] =
          bestRoutes.map((value) => (value).toJson()).toList();
    }
    if (bestRoutesForRouter != null) {
      _json["bestRoutesForRouter"] =
          bestRoutesForRouter.map((value) => (value).toJson()).toList();
    }
    if (bgpPeerStatus != null) {
      _json["bgpPeerStatus"] =
          bgpPeerStatus.map((value) => (value).toJson()).toList();
    }
    if (network != null) {
      _json["network"] = network;
    }
    return _json;
  }
}

class RouterStatusBgpPeerStatus {
  /// Routes that were advertised to the remote BGP peer
  core.List<Route> advertisedRoutes;

  /// IP address of the local BGP interface.
  core.String ipAddress;

  /// URL of the VPN tunnel that this BGP peer controls.
  core.String linkedVpnTunnel;

  /// Name of this BGP peer. Unique within the Routers resource.
  core.String name;

  /// Number of routes learned from the remote BGP Peer.
  core.int numLearnedRoutes;

  /// IP address of the remote BGP interface.
  core.String peerIpAddress;

  /// BGP state as specified in RFC1771.
  core.String state;

  /// Status of the BGP peer: {UP, DOWN}
  /// Possible string values are:
  /// - "DOWN"
  /// - "UNKNOWN"
  /// - "UP"
  core.String status;

  /// Time this session has been up. Format: 14 years, 51 weeks, 6 days, 23
  /// hours, 59 minutes, 59 seconds
  core.String uptime;

  /// Time this session has been up, in seconds. Format: 145
  core.String uptimeSeconds;

  RouterStatusBgpPeerStatus();

  RouterStatusBgpPeerStatus.fromJson(core.Map _json) {
    if (_json.containsKey("advertisedRoutes")) {
      advertisedRoutes = _json["advertisedRoutes"]
          .map((value) => new Route.fromJson(value))
          .toList();
    }
    if (_json.containsKey("ipAddress")) {
      ipAddress = _json["ipAddress"];
    }
    if (_json.containsKey("linkedVpnTunnel")) {
      linkedVpnTunnel = _json["linkedVpnTunnel"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("numLearnedRoutes")) {
      numLearnedRoutes = _json["numLearnedRoutes"];
    }
    if (_json.containsKey("peerIpAddress")) {
      peerIpAddress = _json["peerIpAddress"];
    }
    if (_json.containsKey("state")) {
      state = _json["state"];
    }
    if (_json.containsKey("status")) {
      status = _json["status"];
    }
    if (_json.containsKey("uptime")) {
      uptime = _json["uptime"];
    }
    if (_json.containsKey("uptimeSeconds")) {
      uptimeSeconds = _json["uptimeSeconds"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (advertisedRoutes != null) {
      _json["advertisedRoutes"] =
          advertisedRoutes.map((value) => (value).toJson()).toList();
    }
    if (ipAddress != null) {
      _json["ipAddress"] = ipAddress;
    }
    if (linkedVpnTunnel != null) {
      _json["linkedVpnTunnel"] = linkedVpnTunnel;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (numLearnedRoutes != null) {
      _json["numLearnedRoutes"] = numLearnedRoutes;
    }
    if (peerIpAddress != null) {
      _json["peerIpAddress"] = peerIpAddress;
    }
    if (state != null) {
      _json["state"] = state;
    }
    if (status != null) {
      _json["status"] = status;
    }
    if (uptime != null) {
      _json["uptime"] = uptime;
    }
    if (uptimeSeconds != null) {
      _json["uptimeSeconds"] = uptimeSeconds;
    }
    return _json;
  }
}

class RouterStatusResponse {
  /// Type of resource.
  core.String kind;
  RouterStatus result;

  RouterStatusResponse();

  RouterStatusResponse.fromJson(core.Map _json) {
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("result")) {
      result = new RouterStatus.fromJson(_json["result"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (result != null) {
      _json["result"] = (result).toJson();
    }
    return _json;
  }
}

class RoutersPreviewResponse {
  /// Preview of given router.
  Router resource;

  RoutersPreviewResponse();

  RoutersPreviewResponse.fromJson(core.Map _json) {
    if (_json.containsKey("resource")) {
      resource = new Router.fromJson(_json["resource"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (resource != null) {
      _json["resource"] = (resource).toJson();
    }
    return _json;
  }
}

class RoutersScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  RoutersScopedListWarningData();

  RoutersScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// Informational warning which replaces the list of routers when the list is
/// empty.
class RoutersScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<RoutersScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  RoutersScopedListWarning();

  RoutersScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new RoutersScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class RoutersScopedList {
  /// List of routers contained in this scope.
  core.List<Router> routers;

  /// Informational warning which replaces the list of routers when the list is
  /// empty.
  RoutersScopedListWarning warning;

  RoutersScopedList();

  RoutersScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("routers")) {
      routers =
          _json["routers"].map((value) => new Router.fromJson(value)).toList();
    }
    if (_json.containsKey("warning")) {
      warning = new RoutersScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (routers != null) {
      _json["routers"] = routers.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class SSLHealthCheck {
  /// The TCP port number for the health check request. The default value is
  /// 443. Valid values are 1 through 65535.
  core.int port;

  /// Port name as defined in InstanceGroup#NamedPort#name. If both port and
  /// port_name are defined, port takes precedence.
  core.String portName;

  /// Specifies the type of proxy header to append before sending data to the
  /// backend, either NONE or PROXY_V1. The default is NONE.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String proxyHeader;

  /// The application data to send once the SSL connection has been established
  /// (default value is empty). If both request and response are empty, the
  /// connection establishment alone will indicate health. The request data can
  /// only be ASCII.
  core.String request;

  /// The bytes to match against the beginning of the response data. If left
  /// empty (the default value), any response will indicate health. The response
  /// data can only be ASCII.
  core.String response;

  SSLHealthCheck();

  SSLHealthCheck.fromJson(core.Map _json) {
    if (_json.containsKey("port")) {
      port = _json["port"];
    }
    if (_json.containsKey("portName")) {
      portName = _json["portName"];
    }
    if (_json.containsKey("proxyHeader")) {
      proxyHeader = _json["proxyHeader"];
    }
    if (_json.containsKey("request")) {
      request = _json["request"];
    }
    if (_json.containsKey("response")) {
      response = _json["response"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (port != null) {
      _json["port"] = port;
    }
    if (portName != null) {
      _json["portName"] = portName;
    }
    if (proxyHeader != null) {
      _json["proxyHeader"] = proxyHeader;
    }
    if (request != null) {
      _json["request"] = request;
    }
    if (response != null) {
      _json["response"] = response;
    }
    return _json;
  }
}

/// Sets the scheduling options for an Instance.
class Scheduling {
  /// Specifies whether the instance should be automatically restarted if it is
  /// terminated by Compute Engine (not terminated by a user). You can only set
  /// the automatic restart option for standard instances. Preemptible instances
  /// cannot be automatically restarted.
  ///
  /// By default, this is set to true so an instance is automatically restarted
  /// if it is terminated by Compute Engine.
  core.bool automaticRestart;

  /// Defines the maintenance behavior for this instance. For standard
  /// instances, the default behavior is MIGRATE. For preemptible instances, the
  /// default and only possible behavior is TERMINATE. For more information, see
  /// Setting Instance Scheduling Options.
  /// Possible string values are:
  /// - "MIGRATE"
  /// - "TERMINATE"
  core.String onHostMaintenance;

  /// Defines whether the instance is preemptible. This can only be set during
  /// instance creation, it cannot be set or changed after the instance has been
  /// created.
  core.bool preemptible;

  Scheduling();

  Scheduling.fromJson(core.Map _json) {
    if (_json.containsKey("automaticRestart")) {
      automaticRestart = _json["automaticRestart"];
    }
    if (_json.containsKey("onHostMaintenance")) {
      onHostMaintenance = _json["onHostMaintenance"];
    }
    if (_json.containsKey("preemptible")) {
      preemptible = _json["preemptible"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (automaticRestart != null) {
      _json["automaticRestart"] = automaticRestart;
    }
    if (onHostMaintenance != null) {
      _json["onHostMaintenance"] = onHostMaintenance;
    }
    if (preemptible != null) {
      _json["preemptible"] = preemptible;
    }
    return _json;
  }
}

/// An instance's serial console output.
class SerialPortOutput {
  /// [Output Only] The contents of the console output.
  core.String contents;

  /// [Output Only] Type of the resource. Always compute#serialPortOutput for
  /// serial port output.
  core.String kind;

  /// [Output Only] The position of the next byte of content from the serial
  /// console output. Use this value in the next request as the start parameter.
  core.String next;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// The starting byte position of the output that was returned. This should
  /// match the start parameter sent with the request. If the serial console
  /// output exceeds the size of the buffer, older output will be overwritten by
  /// newer content and the start values will be mismatched.
  core.String start;

  SerialPortOutput();

  SerialPortOutput.fromJson(core.Map _json) {
    if (_json.containsKey("contents")) {
      contents = _json["contents"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("next")) {
      next = _json["next"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("start")) {
      start = _json["start"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (contents != null) {
      _json["contents"] = contents;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (next != null) {
      _json["next"] = next;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (start != null) {
      _json["start"] = start;
    }
    return _json;
  }
}

/// A service account.
class ServiceAccount {
  /// Email address of the service account.
  core.String email;

  /// The list of scopes to be made available for this service account.
  core.List<core.String> scopes;

  ServiceAccount();

  ServiceAccount.fromJson(core.Map _json) {
    if (_json.containsKey("email")) {
      email = _json["email"];
    }
    if (_json.containsKey("scopes")) {
      scopes = _json["scopes"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (email != null) {
      _json["email"] = email;
    }
    if (scopes != null) {
      _json["scopes"] = scopes;
    }
    return _json;
  }
}

/// A persistent disk snapshot resource. (== resource_for beta.snapshots ==) (==
/// resource_for v1.snapshots ==)
class Snapshot {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] Size of the snapshot, specified in GB.
  core.String diskSizeGb;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#snapshot for Snapshot
  /// resources.
  core.String kind;

  /// A fingerprint for the labels being applied to this snapshot, which is
  /// essentially a hash of the labels set used for optimistic locking. The
  /// fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update labels. You must always provide an
  /// up-to-date fingerprint hash in order to update or change labels.
  ///
  /// To see the latest fingerprint, make a get() request to retrieve a
  /// snapshot.
  core.String labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes {
    return convert.BASE64.decode(labelFingerprint);
  }

  void set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.BASE64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  /// Labels to apply to this snapshot. These can be later modified by the
  /// setLabels method. Label values may be empty.
  core.Map<core.String, core.String> labels;

  /// [Output Only] A list of public visible licenses that apply to this
  /// snapshot. This can be because the original image had licenses attached
  /// (such as a Windows image).
  core.List<core.String> licenses;

  /// Name of the resource; provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
  /// be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// Encrypts the snapshot using a customer-supplied encryption key.
  ///
  /// After you encrypt a snapshot using a customer-supplied key, you must
  /// provide the same key if you use the image later For example, you must
  /// provide the encryption key when you create a disk from the encrypted
  /// snapshot in a future request.
  ///
  /// Customer-supplied encryption keys do not protect access to metadata of the
  /// disk.
  ///
  /// If you do not provide an encryption key when creating the snapshot, then
  /// the snapshot will be encrypted using an automatically generated key and
  /// you do not need to provide a key to use the snapshot later.
  CustomerEncryptionKey snapshotEncryptionKey;

  /// [Output Only] The source disk used to create this snapshot.
  core.String sourceDisk;

  /// The customer-supplied encryption key of the source disk. Required if the
  /// source disk is protected by a customer-supplied encryption key.
  CustomerEncryptionKey sourceDiskEncryptionKey;

  /// [Output Only] The ID value of the disk used to create this snapshot. This
  /// value may be used to determine whether the snapshot was taken from the
  /// current or a previous instance of a given disk name.
  core.String sourceDiskId;

  /// [Output Only] The status of the snapshot. This can be CREATING, DELETING,
  /// FAILED, READY, or UPLOADING.
  /// Possible string values are:
  /// - "CREATING"
  /// - "DELETING"
  /// - "FAILED"
  /// - "READY"
  /// - "UPLOADING"
  core.String status;

  /// [Output Only] A size of the storage used by the snapshot. As snapshots
  /// share storage, this number is expected to change with snapshot
  /// creation/deletion.
  core.String storageBytes;

  /// [Output Only] An indicator whether storageBytes is in a stable state or it
  /// is being adjusted as a result of shared storage reallocation. This status
  /// can either be UPDATING, meaning the size of the snapshot is being updated,
  /// or UP_TO_DATE, meaning the size of the snapshot is up-to-date.
  /// Possible string values are:
  /// - "UPDATING"
  /// - "UP_TO_DATE"
  core.String storageBytesStatus;

  Snapshot();

  Snapshot.fromJson(core.Map _json) {
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("diskSizeGb")) {
      diskSizeGb = _json["diskSizeGb"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("labelFingerprint")) {
      labelFingerprint = _json["labelFingerprint"];
    }
    if (_json.containsKey("labels")) {
      labels = _json["labels"];
    }
    if (_json.containsKey("licenses")) {
      licenses = _json["licenses"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("snapshotEncryptionKey")) {
      snapshotEncryptionKey =
          new CustomerEncryptionKey.fromJson(_json["snapshotEncryptionKey"]);
    }
    if (_json.containsKey("sourceDisk")) {
      sourceDisk = _json["sourceDisk"];
    }
    if (_json.containsKey("sourceDiskEncryptionKey")) {
      sourceDiskEncryptionKey =
          new CustomerEncryptionKey.fromJson(_json["sourceDiskEncryptionKey"]);
    }
    if (_json.containsKey("sourceDiskId")) {
      sourceDiskId = _json["sourceDiskId"];
    }
    if (_json.containsKey("status")) {
      status = _json["status"];
    }
    if (_json.containsKey("storageBytes")) {
      storageBytes = _json["storageBytes"];
    }
    if (_json.containsKey("storageBytesStatus")) {
      storageBytesStatus = _json["storageBytesStatus"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (diskSizeGb != null) {
      _json["diskSizeGb"] = diskSizeGb;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (labelFingerprint != null) {
      _json["labelFingerprint"] = labelFingerprint;
    }
    if (labels != null) {
      _json["labels"] = labels;
    }
    if (licenses != null) {
      _json["licenses"] = licenses;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (snapshotEncryptionKey != null) {
      _json["snapshotEncryptionKey"] = (snapshotEncryptionKey).toJson();
    }
    if (sourceDisk != null) {
      _json["sourceDisk"] = sourceDisk;
    }
    if (sourceDiskEncryptionKey != null) {
      _json["sourceDiskEncryptionKey"] = (sourceDiskEncryptionKey).toJson();
    }
    if (sourceDiskId != null) {
      _json["sourceDiskId"] = sourceDiskId;
    }
    if (status != null) {
      _json["status"] = status;
    }
    if (storageBytes != null) {
      _json["storageBytes"] = storageBytes;
    }
    if (storageBytesStatus != null) {
      _json["storageBytesStatus"] = storageBytesStatus;
    }
    return _json;
  }
}

class SnapshotListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  SnapshotListWarningData();

  SnapshotListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class SnapshotListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<SnapshotListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  SnapshotListWarning();

  SnapshotListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new SnapshotListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of Snapshot resources.
class SnapshotList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Snapshot resources.
  core.List<Snapshot> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  SnapshotListWarning warning;

  SnapshotList();

  SnapshotList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items =
          _json["items"].map((value) => new Snapshot.fromJson(value)).toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new SnapshotListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// An SslCertificate resource. This resource provides a mechanism to upload an
/// SSL key and certificate to the load balancer to serve secure connections
/// from the user. (== resource_for beta.sslCertificates ==) (== resource_for
/// v1.sslCertificates ==)
class SslCertificate {
  /// A local certificate file. The certificate must be in PEM format. The
  /// certificate chain must be no greater than 5 certs long. The chain must
  /// include at least one intermediate cert.
  core.String certificate;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#sslCertificate for SSL
  /// certificates.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
  /// be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// A write-only private key in PEM format. Only insert requests will include
  /// this field.
  core.String privateKey;

  /// [Output only] Server-defined URL for the resource.
  core.String selfLink;

  SslCertificate();

  SslCertificate.fromJson(core.Map _json) {
    if (_json.containsKey("certificate")) {
      certificate = _json["certificate"];
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("privateKey")) {
      privateKey = _json["privateKey"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (certificate != null) {
      _json["certificate"] = certificate;
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (privateKey != null) {
      _json["privateKey"] = privateKey;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    return _json;
  }
}

class SslCertificateListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  SslCertificateListWarningData();

  SslCertificateListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class SslCertificateListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<SslCertificateListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  SslCertificateListWarning();

  SslCertificateListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new SslCertificateListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of SslCertificate resources.
class SslCertificateList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of SslCertificate resources.
  core.List<SslCertificate> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  SslCertificateListWarning warning;

  SslCertificateList();

  SslCertificateList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = _json["items"]
          .map((value) => new SslCertificate.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new SslCertificateListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// A Subnetwork resource. (== resource_for beta.subnetworks ==) (==
/// resource_for v1.subnetworks ==)
class Subnetwork {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource. This field can be set only at resource creation time.
  core.String description;

  /// [Output Only] The gateway address for default routes to reach destination
  /// addresses outside this subnetwork.
  core.String gatewayAddress;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// The range of internal addresses that are owned by this subnetwork. Provide
  /// this property when you create the subnetwork. For example, 10.0.0.0/8 or
  /// 192.168.0.0/16. Ranges must be unique and non-overlapping within a
  /// network. Only IPv4 is supported. This field can be set only at resource
  /// creation time.
  core.String ipCidrRange;

  /// [Output Only] Type of the resource. Always compute#subnetwork for
  /// Subnetwork resources.
  core.String kind;

  /// The name of the resource, provided by the client when initially creating
  /// the resource. The name must be 1-63 characters long, and comply with
  /// RFC1035. Specifically, the name must be 1-63 characters long and match the
  /// regular expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first
  /// character must be a lowercase letter, and all following characters must be
  /// a dash, lowercase letter, or digit, except the last character, which
  /// cannot be a dash.
  core.String name;

  /// The URL of the network to which this subnetwork belongs, provided by the
  /// client when initially creating the subnetwork. Only networks that are in
  /// the distributed mode can have subnetworks. This field can be set only at
  /// resource creation time.
  core.String network;

  /// Whether the VMs in this subnet can access Google services without assigned
  /// external IP addresses. This field can be both set at resource creation
  /// time and updated using setPrivateIpGoogleAccess.
  core.bool privateIpGoogleAccess;

  /// URL of the region where the Subnetwork resides. This field can be set only
  /// at resource creation time.
  core.String region;

  /// An array of configurations for secondary IP ranges for VM instances
  /// contained in this subnetwork. The primary IP of such VM must belong to the
  /// primary ipCidrRange of the subnetwork. The alias IPs may belong to either
  /// primary or secondary ranges.
  core.List<SubnetworkSecondaryRange> secondaryIpRanges;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  Subnetwork();

  Subnetwork.fromJson(core.Map _json) {
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("gatewayAddress")) {
      gatewayAddress = _json["gatewayAddress"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("ipCidrRange")) {
      ipCidrRange = _json["ipCidrRange"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("network")) {
      network = _json["network"];
    }
    if (_json.containsKey("privateIpGoogleAccess")) {
      privateIpGoogleAccess = _json["privateIpGoogleAccess"];
    }
    if (_json.containsKey("region")) {
      region = _json["region"];
    }
    if (_json.containsKey("secondaryIpRanges")) {
      secondaryIpRanges = _json["secondaryIpRanges"]
          .map((value) => new SubnetworkSecondaryRange.fromJson(value))
          .toList();
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (gatewayAddress != null) {
      _json["gatewayAddress"] = gatewayAddress;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (ipCidrRange != null) {
      _json["ipCidrRange"] = ipCidrRange;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (network != null) {
      _json["network"] = network;
    }
    if (privateIpGoogleAccess != null) {
      _json["privateIpGoogleAccess"] = privateIpGoogleAccess;
    }
    if (region != null) {
      _json["region"] = region;
    }
    if (secondaryIpRanges != null) {
      _json["secondaryIpRanges"] =
          secondaryIpRanges.map((value) => (value).toJson()).toList();
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    return _json;
  }
}

class SubnetworkAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  SubnetworkAggregatedListWarningData();

  SubnetworkAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class SubnetworkAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<SubnetworkAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  SubnetworkAggregatedListWarning();

  SubnetworkAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) =>
              new SubnetworkAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class SubnetworkAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of SubnetworksScopedList resources.
  core.Map<core.String, SubnetworksScopedList> items;

  /// [Output Only] Type of resource. Always compute#subnetworkAggregatedList
  /// for aggregated lists of subnetworks.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  SubnetworkAggregatedListWarning warning;

  SubnetworkAggregatedList();

  SubnetworkAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons
          .mapMap<core.Map<core.String, core.Object>, SubnetworksScopedList>(
              _json["items"],
              (core.Map<core.String, core.Object> item) =>
                  new SubnetworksScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new SubnetworkAggregatedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = commons
          .mapMap<SubnetworksScopedList, core.Map<core.String, core.Object>>(
              items, (SubnetworksScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class SubnetworkListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  SubnetworkListWarningData();

  SubnetworkListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class SubnetworkListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<SubnetworkListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  SubnetworkListWarning();

  SubnetworkListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new SubnetworkListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of Subnetwork resources.
class SubnetworkList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Subnetwork resources.
  core.List<Subnetwork> items;

  /// [Output Only] Type of resource. Always compute#subnetworkList for lists of
  /// subnetworks.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  SubnetworkListWarning warning;

  SubnetworkList();

  SubnetworkList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = _json["items"]
          .map((value) => new Subnetwork.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new SubnetworkListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// Represents a secondary IP range of a subnetwork.
class SubnetworkSecondaryRange {
  /// The range of IP addresses belonging to this subnetwork secondary range.
  /// Provide this property when you create the subnetwork. Ranges must be
  /// unique and non-overlapping with all primary and secondary IP ranges within
  /// a network. Only IPv4 is supported.
  core.String ipCidrRange;

  /// The name associated with this subnetwork secondary range, used when adding
  /// an alias IP range to a VM instance. The name must be 1-63 characters long,
  /// and comply with RFC1035. The name must be unique within the subnetwork.
  core.String rangeName;

  SubnetworkSecondaryRange();

  SubnetworkSecondaryRange.fromJson(core.Map _json) {
    if (_json.containsKey("ipCidrRange")) {
      ipCidrRange = _json["ipCidrRange"];
    }
    if (_json.containsKey("rangeName")) {
      rangeName = _json["rangeName"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (ipCidrRange != null) {
      _json["ipCidrRange"] = ipCidrRange;
    }
    if (rangeName != null) {
      _json["rangeName"] = rangeName;
    }
    return _json;
  }
}

class SubnetworksExpandIpCidrRangeRequest {
  /// The IP (in CIDR format or netmask) of internal addresses that are legal on
  /// this Subnetwork. This range should be disjoint from other subnetworks
  /// within this network. This range can only be larger than (i.e. a superset
  /// of) the range previously defined before the update.
  core.String ipCidrRange;

  SubnetworksExpandIpCidrRangeRequest();

  SubnetworksExpandIpCidrRangeRequest.fromJson(core.Map _json) {
    if (_json.containsKey("ipCidrRange")) {
      ipCidrRange = _json["ipCidrRange"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (ipCidrRange != null) {
      _json["ipCidrRange"] = ipCidrRange;
    }
    return _json;
  }
}

class SubnetworksScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  SubnetworksScopedListWarningData();

  SubnetworksScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// An informational warning that appears when the list of addresses is empty.
class SubnetworksScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<SubnetworksScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  SubnetworksScopedListWarning();

  SubnetworksScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new SubnetworksScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class SubnetworksScopedList {
  /// List of subnetworks contained in this scope.
  core.List<Subnetwork> subnetworks;

  /// An informational warning that appears when the list of addresses is empty.
  SubnetworksScopedListWarning warning;

  SubnetworksScopedList();

  SubnetworksScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("subnetworks")) {
      subnetworks = _json["subnetworks"]
          .map((value) => new Subnetwork.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning = new SubnetworksScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (subnetworks != null) {
      _json["subnetworks"] =
          subnetworks.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class SubnetworksSetPrivateIpGoogleAccessRequest {
  core.bool privateIpGoogleAccess;

  SubnetworksSetPrivateIpGoogleAccessRequest();

  SubnetworksSetPrivateIpGoogleAccessRequest.fromJson(core.Map _json) {
    if (_json.containsKey("privateIpGoogleAccess")) {
      privateIpGoogleAccess = _json["privateIpGoogleAccess"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (privateIpGoogleAccess != null) {
      _json["privateIpGoogleAccess"] = privateIpGoogleAccess;
    }
    return _json;
  }
}

class TCPHealthCheck {
  /// The TCP port number for the health check request. The default value is 80.
  /// Valid values are 1 through 65535.
  core.int port;

  /// Port name as defined in InstanceGroup#NamedPort#name. If both port and
  /// port_name are defined, port takes precedence.
  core.String portName;

  /// Specifies the type of proxy header to append before sending data to the
  /// backend, either NONE or PROXY_V1. The default is NONE.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String proxyHeader;

  /// The application data to send once the TCP connection has been established
  /// (default value is empty). If both request and response are empty, the
  /// connection establishment alone will indicate health. The request data can
  /// only be ASCII.
  core.String request;

  /// The bytes to match against the beginning of the response data. If left
  /// empty (the default value), any response will indicate health. The response
  /// data can only be ASCII.
  core.String response;

  TCPHealthCheck();

  TCPHealthCheck.fromJson(core.Map _json) {
    if (_json.containsKey("port")) {
      port = _json["port"];
    }
    if (_json.containsKey("portName")) {
      portName = _json["portName"];
    }
    if (_json.containsKey("proxyHeader")) {
      proxyHeader = _json["proxyHeader"];
    }
    if (_json.containsKey("request")) {
      request = _json["request"];
    }
    if (_json.containsKey("response")) {
      response = _json["response"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (port != null) {
      _json["port"] = port;
    }
    if (portName != null) {
      _json["portName"] = portName;
    }
    if (proxyHeader != null) {
      _json["proxyHeader"] = proxyHeader;
    }
    if (request != null) {
      _json["request"] = request;
    }
    if (response != null) {
      _json["response"] = response;
    }
    return _json;
  }
}

/// A set of instance tags.
class Tags {
  /// Specifies a fingerprint for this request, which is essentially a hash of
  /// the metadata's contents and used for optimistic locking. The fingerprint
  /// is initially generated by Compute Engine and changes after every request
  /// to modify or update metadata. You must always provide an up-to-date
  /// fingerprint hash in order to update or change metadata.
  ///
  /// To see the latest fingerprint, make get() request to the instance.
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes {
    return convert.BASE64.decode(fingerprint);
  }

  void set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.BASE64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  /// An array of tags. Each tag must be 1-63 characters long, and comply with
  /// RFC1035.
  core.List<core.String> items;

  Tags();

  Tags.fromJson(core.Map _json) {
    if (_json.containsKey("fingerprint")) {
      fingerprint = _json["fingerprint"];
    }
    if (_json.containsKey("items")) {
      items = _json["items"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (fingerprint != null) {
      _json["fingerprint"] = fingerprint;
    }
    if (items != null) {
      _json["items"] = items;
    }
    return _json;
  }
}

/// A TargetHttpProxy resource. This resource defines an HTTP proxy. (==
/// resource_for beta.targetHttpProxies ==) (== resource_for
/// v1.targetHttpProxies ==)
class TargetHttpProxy {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of resource. Always compute#targetHttpProxy for target
  /// HTTP proxies.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
  /// be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// URL to the UrlMap resource that defines the mapping from URL to the
  /// BackendService.
  core.String urlMap;

  TargetHttpProxy();

  TargetHttpProxy.fromJson(core.Map _json) {
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("urlMap")) {
      urlMap = _json["urlMap"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (urlMap != null) {
      _json["urlMap"] = urlMap;
    }
    return _json;
  }
}

class TargetHttpProxyListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  TargetHttpProxyListWarningData();

  TargetHttpProxyListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class TargetHttpProxyListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<TargetHttpProxyListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  TargetHttpProxyListWarning();

  TargetHttpProxyListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new TargetHttpProxyListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// A list of TargetHttpProxy resources.
class TargetHttpProxyList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of TargetHttpProxy resources.
  core.List<TargetHttpProxy> items;

  /// Type of resource. Always compute#targetHttpProxyList for lists of target
  /// HTTP proxies.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  TargetHttpProxyListWarning warning;

  TargetHttpProxyList();

  TargetHttpProxyList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = _json["items"]
          .map((value) => new TargetHttpProxy.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new TargetHttpProxyListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class TargetHttpsProxiesSetSslCertificatesRequest {
  /// New set of SslCertificate resources to associate with this
  /// TargetHttpsProxy resource. Currently exactly one SslCertificate resource
  /// must be specified.
  core.List<core.String> sslCertificates;

  TargetHttpsProxiesSetSslCertificatesRequest();

  TargetHttpsProxiesSetSslCertificatesRequest.fromJson(core.Map _json) {
    if (_json.containsKey("sslCertificates")) {
      sslCertificates = _json["sslCertificates"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (sslCertificates != null) {
      _json["sslCertificates"] = sslCertificates;
    }
    return _json;
  }
}

/// A TargetHttpsProxy resource. This resource defines an HTTPS proxy. (==
/// resource_for beta.targetHttpsProxies ==) (== resource_for
/// v1.targetHttpsProxies ==)
class TargetHttpsProxy {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of resource. Always compute#targetHttpsProxy for target
  /// HTTPS proxies.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
  /// be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// URLs to SslCertificate resources that are used to authenticate connections
  /// between users and the load balancer. Currently, exactly one SSL
  /// certificate must be specified.
  core.List<core.String> sslCertificates;

  /// A fully-qualified or valid partial URL to the UrlMap resource that defines
  /// the mapping from URL to the BackendService. For example, the following are
  /// all valid URLs for specifying a URL map:
  /// -
  /// https://www.googleapis.compute/v1/projects/project/global/urlMaps/url-map
  /// - projects/project/global/urlMaps/url-map
  /// - global/urlMaps/url-map
  core.String urlMap;

  TargetHttpsProxy();

  TargetHttpsProxy.fromJson(core.Map _json) {
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("sslCertificates")) {
      sslCertificates = _json["sslCertificates"];
    }
    if (_json.containsKey("urlMap")) {
      urlMap = _json["urlMap"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (sslCertificates != null) {
      _json["sslCertificates"] = sslCertificates;
    }
    if (urlMap != null) {
      _json["urlMap"] = urlMap;
    }
    return _json;
  }
}

class TargetHttpsProxyListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  TargetHttpsProxyListWarningData();

  TargetHttpsProxyListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class TargetHttpsProxyListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<TargetHttpsProxyListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  TargetHttpsProxyListWarning();

  TargetHttpsProxyListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new TargetHttpsProxyListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of TargetHttpsProxy resources.
class TargetHttpsProxyList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of TargetHttpsProxy resources.
  core.List<TargetHttpsProxy> items;

  /// Type of resource. Always compute#targetHttpsProxyList for lists of target
  /// HTTPS proxies.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  TargetHttpsProxyListWarning warning;

  TargetHttpsProxyList();

  TargetHttpsProxyList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = _json["items"]
          .map((value) => new TargetHttpsProxy.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new TargetHttpsProxyListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// A TargetInstance resource. This resource defines an endpoint instance that
/// terminates traffic of certain protocols. (== resource_for
/// beta.targetInstances ==) (== resource_for v1.targetInstances ==)
class TargetInstance {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// A URL to the virtual machine instance that handles traffic for this target
  /// instance. When creating a target instance, you can provide the
  /// fully-qualified URL or a valid partial URL to the desired virtual machine.
  /// For example, the following are all valid URLs:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone/instances/instance
  /// - projects/project/zones/zone/instances/instance
  /// - zones/zone/instances/instance
  core.String instance;

  /// [Output Only] The type of the resource. Always compute#targetInstance for
  /// target instances.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
  /// be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// NAT option controlling how IPs are NAT'ed to the instance. Currently only
  /// NO_NAT (default value) is supported.
  /// Possible string values are:
  /// - "NO_NAT"
  core.String natPolicy;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] URL of the zone where the target instance resides. You must
  /// specify this field as part of the HTTP request URL. It is not settable as
  /// a field in the request body.
  core.String zone;

  TargetInstance();

  TargetInstance.fromJson(core.Map _json) {
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("instance")) {
      instance = _json["instance"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("natPolicy")) {
      natPolicy = _json["natPolicy"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("zone")) {
      zone = _json["zone"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (instance != null) {
      _json["instance"] = instance;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (natPolicy != null) {
      _json["natPolicy"] = natPolicy;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (zone != null) {
      _json["zone"] = zone;
    }
    return _json;
  }
}

class TargetInstanceAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  TargetInstanceAggregatedListWarningData();

  TargetInstanceAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class TargetInstanceAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<TargetInstanceAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  TargetInstanceAggregatedListWarning();

  TargetInstanceAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) =>
              new TargetInstanceAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class TargetInstanceAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of TargetInstance resources.
  core.Map<core.String, TargetInstancesScopedList> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  TargetInstanceAggregatedListWarning warning;

  TargetInstanceAggregatedList();

  TargetInstanceAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons.mapMap<core.Map<core.String, core.Object>,
              TargetInstancesScopedList>(
          _json["items"],
          (core.Map<core.String, core.Object> item) =>
              new TargetInstancesScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning =
          new TargetInstanceAggregatedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = commons.mapMap<TargetInstancesScopedList,
              core.Map<core.String, core.Object>>(
          items, (TargetInstancesScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class TargetInstanceListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  TargetInstanceListWarningData();

  TargetInstanceListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class TargetInstanceListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<TargetInstanceListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  TargetInstanceListWarning();

  TargetInstanceListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new TargetInstanceListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of TargetInstance resources.
class TargetInstanceList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of TargetInstance resources.
  core.List<TargetInstance> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  TargetInstanceListWarning warning;

  TargetInstanceList();

  TargetInstanceList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = _json["items"]
          .map((value) => new TargetInstance.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new TargetInstanceListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class TargetInstancesScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  TargetInstancesScopedListWarningData();

  TargetInstancesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// Informational warning which replaces the list of addresses when the list is
/// empty.
class TargetInstancesScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<TargetInstancesScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  TargetInstancesScopedListWarning();

  TargetInstancesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) =>
              new TargetInstancesScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class TargetInstancesScopedList {
  /// List of target instances contained in this scope.
  core.List<TargetInstance> targetInstances;

  /// Informational warning which replaces the list of addresses when the list
  /// is empty.
  TargetInstancesScopedListWarning warning;

  TargetInstancesScopedList();

  TargetInstancesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("targetInstances")) {
      targetInstances = _json["targetInstances"]
          .map((value) => new TargetInstance.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning = new TargetInstancesScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (targetInstances != null) {
      _json["targetInstances"] =
          targetInstances.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// A TargetPool resource. This resource defines a pool of instances, an
/// associated HttpHealthCheck resource, and the fallback target pool. (==
/// resource_for beta.targetPools ==) (== resource_for v1.targetPools ==)
class TargetPool {
  /// This field is applicable only when the containing target pool is serving a
  /// forwarding rule as the primary pool, and its failoverRatio field is
  /// properly set to a value between [0, 1].
  ///
  /// backupPool and failoverRatio together define the fallback behavior of the
  /// primary target pool: if the ratio of the healthy instances in the primary
  /// pool is at or below failoverRatio, traffic arriving at the load-balanced
  /// IP will be directed to the backup pool.
  ///
  /// In case where failoverRatio and backupPool are not set, or all the
  /// instances in the backup pool are unhealthy, the traffic will be directed
  /// back to the primary pool in the "force" mode, where traffic will be spread
  /// to the healthy instances with the best effort, or to all instances when no
  /// instance is healthy.
  core.String backupPool;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// This field is applicable only when the containing target pool is serving a
  /// forwarding rule as the primary pool (i.e., not as a backup pool to some
  /// other target pool). The value of the field must be in [0, 1].
  ///
  /// If set, backupPool must also be set. They together define the fallback
  /// behavior of the primary target pool: if the ratio of the healthy instances
  /// in the primary pool is at or below this number, traffic arriving at the
  /// load-balanced IP will be directed to the backup pool.
  ///
  /// In case where failoverRatio is not set or all the instances in the backup
  /// pool are unhealthy, the traffic will be directed back to the primary pool
  /// in the "force" mode, where traffic will be spread to the healthy instances
  /// with the best effort, or to all instances when no instance is healthy.
  core.double failoverRatio;

  /// The URL of the HttpHealthCheck resource. A member instance in this pool is
  /// considered healthy if and only if the health checks pass. An empty list
  /// means all member instances will be considered healthy at all times. Only
  /// HttpHealthChecks are supported. Only one health check may be specified.
  core.List<core.String> healthChecks;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// A list of resource URLs to the virtual machine instances serving this
  /// pool. They must live in zones contained in the same region as this pool.
  core.List<core.String> instances;

  /// [Output Only] Type of the resource. Always compute#targetPool for target
  /// pools.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
  /// be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// [Output Only] URL of the region where the target pool resides.
  core.String region;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// Sesssion affinity option, must be one of the following values:
  /// NONE: Connections from the same client IP may go to any instance in the
  /// pool.
  /// CLIENT_IP: Connections from the same client IP will go to the same
  /// instance in the pool while that instance remains healthy.
  /// CLIENT_IP_PROTO: Connections from the same client IP with the same IP
  /// protocol will go to the same instance in the pool while that instance
  /// remains healthy.
  /// Possible string values are:
  /// - "CLIENT_IP"
  /// - "CLIENT_IP_PORT_PROTO"
  /// - "CLIENT_IP_PROTO"
  /// - "GENERATED_COOKIE"
  /// - "NONE"
  core.String sessionAffinity;

  TargetPool();

  TargetPool.fromJson(core.Map _json) {
    if (_json.containsKey("backupPool")) {
      backupPool = _json["backupPool"];
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("failoverRatio")) {
      failoverRatio = _json["failoverRatio"];
    }
    if (_json.containsKey("healthChecks")) {
      healthChecks = _json["healthChecks"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("instances")) {
      instances = _json["instances"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("region")) {
      region = _json["region"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("sessionAffinity")) {
      sessionAffinity = _json["sessionAffinity"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (backupPool != null) {
      _json["backupPool"] = backupPool;
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (failoverRatio != null) {
      _json["failoverRatio"] = failoverRatio;
    }
    if (healthChecks != null) {
      _json["healthChecks"] = healthChecks;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (instances != null) {
      _json["instances"] = instances;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (region != null) {
      _json["region"] = region;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (sessionAffinity != null) {
      _json["sessionAffinity"] = sessionAffinity;
    }
    return _json;
  }
}

class TargetPoolAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  TargetPoolAggregatedListWarningData();

  TargetPoolAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class TargetPoolAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<TargetPoolAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  TargetPoolAggregatedListWarning();

  TargetPoolAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) =>
              new TargetPoolAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class TargetPoolAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of TargetPool resources.
  core.Map<core.String, TargetPoolsScopedList> items;

  /// [Output Only] Type of resource. Always compute#targetPoolAggregatedList
  /// for aggregated lists of target pools.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  TargetPoolAggregatedListWarning warning;

  TargetPoolAggregatedList();

  TargetPoolAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons
          .mapMap<core.Map<core.String, core.Object>, TargetPoolsScopedList>(
              _json["items"],
              (core.Map<core.String, core.Object> item) =>
                  new TargetPoolsScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new TargetPoolAggregatedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = commons
          .mapMap<TargetPoolsScopedList, core.Map<core.String, core.Object>>(
              items, (TargetPoolsScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class TargetPoolInstanceHealth {
  core.List<HealthStatus> healthStatus;

  /// [Output Only] Type of resource. Always compute#targetPoolInstanceHealth
  /// when checking the health of an instance.
  core.String kind;

  TargetPoolInstanceHealth();

  TargetPoolInstanceHealth.fromJson(core.Map _json) {
    if (_json.containsKey("healthStatus")) {
      healthStatus = _json["healthStatus"]
          .map((value) => new HealthStatus.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (healthStatus != null) {
      _json["healthStatus"] =
          healthStatus.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    return _json;
  }
}

class TargetPoolListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  TargetPoolListWarningData();

  TargetPoolListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class TargetPoolListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<TargetPoolListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  TargetPoolListWarning();

  TargetPoolListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new TargetPoolListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of TargetPool resources.
class TargetPoolList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of TargetPool resources.
  core.List<TargetPool> items;

  /// [Output Only] Type of resource. Always compute#targetPoolList for lists of
  /// target pools.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  TargetPoolListWarning warning;

  TargetPoolList();

  TargetPoolList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = _json["items"]
          .map((value) => new TargetPool.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new TargetPoolListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class TargetPoolsAddHealthCheckRequest {
  /// The HttpHealthCheck to add to the target pool.
  core.List<HealthCheckReference> healthChecks;

  TargetPoolsAddHealthCheckRequest();

  TargetPoolsAddHealthCheckRequest.fromJson(core.Map _json) {
    if (_json.containsKey("healthChecks")) {
      healthChecks = _json["healthChecks"]
          .map((value) => new HealthCheckReference.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (healthChecks != null) {
      _json["healthChecks"] =
          healthChecks.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

class TargetPoolsAddInstanceRequest {
  /// A full or partial URL to an instance to add to this target pool. This can
  /// be a full or partial URL. For example, the following are valid URLs:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project-id/zones/zone/instances/instance-name
  /// - projects/project-id/zones/zone/instances/instance-name
  /// - zones/zone/instances/instance-name
  core.List<InstanceReference> instances;

  TargetPoolsAddInstanceRequest();

  TargetPoolsAddInstanceRequest.fromJson(core.Map _json) {
    if (_json.containsKey("instances")) {
      instances = _json["instances"]
          .map((value) => new InstanceReference.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (instances != null) {
      _json["instances"] = instances.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

class TargetPoolsRemoveHealthCheckRequest {
  /// Health check URL to be removed. This can be a full or valid partial URL.
  /// For example, the following are valid URLs:
  /// -
  /// https://www.googleapis.com/compute/beta/projects/project/global/httpHealthChecks/health-check
  /// - projects/project/global/httpHealthChecks/health-check
  /// - global/httpHealthChecks/health-check
  core.List<HealthCheckReference> healthChecks;

  TargetPoolsRemoveHealthCheckRequest();

  TargetPoolsRemoveHealthCheckRequest.fromJson(core.Map _json) {
    if (_json.containsKey("healthChecks")) {
      healthChecks = _json["healthChecks"]
          .map((value) => new HealthCheckReference.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (healthChecks != null) {
      _json["healthChecks"] =
          healthChecks.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

class TargetPoolsRemoveInstanceRequest {
  /// URLs of the instances to be removed from target pool.
  core.List<InstanceReference> instances;

  TargetPoolsRemoveInstanceRequest();

  TargetPoolsRemoveInstanceRequest.fromJson(core.Map _json) {
    if (_json.containsKey("instances")) {
      instances = _json["instances"]
          .map((value) => new InstanceReference.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (instances != null) {
      _json["instances"] = instances.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

class TargetPoolsScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  TargetPoolsScopedListWarningData();

  TargetPoolsScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// Informational warning which replaces the list of addresses when the list is
/// empty.
class TargetPoolsScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<TargetPoolsScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  TargetPoolsScopedListWarning();

  TargetPoolsScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new TargetPoolsScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class TargetPoolsScopedList {
  /// List of target pools contained in this scope.
  core.List<TargetPool> targetPools;

  /// Informational warning which replaces the list of addresses when the list
  /// is empty.
  TargetPoolsScopedListWarning warning;

  TargetPoolsScopedList();

  TargetPoolsScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("targetPools")) {
      targetPools = _json["targetPools"]
          .map((value) => new TargetPool.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning = new TargetPoolsScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (targetPools != null) {
      _json["targetPools"] =
          targetPools.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class TargetReference {
  core.String target;

  TargetReference();

  TargetReference.fromJson(core.Map _json) {
    if (_json.containsKey("target")) {
      target = _json["target"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (target != null) {
      _json["target"] = target;
    }
    return _json;
  }
}

class TargetSslProxiesSetBackendServiceRequest {
  /// The URL of the new BackendService resource for the targetSslProxy.
  core.String service;

  TargetSslProxiesSetBackendServiceRequest();

  TargetSslProxiesSetBackendServiceRequest.fromJson(core.Map _json) {
    if (_json.containsKey("service")) {
      service = _json["service"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (service != null) {
      _json["service"] = service;
    }
    return _json;
  }
}

class TargetSslProxiesSetProxyHeaderRequest {
  /// The new type of proxy header to append before sending data to the backend.
  /// NONE or PROXY_V1 are allowed.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String proxyHeader;

  TargetSslProxiesSetProxyHeaderRequest();

  TargetSslProxiesSetProxyHeaderRequest.fromJson(core.Map _json) {
    if (_json.containsKey("proxyHeader")) {
      proxyHeader = _json["proxyHeader"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (proxyHeader != null) {
      _json["proxyHeader"] = proxyHeader;
    }
    return _json;
  }
}

class TargetSslProxiesSetSslCertificatesRequest {
  /// New set of URLs to SslCertificate resources to associate with this
  /// TargetSslProxy. Currently exactly one ssl certificate must be specified.
  core.List<core.String> sslCertificates;

  TargetSslProxiesSetSslCertificatesRequest();

  TargetSslProxiesSetSslCertificatesRequest.fromJson(core.Map _json) {
    if (_json.containsKey("sslCertificates")) {
      sslCertificates = _json["sslCertificates"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (sslCertificates != null) {
      _json["sslCertificates"] = sslCertificates;
    }
    return _json;
  }
}

/// A TargetSslProxy resource. This resource defines an SSL proxy. (==
/// resource_for beta.targetSslProxies ==) (== resource_for v1.targetSslProxies
/// ==)
class TargetSslProxy {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#targetSslProxy for
  /// target SSL proxies.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
  /// be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// Specifies the type of proxy header to append before sending data to the
  /// backend, either NONE or PROXY_V1. The default is NONE.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String proxyHeader;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// URL to the BackendService resource.
  core.String service;

  /// URLs to SslCertificate resources that are used to authenticate connections
  /// to Backends. Currently exactly one SSL certificate must be specified.
  core.List<core.String> sslCertificates;

  TargetSslProxy();

  TargetSslProxy.fromJson(core.Map _json) {
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("proxyHeader")) {
      proxyHeader = _json["proxyHeader"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("service")) {
      service = _json["service"];
    }
    if (_json.containsKey("sslCertificates")) {
      sslCertificates = _json["sslCertificates"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (proxyHeader != null) {
      _json["proxyHeader"] = proxyHeader;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (service != null) {
      _json["service"] = service;
    }
    if (sslCertificates != null) {
      _json["sslCertificates"] = sslCertificates;
    }
    return _json;
  }
}

class TargetSslProxyListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  TargetSslProxyListWarningData();

  TargetSslProxyListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class TargetSslProxyListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<TargetSslProxyListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  TargetSslProxyListWarning();

  TargetSslProxyListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new TargetSslProxyListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of TargetSslProxy resources.
class TargetSslProxyList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of TargetSslProxy resources.
  core.List<TargetSslProxy> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  TargetSslProxyListWarning warning;

  TargetSslProxyList();

  TargetSslProxyList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = _json["items"]
          .map((value) => new TargetSslProxy.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new TargetSslProxyListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class TargetTcpProxiesSetBackendServiceRequest {
  /// The URL of the new BackendService resource for the targetTcpProxy.
  core.String service;

  TargetTcpProxiesSetBackendServiceRequest();

  TargetTcpProxiesSetBackendServiceRequest.fromJson(core.Map _json) {
    if (_json.containsKey("service")) {
      service = _json["service"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (service != null) {
      _json["service"] = service;
    }
    return _json;
  }
}

class TargetTcpProxiesSetProxyHeaderRequest {
  /// The new type of proxy header to append before sending data to the backend.
  /// NONE or PROXY_V1 are allowed.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String proxyHeader;

  TargetTcpProxiesSetProxyHeaderRequest();

  TargetTcpProxiesSetProxyHeaderRequest.fromJson(core.Map _json) {
    if (_json.containsKey("proxyHeader")) {
      proxyHeader = _json["proxyHeader"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (proxyHeader != null) {
      _json["proxyHeader"] = proxyHeader;
    }
    return _json;
  }
}

/// A TargetTcpProxy resource. This resource defines a TCP proxy. (==
/// resource_for beta.targetTcpProxies ==) (== resource_for v1.targetTcpProxies
/// ==)
class TargetTcpProxy {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#targetTcpProxy for
  /// target TCP proxies.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
  /// be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// Specifies the type of proxy header to append before sending data to the
  /// backend, either NONE or PROXY_V1. The default is NONE.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String proxyHeader;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// URL to the BackendService resource.
  core.String service;

  TargetTcpProxy();

  TargetTcpProxy.fromJson(core.Map _json) {
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("proxyHeader")) {
      proxyHeader = _json["proxyHeader"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("service")) {
      service = _json["service"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (proxyHeader != null) {
      _json["proxyHeader"] = proxyHeader;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (service != null) {
      _json["service"] = service;
    }
    return _json;
  }
}

class TargetTcpProxyListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  TargetTcpProxyListWarningData();

  TargetTcpProxyListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class TargetTcpProxyListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<TargetTcpProxyListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  TargetTcpProxyListWarning();

  TargetTcpProxyListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new TargetTcpProxyListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of TargetTcpProxy resources.
class TargetTcpProxyList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of TargetTcpProxy resources.
  core.List<TargetTcpProxy> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  TargetTcpProxyListWarning warning;

  TargetTcpProxyList();

  TargetTcpProxyList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = _json["items"]
          .map((value) => new TargetTcpProxy.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new TargetTcpProxyListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// Represents a Target VPN gateway resource. (== resource_for
/// beta.targetVpnGateways ==) (== resource_for v1.targetVpnGateways ==)
class TargetVpnGateway {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] A list of URLs to the ForwardingRule resources.
  /// ForwardingRules are created using compute.forwardingRules.insert and
  /// associated to a VPN gateway.
  core.List<core.String> forwardingRules;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of resource. Always compute#targetVpnGateway for target
  /// VPN gateways.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
  /// be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// URL of the network to which this VPN gateway is attached. Provided by the
  /// client when the VPN gateway is created.
  core.String network;

  /// [Output Only] URL of the region where the target VPN gateway resides. You
  /// must specify this field as part of the HTTP request URL. It is not
  /// settable as a field in the request body.
  core.String region;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] The status of the VPN gateway.
  /// Possible string values are:
  /// - "CREATING"
  /// - "DELETING"
  /// - "FAILED"
  /// - "READY"
  core.String status;

  /// [Output Only] A list of URLs to VpnTunnel resources. VpnTunnels are
  /// created using compute.vpntunnels.insert method and associated to a VPN
  /// gateway.
  core.List<core.String> tunnels;

  TargetVpnGateway();

  TargetVpnGateway.fromJson(core.Map _json) {
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("forwardingRules")) {
      forwardingRules = _json["forwardingRules"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("network")) {
      network = _json["network"];
    }
    if (_json.containsKey("region")) {
      region = _json["region"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("status")) {
      status = _json["status"];
    }
    if (_json.containsKey("tunnels")) {
      tunnels = _json["tunnels"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (forwardingRules != null) {
      _json["forwardingRules"] = forwardingRules;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (network != null) {
      _json["network"] = network;
    }
    if (region != null) {
      _json["region"] = region;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (status != null) {
      _json["status"] = status;
    }
    if (tunnels != null) {
      _json["tunnels"] = tunnels;
    }
    return _json;
  }
}

class TargetVpnGatewayAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  TargetVpnGatewayAggregatedListWarningData();

  TargetVpnGatewayAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class TargetVpnGatewayAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<TargetVpnGatewayAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  TargetVpnGatewayAggregatedListWarning();

  TargetVpnGatewayAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) =>
              new TargetVpnGatewayAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class TargetVpnGatewayAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of TargetVpnGateway resources.
  core.Map<core.String, TargetVpnGatewaysScopedList> items;

  /// [Output Only] Type of resource. Always compute#targetVpnGateway for target
  /// VPN gateways.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  TargetVpnGatewayAggregatedListWarning warning;

  TargetVpnGatewayAggregatedList();

  TargetVpnGatewayAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons.mapMap<core.Map<core.String, core.Object>,
              TargetVpnGatewaysScopedList>(
          _json["items"],
          (core.Map<core.String, core.Object> item) =>
              new TargetVpnGatewaysScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning =
          new TargetVpnGatewayAggregatedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = commons.mapMap<TargetVpnGatewaysScopedList,
              core.Map<core.String, core.Object>>(
          items, (TargetVpnGatewaysScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class TargetVpnGatewayListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  TargetVpnGatewayListWarningData();

  TargetVpnGatewayListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class TargetVpnGatewayListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<TargetVpnGatewayListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  TargetVpnGatewayListWarning();

  TargetVpnGatewayListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new TargetVpnGatewayListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of TargetVpnGateway resources.
class TargetVpnGatewayList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of TargetVpnGateway resources.
  core.List<TargetVpnGateway> items;

  /// [Output Only] Type of resource. Always compute#targetVpnGateway for target
  /// VPN gateways.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  TargetVpnGatewayListWarning warning;

  TargetVpnGatewayList();

  TargetVpnGatewayList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = _json["items"]
          .map((value) => new TargetVpnGateway.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new TargetVpnGatewayListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class TargetVpnGatewaysScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  TargetVpnGatewaysScopedListWarningData();

  TargetVpnGatewaysScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning which replaces the list of addresses
/// when the list is empty.
class TargetVpnGatewaysScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<TargetVpnGatewaysScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  TargetVpnGatewaysScopedListWarning();

  TargetVpnGatewaysScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) =>
              new TargetVpnGatewaysScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class TargetVpnGatewaysScopedList {
  /// [Output Only] List of target vpn gateways contained in this scope.
  core.List<TargetVpnGateway> targetVpnGateways;

  /// [Output Only] Informational warning which replaces the list of addresses
  /// when the list is empty.
  TargetVpnGatewaysScopedListWarning warning;

  TargetVpnGatewaysScopedList();

  TargetVpnGatewaysScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("targetVpnGateways")) {
      targetVpnGateways = _json["targetVpnGateways"]
          .map((value) => new TargetVpnGateway.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning =
          new TargetVpnGatewaysScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (targetVpnGateways != null) {
      _json["targetVpnGateways"] =
          targetVpnGateways.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class TestFailure {
  core.String actualService;
  core.String expectedService;
  core.String host;
  core.String path;

  TestFailure();

  TestFailure.fromJson(core.Map _json) {
    if (_json.containsKey("actualService")) {
      actualService = _json["actualService"];
    }
    if (_json.containsKey("expectedService")) {
      expectedService = _json["expectedService"];
    }
    if (_json.containsKey("host")) {
      host = _json["host"];
    }
    if (_json.containsKey("path")) {
      path = _json["path"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (actualService != null) {
      _json["actualService"] = actualService;
    }
    if (expectedService != null) {
      _json["expectedService"] = expectedService;
    }
    if (host != null) {
      _json["host"] = host;
    }
    if (path != null) {
      _json["path"] = path;
    }
    return _json;
  }
}

/// A UrlMap resource. This resource defines the mapping from URL to the
/// BackendService resource, based on the "longest-match" of the URL's host and
/// path.
class UrlMap {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// The URL of the BackendService resource if none of the hostRules match.
  core.String defaultService;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// Fingerprint of this resource. A hash of the contents stored in this
  /// object. This field is used in optimistic locking. This field will be
  /// ignored when inserting a UrlMap. An up-to-date fingerprint must be
  /// provided in order to update the UrlMap.
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes {
    return convert.BASE64.decode(fingerprint);
  }

  void set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.BASE64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  /// The list of HostRules to use against the URL.
  core.List<HostRule> hostRules;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#urlMaps for url maps.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
  /// be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// The list of named PathMatchers to use against the URL.
  core.List<PathMatcher> pathMatchers;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// The list of expected URL mapping tests. Request to update this UrlMap will
  /// succeed only if all of the test cases pass. You can specify a maximum of
  /// 100 tests per UrlMap.
  core.List<UrlMapTest> tests;

  UrlMap();

  UrlMap.fromJson(core.Map _json) {
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("defaultService")) {
      defaultService = _json["defaultService"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("fingerprint")) {
      fingerprint = _json["fingerprint"];
    }
    if (_json.containsKey("hostRules")) {
      hostRules = _json["hostRules"]
          .map((value) => new HostRule.fromJson(value))
          .toList();
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("pathMatchers")) {
      pathMatchers = _json["pathMatchers"]
          .map((value) => new PathMatcher.fromJson(value))
          .toList();
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("tests")) {
      tests = _json["tests"]
          .map((value) => new UrlMapTest.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (defaultService != null) {
      _json["defaultService"] = defaultService;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (fingerprint != null) {
      _json["fingerprint"] = fingerprint;
    }
    if (hostRules != null) {
      _json["hostRules"] = hostRules.map((value) => (value).toJson()).toList();
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (pathMatchers != null) {
      _json["pathMatchers"] =
          pathMatchers.map((value) => (value).toJson()).toList();
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (tests != null) {
      _json["tests"] = tests.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

class UrlMapListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  UrlMapListWarningData();

  UrlMapListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class UrlMapListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<UrlMapListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  UrlMapListWarning();

  UrlMapListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new UrlMapListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of UrlMap resources.
class UrlMapList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of UrlMap resources.
  core.List<UrlMap> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  UrlMapListWarning warning;

  UrlMapList();

  UrlMapList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items =
          _json["items"].map((value) => new UrlMap.fromJson(value)).toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new UrlMapListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class UrlMapReference {
  core.String urlMap;

  UrlMapReference();

  UrlMapReference.fromJson(core.Map _json) {
    if (_json.containsKey("urlMap")) {
      urlMap = _json["urlMap"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (urlMap != null) {
      _json["urlMap"] = urlMap;
    }
    return _json;
  }
}

/// Message for the expected URL mappings.
class UrlMapTest {
  /// Description of this test case.
  core.String description;

  /// Host portion of the URL.
  core.String host;

  /// Path portion of the URL.
  core.String path;

  /// Expected BackendService resource the given URL should be mapped to.
  core.String service;

  UrlMapTest();

  UrlMapTest.fromJson(core.Map _json) {
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("host")) {
      host = _json["host"];
    }
    if (_json.containsKey("path")) {
      path = _json["path"];
    }
    if (_json.containsKey("service")) {
      service = _json["service"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (description != null) {
      _json["description"] = description;
    }
    if (host != null) {
      _json["host"] = host;
    }
    if (path != null) {
      _json["path"] = path;
    }
    if (service != null) {
      _json["service"] = service;
    }
    return _json;
  }
}

/// Message representing the validation result for a UrlMap.
class UrlMapValidationResult {
  core.List<core.String> loadErrors;

  /// Whether the given UrlMap can be successfully loaded. If false,
  /// 'loadErrors' indicates the reasons.
  core.bool loadSucceeded;
  core.List<TestFailure> testFailures;

  /// If successfully loaded, this field indicates whether the test passed. If
  /// false, 'testFailures's indicate the reason of failure.
  core.bool testPassed;

  UrlMapValidationResult();

  UrlMapValidationResult.fromJson(core.Map _json) {
    if (_json.containsKey("loadErrors")) {
      loadErrors = _json["loadErrors"];
    }
    if (_json.containsKey("loadSucceeded")) {
      loadSucceeded = _json["loadSucceeded"];
    }
    if (_json.containsKey("testFailures")) {
      testFailures = _json["testFailures"]
          .map((value) => new TestFailure.fromJson(value))
          .toList();
    }
    if (_json.containsKey("testPassed")) {
      testPassed = _json["testPassed"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (loadErrors != null) {
      _json["loadErrors"] = loadErrors;
    }
    if (loadSucceeded != null) {
      _json["loadSucceeded"] = loadSucceeded;
    }
    if (testFailures != null) {
      _json["testFailures"] =
          testFailures.map((value) => (value).toJson()).toList();
    }
    if (testPassed != null) {
      _json["testPassed"] = testPassed;
    }
    return _json;
  }
}

class UrlMapsValidateRequest {
  /// Content of the UrlMap to be validated.
  UrlMap resource;

  UrlMapsValidateRequest();

  UrlMapsValidateRequest.fromJson(core.Map _json) {
    if (_json.containsKey("resource")) {
      resource = new UrlMap.fromJson(_json["resource"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (resource != null) {
      _json["resource"] = (resource).toJson();
    }
    return _json;
  }
}

class UrlMapsValidateResponse {
  UrlMapValidationResult result;

  UrlMapsValidateResponse();

  UrlMapsValidateResponse.fromJson(core.Map _json) {
    if (_json.containsKey("result")) {
      result = new UrlMapValidationResult.fromJson(_json["result"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (result != null) {
      _json["result"] = (result).toJson();
    }
    return _json;
  }
}

/// The location in Cloud Storage and naming method of the daily usage report.
/// Contains bucket_name and report_name prefix.
class UsageExportLocation {
  /// The name of an existing bucket in Cloud Storage where the usage report
  /// object is stored. The Google Service Account is granted write access to
  /// this bucket. This can either be the bucket name by itself, such as
  /// example-bucket, or the bucket name with gs:// or
  /// https://storage.googleapis.com/ in front of it, such as
  /// gs://example-bucket.
  core.String bucketName;

  /// An optional prefix for the name of the usage report object stored in
  /// bucketName. If not supplied, defaults to usage. The report is stored as a
  /// CSV file named report_name_prefix_gce_YYYYMMDD.csv where YYYYMMDD is the
  /// day of the usage according to Pacific Time. If you supply a prefix, it
  /// should conform to Cloud Storage object naming conventions.
  core.String reportNamePrefix;

  UsageExportLocation();

  UsageExportLocation.fromJson(core.Map _json) {
    if (_json.containsKey("bucketName")) {
      bucketName = _json["bucketName"];
    }
    if (_json.containsKey("reportNamePrefix")) {
      reportNamePrefix = _json["reportNamePrefix"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (bucketName != null) {
      _json["bucketName"] = bucketName;
    }
    if (reportNamePrefix != null) {
      _json["reportNamePrefix"] = reportNamePrefix;
    }
    return _json;
  }
}

/// VPN tunnel resource. (== resource_for beta.vpnTunnels ==) (== resource_for
/// v1.vpnTunnels ==)
class VpnTunnel {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] Detailed status message for the VPN tunnel.
  core.String detailedStatus;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// IKE protocol version to use when establishing the VPN tunnel with peer VPN
  /// gateway. Acceptable IKE versions are 1 or 2. Default version is 2.
  core.int ikeVersion;

  /// [Output Only] Type of resource. Always compute#vpnTunnel for VPN tunnels.
  core.String kind;

  /// Local traffic selector to use when establishing the VPN tunnel with peer
  /// VPN gateway. The value should be a CIDR formatted string, for example:
  /// 192.168.0.0/16. The ranges should be disjoint. Only IPv4 is supported.
  core.List<core.String> localTrafficSelector;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
  /// be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// IP address of the peer VPN gateway. Only IPv4 is supported.
  core.String peerIp;

  /// [Output Only] URL of the region where the VPN tunnel resides. You must
  /// specify this field as part of the HTTP request URL. It is not settable as
  /// a field in the request body.
  core.String region;

  /// Remote traffic selectors to use when establishing the VPN tunnel with peer
  /// VPN gateway. The value should be a CIDR formatted string, for example:
  /// 192.168.0.0/16. The ranges should be disjoint. Only IPv4 is supported.
  core.List<core.String> remoteTrafficSelector;

  /// URL of router resource to be used for dynamic routing.
  core.String router;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// Shared secret used to set the secure session between the Cloud VPN gateway
  /// and the peer VPN gateway.
  core.String sharedSecret;

  /// Hash of the shared secret.
  core.String sharedSecretHash;

  /// [Output Only] The status of the VPN tunnel.
  /// Possible string values are:
  /// - "ALLOCATING_RESOURCES"
  /// - "AUTHORIZATION_ERROR"
  /// - "DEPROVISIONING"
  /// - "ESTABLISHED"
  /// - "FAILED"
  /// - "FIRST_HANDSHAKE"
  /// - "NEGOTIATION_FAILURE"
  /// - "NETWORK_ERROR"
  /// - "NO_INCOMING_PACKETS"
  /// - "PROVISIONING"
  /// - "REJECTED"
  /// - "WAITING_FOR_FULL_CONFIG"
  core.String status;

  /// URL of the Target VPN gateway with which this VPN tunnel is associated.
  /// Provided by the client when the VPN tunnel is created.
  core.String targetVpnGateway;

  VpnTunnel();

  VpnTunnel.fromJson(core.Map _json) {
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("detailedStatus")) {
      detailedStatus = _json["detailedStatus"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("ikeVersion")) {
      ikeVersion = _json["ikeVersion"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("localTrafficSelector")) {
      localTrafficSelector = _json["localTrafficSelector"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("peerIp")) {
      peerIp = _json["peerIp"];
    }
    if (_json.containsKey("region")) {
      region = _json["region"];
    }
    if (_json.containsKey("remoteTrafficSelector")) {
      remoteTrafficSelector = _json["remoteTrafficSelector"];
    }
    if (_json.containsKey("router")) {
      router = _json["router"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("sharedSecret")) {
      sharedSecret = _json["sharedSecret"];
    }
    if (_json.containsKey("sharedSecretHash")) {
      sharedSecretHash = _json["sharedSecretHash"];
    }
    if (_json.containsKey("status")) {
      status = _json["status"];
    }
    if (_json.containsKey("targetVpnGateway")) {
      targetVpnGateway = _json["targetVpnGateway"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (detailedStatus != null) {
      _json["detailedStatus"] = detailedStatus;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (ikeVersion != null) {
      _json["ikeVersion"] = ikeVersion;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (localTrafficSelector != null) {
      _json["localTrafficSelector"] = localTrafficSelector;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (peerIp != null) {
      _json["peerIp"] = peerIp;
    }
    if (region != null) {
      _json["region"] = region;
    }
    if (remoteTrafficSelector != null) {
      _json["remoteTrafficSelector"] = remoteTrafficSelector;
    }
    if (router != null) {
      _json["router"] = router;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (sharedSecret != null) {
      _json["sharedSecret"] = sharedSecret;
    }
    if (sharedSecretHash != null) {
      _json["sharedSecretHash"] = sharedSecretHash;
    }
    if (status != null) {
      _json["status"] = status;
    }
    if (targetVpnGateway != null) {
      _json["targetVpnGateway"] = targetVpnGateway;
    }
    return _json;
  }
}

class VpnTunnelAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  VpnTunnelAggregatedListWarningData();

  VpnTunnelAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class VpnTunnelAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<VpnTunnelAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  VpnTunnelAggregatedListWarning();

  VpnTunnelAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map(
              (value) => new VpnTunnelAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class VpnTunnelAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of VpnTunnelsScopedList resources.
  core.Map<core.String, VpnTunnelsScopedList> items;

  /// [Output Only] Type of resource. Always compute#vpnTunnel for VPN tunnels.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  VpnTunnelAggregatedListWarning warning;

  VpnTunnelAggregatedList();

  VpnTunnelAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons
          .mapMap<core.Map<core.String, core.Object>, VpnTunnelsScopedList>(
              _json["items"],
              (core.Map<core.String, core.Object> item) =>
                  new VpnTunnelsScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new VpnTunnelAggregatedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = commons
          .mapMap<VpnTunnelsScopedList, core.Map<core.String, core.Object>>(
              items, (VpnTunnelsScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class VpnTunnelListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  VpnTunnelListWarningData();

  VpnTunnelListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class VpnTunnelListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<VpnTunnelListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  VpnTunnelListWarning();

  VpnTunnelListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new VpnTunnelListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of VpnTunnel resources.
class VpnTunnelList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of VpnTunnel resources.
  core.List<VpnTunnel> items;

  /// [Output Only] Type of resource. Always compute#vpnTunnel for VPN tunnels.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  VpnTunnelListWarning warning;

  VpnTunnelList();

  VpnTunnelList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items =
          _json["items"].map((value) => new VpnTunnel.fromJson(value)).toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new VpnTunnelListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class VpnTunnelsScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  VpnTunnelsScopedListWarningData();

  VpnTunnelsScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// Informational warning which replaces the list of addresses when the list is
/// empty.
class VpnTunnelsScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<VpnTunnelsScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  VpnTunnelsScopedListWarning();

  VpnTunnelsScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new VpnTunnelsScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class VpnTunnelsScopedList {
  /// List of vpn tunnels contained in this scope.
  core.List<VpnTunnel> vpnTunnels;

  /// Informational warning which replaces the list of addresses when the list
  /// is empty.
  VpnTunnelsScopedListWarning warning;

  VpnTunnelsScopedList();

  VpnTunnelsScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("vpnTunnels")) {
      vpnTunnels = _json["vpnTunnels"]
          .map((value) => new VpnTunnel.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning = new VpnTunnelsScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (vpnTunnels != null) {
      _json["vpnTunnels"] =
          vpnTunnels.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class XpnHostListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  XpnHostListWarningData();

  XpnHostListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class XpnHostListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<XpnHostListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  XpnHostListWarning();

  XpnHostListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new XpnHostListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class XpnHostList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// [Output Only] A list of shared VPC host project URLs.
  core.List<Project> items;

  /// [Output Only] Type of resource. Always compute#xpnHostList for lists of
  /// shared VPC hosts.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  XpnHostListWarning warning;

  XpnHostList();

  XpnHostList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items =
          _json["items"].map((value) => new Project.fromJson(value)).toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new XpnHostListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// Service resource (a.k.a service project) ID.
class XpnResourceId {
  /// The ID of the service resource. In the case of projects, this field
  /// matches the project ID (e.g., my-project), not the project number (e.g.,
  /// 12345678).
  core.String id;

  /// The type of the service resource.
  /// Possible string values are:
  /// - "PROJECT"
  /// - "XPN_RESOURCE_TYPE_UNSPECIFIED"
  core.String type;

  XpnResourceId();

  XpnResourceId.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("type")) {
      type = _json["type"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (type != null) {
      _json["type"] = type;
    }
    return _json;
  }
}

/// A Zone resource. (== resource_for beta.zones ==) (== resource_for v1.zones
/// ==)
class Zone {
  /// [Output Only] Available cpu/platform selections for the zone.
  core.List<core.String> availableCpuPlatforms;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// [Output Only] The deprecation status associated with this zone.
  DeprecationStatus deprecated;

  /// [Output Only] Textual description of the resource.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#zone for zones.
  core.String kind;

  /// [Output Only] Name of the resource.
  core.String name;

  /// [Output Only] Full URL reference to the region which hosts the zone.
  core.String region;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] Status of the zone, either UP or DOWN.
  /// Possible string values are:
  /// - "DOWN"
  /// - "UP"
  core.String status;

  Zone();

  Zone.fromJson(core.Map _json) {
    if (_json.containsKey("availableCpuPlatforms")) {
      availableCpuPlatforms = _json["availableCpuPlatforms"];
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("deprecated")) {
      deprecated = new DeprecationStatus.fromJson(_json["deprecated"]);
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("region")) {
      region = _json["region"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("status")) {
      status = _json["status"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (availableCpuPlatforms != null) {
      _json["availableCpuPlatforms"] = availableCpuPlatforms;
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (deprecated != null) {
      _json["deprecated"] = (deprecated).toJson();
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (region != null) {
      _json["region"] = region;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (status != null) {
      _json["status"] = status;
    }
    return _json;
  }
}

class ZoneListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  ZoneListWarningData();

  ZoneListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class ZoneListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<ZoneListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  ZoneListWarning();

  ZoneListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = _json["data"]
          .map((value) => new ZoneListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of zone resources.
class ZoneList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Zone resources.
  core.List<Zone> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  ZoneListWarning warning;

  ZoneList();

  ZoneList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = _json["items"].map((value) => new Zone.fromJson(value)).toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new ZoneListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class ZoneSetLabelsRequest {
  /// The fingerprint of the previous set of labels for this resource, used to
  /// detect conflicts. The fingerprint is initially generated by Compute Engine
  /// and changes after every request to modify or update labels. You must
  /// always provide an up-to-date fingerprint hash in order to update or change
  /// labels. Make a get() request to the resource to get the latest
  /// fingerprint.
  core.String labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes {
    return convert.BASE64.decode(labelFingerprint);
  }

  void set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.BASE64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  /// The labels to set for this resource.
  core.Map<core.String, core.String> labels;

  ZoneSetLabelsRequest();

  ZoneSetLabelsRequest.fromJson(core.Map _json) {
    if (_json.containsKey("labelFingerprint")) {
      labelFingerprint = _json["labelFingerprint"];
    }
    if (_json.containsKey("labels")) {
      labels = _json["labels"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (labelFingerprint != null) {
      _json["labelFingerprint"] = labelFingerprint;
    }
    if (labels != null) {
      _json["labels"] = labels;
    }
    return _json;
  }
}
